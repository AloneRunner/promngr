
import {
    Match,
    Team,
    Player,
    MatchEvent,
    MatchEventType,
    Position,
    SimulationState,
    TacticType,
    TeamTactic,
    TeamMentality,
    PlayerPersonality,
    LineupStatus
} from '../types';

// === MISSING INTERFACE DEFINITION ===
interface PlayerState {
    targetX: number;
    targetY: number;
    isPressing: boolean;
    actionLock: number;
    sprintDistance?: number;
    runDistance?: number;
    currentStamina: number;
    incomingSignal?: Signal | null;
    outgoingSignal?: Signal | null;
    matchRating?: number;
    stats?: any;
    hasBall?: boolean;
    shotType?: string; // 'NORMAL', 'VOLLEY', 'BICYCLE', 'HEADER', 'CHIP', etc.
    isCollided?: boolean;
}

// --- UTILS ---
const dist = (x1: number, y1: number, x2: number, y2: number) => Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
const distSq = (x1: number, y1: number, x2: number, y2: number) => (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
const clamp = (val: number, min: number, max: number) => Math.max(min, Math.min(max, val));
const lerp = (start: number, end: number, t: number) => start * (1 - t) + end * t;

// === KAPSAMLÄ° YORGUNLUK ETKÄ°SÄ° SÄ°STEMÄ° ===
// Her stat iÃ§in ayrÄ± ayrÄ± yorgunluk etkisi hesaplar
// Kaleciler iÃ§in daha hafif, saha oyuncularÄ± iÃ§in daha aÄŸÄ±r cezalar

interface FatigueModifiers {
    // Fiziksel
    speed: number;
    strength: number;
    stamina: number;
    aggression: number;
    // Teknik
    finishing: number;
    passing: number;
    dribbling: number;
    tackling: number;
    goalkeeping: number;
    // Zihinsel
    positioning: number;
    composure: number;
    decisions: number;
    vision: number;
    leadership: number;
}

// Saha oyuncularÄ± iÃ§in yorgunluk modifikatÃ¶rleri
const getFieldPlayerFatigueModifiers = (stamina: number): FatigueModifiers => {
    if (stamina >= 80) {
        // 80-100: DinÃ§ - tam performans
        return {
            speed: 1.0, strength: 1.0, stamina: 1.0, aggression: 1.0,
            finishing: 1.0, passing: 1.0, dribbling: 1.0, tackling: 1.0, goalkeeping: 1.0,
            positioning: 1.0, composure: 1.0, decisions: 1.0, vision: 1.0, leadership: 1.0
        };
    } else if (stamina >= 60) {
        // 60-80: Hafif yorgun
        return {
            speed: 0.95, strength: 0.98, stamina: 0.95, aggression: 0.97,
            finishing: 0.94, passing: 0.95, dribbling: 0.93, tackling: 0.94, goalkeeping: 0.97,
            positioning: 0.93, composure: 0.92, decisions: 0.90, vision: 0.93, leadership: 0.95
        };
    } else if (stamina >= 40) {
        // 40-60: Orta yorgun - belirgin dÃ¼ÅŸÃ¼ÅŸ
        return {
            speed: 0.85, strength: 0.92, stamina: 0.85, aggression: 0.88,
            finishing: 0.82, passing: 0.85, dribbling: 0.80, tackling: 0.83, goalkeeping: 0.90,
            positioning: 0.80, composure: 0.78, decisions: 0.75, vision: 0.82, leadership: 0.88
        };
    } else if (stamina >= 20) {
        // 20-40: Ã‡ok yorgun - AÄžIR CEZALAR
        return {
            speed: 0.68, strength: 0.82, stamina: 0.70, aggression: 0.75,
            finishing: 0.65, passing: 0.70, dribbling: 0.60, tackling: 0.65, goalkeeping: 0.80,
            positioning: 0.62, composure: 0.55, decisions: 0.55, vision: 0.65, leadership: 0.78
        };
    } else {
        // 0-20: Bitik - deÄŸiÅŸiklik ÅŸart!
        return {
            speed: 0.45, strength: 0.70, stamina: 0.50, aggression: 0.60,
            finishing: 0.45, passing: 0.50, dribbling: 0.40, tackling: 0.45, goalkeeping: 0.65,
            positioning: 0.42, composure: 0.35, decisions: 0.35, vision: 0.45, leadership: 0.65
        };
    }
};

// Kaleciler iÃ§in Ã¶zel yorgunluk modifikatÃ¶rleri (daha hafif etkiler)
const getGoalkeeperFatigueModifiers = (stamina: number): FatigueModifiers => {
    if (stamina >= 70) {
        // 70-100: DinÃ§
        return {
            speed: 1.0, strength: 1.0, stamina: 1.0, aggression: 1.0,
            finishing: 1.0, passing: 1.0, dribbling: 1.0, tackling: 1.0, goalkeeping: 1.0,
            positioning: 1.0, composure: 1.0, decisions: 1.0, vision: 1.0, leadership: 1.0
        };
    } else if (stamina >= 50) {
        // 50-70: Hafif yorgun
        return {
            speed: 0.95, strength: 0.98, stamina: 0.95, aggression: 0.98,
            finishing: 1.0, passing: 0.98, dribbling: 0.98, tackling: 0.98, goalkeeping: 0.97,
            positioning: 0.96, composure: 0.95, decisions: 0.95, vision: 0.97, leadership: 0.98
        };
    } else if (stamina >= 30) {
        // 30-50: Orta yorgun
        return {
            speed: 0.90, strength: 0.95, stamina: 0.88, aggression: 0.92,
            finishing: 1.0, passing: 0.95, dribbling: 0.95, tackling: 0.92, goalkeeping: 0.93,
            positioning: 0.90, composure: 0.88, decisions: 0.88, vision: 0.92, leadership: 0.95
        };
    } else if (stamina >= 10) {
        // 10-30: Ã‡ok yorgun
        return {
            speed: 0.85, strength: 0.90, stamina: 0.80, aggression: 0.85,
            finishing: 1.0, passing: 0.90, dribbling: 0.90, tackling: 0.85, goalkeeping: 0.85,
            positioning: 0.82, composure: 0.80, decisions: 0.80, vision: 0.85, leadership: 0.90
        };
    } else {
        // 0-10: Bitik
        return {
            speed: 0.75, strength: 0.85, stamina: 0.70, aggression: 0.75,
            finishing: 1.0, passing: 0.85, dribbling: 0.85, tackling: 0.78, goalkeeping: 0.75,
            positioning: 0.70, composure: 0.65, decisions: 0.65, vision: 0.75, leadership: 0.85
        };
    }
};

// Oyuncu iÃ§in tÃ¼m yorgunluk modifikatÃ¶rlerini al
const getAllFatigueModifiers = (stamina: number, isGoalkeeper: boolean): FatigueModifiers => {
    return isGoalkeeper
        ? getGoalkeeperFatigueModifiers(stamina)
        : getFieldPlayerFatigueModifiers(stamina);
};

// === BASÄ°TLEÅžTÄ°RÄ°LMÄ°Åž YORGUNLUK FONKSÄ°YONU (geriye uyumluluk iÃ§in) ===
// type: 'physical' (hÄ±z, ivme), 'technical' (pas, ÅŸut, dribling), 'mental' (karar, pozisyon)
const getFatigueModifier = (stamina: number, type: 'physical' | 'technical' | 'mental'): number => {
    const mods = getFieldPlayerFatigueModifiers(stamina);
    if (type === 'physical') return mods.speed;
    if (type === 'technical') return mods.passing;
    return mods.decisions; // mental
};

// === YORGUNLUKLU STAT HESAPLAMA ===
// Bir oyuncunun yorgunluk dahil gerÃ§ek stat deÄŸerini hesaplar
const getEffectiveStat = (
    player: Player,
    statName: keyof FatigueModifiers,
    currentStamina: number
): number => {
    const isGK = player.position === Position.GK;
    const mods = getAllFatigueModifiers(currentStamina, isGK);
    const baseStat = (player.attributes as any)[statName] || 50;
    return baseStat * mods[statName];
};

// === STAT FLOOR SCALING ===
// ZayÄ±f statlarÄ± yukarÄ± Ã§ekerken gÃ¼Ã§lÃ¼ statlarÄ± aynen bÄ±rakÄ±r
// Ã–rnek: 50 -> 65, 60 -> 70, 70 -> 77, 80 -> 85, 90 -> 92, 100 -> 100
// Bu sayede zayÄ±f kaleci/defans daha az ezilir, gÃ¼Ã§lÃ¼ler aynÄ± kalÄ±r
const applyStatFloor = (stat: number, floor: number = 40): number => {
    // stat < floor ise floor'a Ã§ekilir
    // stat > floor ise kademeli olarak yukarÄ± kaydÄ±rÄ±lÄ±r
    // stat = 100 ise aynen kalÄ±r
    if (stat >= 100) return 100;
    if (stat <= floor) return floor + 5; // Minimum taban

    // floor ile 100 arasÄ±nÄ± sÄ±kÄ±ÅŸtÄ±r
    // FormÃ¼l: stat + (100 - stat) * compressionFactor
    // compressionFactor = (stat dÃ¼ÅŸtÃ¼kÃ§e artar)
    const range = 100 - floor;
    const normalizedStat = (stat - floor) / range; // 0 to 1

    // Logaritmik sÄ±kÄ±ÅŸtÄ±rma: dÃ¼ÅŸÃ¼k statlar daha fazla yÃ¼kselir
    const compression = 0.25 * (1 - normalizedStat); // 0.25 at floor, 0 at 100
    const boost = (100 - stat) * compression;

    return Math.min(100, stat + boost);
};

// --- CONSTANTS ---
export const TICKS_PER_MINUTE = 60; // ~3 seconds per minute at 1x speed (50ms per tick)
const DEBUG_MATCH = true; // Enable match analysis logging

// === GERÃ‡EK FUTBOL SAHASI BOYUTLARI (metre cinsinden) ===
const PITCH_LENGTH = 105;   // X ekseni: 0-105 metre
const PITCH_WIDTH = 68;     // Y ekseni: 0-68 metre
const PITCH_CENTER_X = 52.5; // Orta saha X
const PITCH_CENTER_Y = 34;   // Orta saha Y

// GerÃ§ek hÄ±zlar (metre/saniye, 1 tick = 1 saniye oyun sÃ¼resi)
// Sprint hÄ±zÄ±: ~30 km/h = 8.3 m/s, Top hÄ±zÄ±: ~120 km/h = 33 m/s
// Ama oyunda 60 tick = 1 dakika, yani Ã¶lÃ§eklendirme gerekli
// Eski 100 birim sisteminde 1.10 hÄ±z = 60 tick'te 66 birim = yaklaÅŸÄ±k yarÄ± saha
// Yeni sistemde aynÄ± oranÄ± koruyalÄ±m: 1.10 * (105/100) â‰ˆ 1.15
const MAX_PLAYER_SPEED = 1.15;  // metre/tick (Ã¶lÃ§eklendirilmiÅŸ)
const MAX_BALL_SPEED = 4.4;     // metre/tick (Ã¶lÃ§eklendirilmiÅŸ)
const BALL_FRICTION = 0.96;
const BALL_AIR_DRAG = 0.98;
const GRAVITY = 0.20;
const BALL_BOUNCE = 0.55;
const PLAYER_ACCELERATION = 0.12;
const PLAYER_TURN_SPEED = 0.25;

// AI Ranges (metre cinsinden - gerÃ§ek mesafeler)
const SHOOT_RANGE = 32;       // 30 â†’ 32m (ceza sahasÄ± dÄ±ÅŸÄ±ndan ÅŸut)
const PASS_RANGE_VISION = 52; // 50 â†’ 52m
const TACKLE_RANGE_BASE = 3.5;  // 4.2 â†’ 3.5m (Defans dengeli - ne Ã§ok kolay ne Ã§ok zor)
const PRESSING_RANGE = 18;     // 20 â†’ 18m (dengeli pressing)

// Kale BoyutlarÄ± (gerÃ§ek: 7.32m geniÅŸlik, merkez Y=34)
// Kale: Y = 34 Â± 3.66 = 30.34 - 37.66
const GOAL_Y_TOP = 30.34;
const GOAL_Y_BOTTOM = 37.66;
const GOAL_Y_CENTER = 34.0;

// Ceza sahasÄ± boyutlarÄ± (gerÃ§ek)
const PENALTY_BOX_DEPTH = 16.5;    // Kale Ã§izgisinden 16.5m
const PENALTY_BOX_WIDTH = 40.32;   // 40.32m geniÅŸlik (Y: 13.84 - 54.16)
const SIX_YARD_BOX_DEPTH = 5.5;    // 6 yard box = 5.5m
const PENALTY_SPOT = 11;           // PenaltÄ± noktasÄ± = 11m

// --- FM-STYLE RATING CALCULATOR ---
// Uses ALL 14 attributes with position-specific weights (like Football Manager)
// No attribute is ignored - each contributes with appropriate weight for the position

// Helper: Get attribute values with defaults
const getAttrValues = (attr: any) => ({
    fin: attr.finishing || 50,
    pas: attr.passing || 50,
    dri: attr.dribbling || 50,
    tac: attr.tackling || 50,
    gk: attr.goalkeeping || 10,
    spd: attr.speed || 50,
    sta: attr.stamina || 50,
    str: attr.strength || 50,
    dec: attr.decisions || 50,
    pos: attr.positioning || 50,
    vis: attr.vision || 50,
    com: attr.composure || 50,
    lea: attr.leadership || 50,
    agg: attr.aggression || 50,
});

// Helper: Calculate position-weighted attribute score
const calcPositionScore = (a: ReturnType<typeof getAttrValues>, position: Position): number => {
    if (position === Position.GK) {
        return (a.gk * 0.40) + (a.pos * 0.12) + (a.com * 0.10) + (a.dec * 0.08) +
            (a.str * 0.06) + (a.spd * 0.05) + (a.lea * 0.04) + (a.pas * 0.04) +
            (a.vis * 0.03) + (a.sta * 0.03) + (a.agg * 0.02) + (a.fin * 0.01) +
            (a.dri * 0.01) + (a.tac * 0.01);
    } else if (position === Position.DEF) {
        return (a.tac * 0.18) + (a.pos * 0.14) + (a.str * 0.12) + (a.spd * 0.10) +
            (a.com * 0.08) + (a.dec * 0.08) + (a.agg * 0.07) + (a.sta * 0.06) +
            (a.pas * 0.05) + (a.lea * 0.04) + (a.vis * 0.03) + (a.dri * 0.02) +
            (a.fin * 0.02) + (a.gk * 0.01);
    } else if (position === Position.MID) {
        return (a.pas * 0.15) + (a.vis * 0.13) + (a.sta * 0.10) + (a.dri * 0.10) +
            (a.dec * 0.09) + (a.com * 0.08) + (a.spd * 0.07) + (a.pos * 0.06) +
            (a.tac * 0.06) + (a.fin * 0.05) + (a.str * 0.04) + (a.lea * 0.03) +
            (a.agg * 0.03) + (a.gk * 0.01);
    } else { // FWD
        return (a.fin * 0.20) + (a.spd * 0.14) + (a.dri * 0.12) + (a.pos * 0.10) +
            (a.com * 0.10) + (a.dec * 0.06) + (a.str * 0.06) + (a.vis * 0.05) +
            (a.pas * 0.05) + (a.sta * 0.04) + (a.agg * 0.04) + (a.tac * 0.02) +
            (a.lea * 0.01) + (a.gk * 0.01);
    }
};

// === BASE OVERALL CALCULATOR (for player creation) ===
// Pure attribute-based, no anchor. Used when creating players from data.
export const calculateBaseOverall = (player: Player, position: Position): number => {
    if (!player || !player.attributes) return 60;
    const a = getAttrValues(player.attributes);
    const score = calcPositionScore(a, position);
    return Math.max(1, Math.floor(score));
};

// === EFFECTIVE RATING CALCULATOR (for display/UI) ===
// Uses base overall as anchor + position fit bonus + condition/morale penalties
export const calculateEffectiveRating = (player: Player, assignedPosition: Position, currentCondition: number = 100): number => {
    if (!player || !player.attributes) return 60;
    const a = getAttrValues(player.attributes);
    const attrScore = calcPositionScore(a, assignedPosition);

    // If player has no overall yet (creation time), return pure attribute score
    if (!player.overall || player.overall === 0) {
        return Math.max(1, Math.floor(attrScore));
    }

    // === ANCHOR TO BASE OVERALL ===
    const baseOvr = player.overall;
    const simpleAvg = (a.fin + a.pas + a.dri + a.tac + a.spd + a.sta + a.str + a.dec + a.pos + a.vis + a.com + a.lea + a.agg) / 13;
    const positionFit = attrScore - simpleAvg;
    const fitBonus = Math.max(-8, Math.min(8, positionFit));
    let score = baseOvr + fitBonus;

    // POSITION PENALTY (only when playing out of position)
    if (player.position !== assignedPosition) {
        if (player.position === Position.GK || assignedPosition === Position.GK) score *= 0.3;
        else if ((player.position === Position.DEF && assignedPosition === Position.FWD) || (player.position === Position.FWD && assignedPosition === Position.DEF)) score *= 0.7;
        else score *= 0.90;
    }

    // MORALE IMPACT (subtle: only negative below 40)
    if (player.morale < 40) {
        score -= Math.floor((40 - player.morale) / 10);
    }

    // CONDITION/FATIGUE IMPACT
    if (currentCondition < 30) {
        score -= Math.floor((30 - currentCondition) / 5);
    } else if (currentCondition < 60) {
        score -= Math.floor((60 - currentCondition) / 15);
    }

    return Math.max(1, Math.floor(score));
};

export const getRoleFromX = (x: number): Position => {
    if (x < 12) return Position.GK;
    if (x < 38) return Position.DEF;
    if (x < 72) return Position.MID;
    return Position.FWD;
};

export const getFormationStructure = (formation: TacticType) => {
    switch (formation) {
        case TacticType.T_442: return { DEF: 4, MID: 4, FWD: 2 };
        case TacticType.T_433: return { DEF: 4, MID: 3, FWD: 3 };
        case TacticType.T_352: return { DEF: 3, MID: 5, FWD: 2 };
        case TacticType.T_541: return { DEF: 5, MID: 4, FWD: 1 };
        case TacticType.T_451: return { DEF: 4, MID: 5, FWD: 1 };
        case TacticType.T_4231: return { DEF: 4, MID: 5, FWD: 1 };
        case TacticType.T_343: return { DEF: 3, MID: 4, FWD: 3 };
        case TacticType.T_4141: return { DEF: 4, MID: 5, FWD: 1 };
        case TacticType.T_532: return { DEF: 5, MID: 3, FWD: 2 };
        case TacticType.T_41212: return { DEF: 4, MID: 4, FWD: 2 };
        case TacticType.T_4321: return { DEF: 4, MID: 5, FWD: 1 };
        default: return { DEF: 4, MID: 4, FWD: 2 };
    }
};

const normalizePos = (p: Player): Position => {
    if (!p) return Position.MID;
    const raw = p.position as string;
    if (raw === 'KL' || raw === 'GK') return Position.GK;
    if (['STP', 'SÄžB', 'SLB', 'DEF', 'CB', 'LB', 'RB', 'SW'].includes(raw)) return Position.DEF;
    if (['MDO', 'MO', 'MOO', 'MID', 'CDM', 'CM', 'CAM', 'LM', 'RM'].includes(raw)) return Position.MID;
    return Position.FWD;
};

// === FORMASYON POZISYONLARI (105x68 motor koordinatlarÄ±) ===
// Motor koordinatlarÄ±: X=0-105 (sol-saÄŸ), Y=0-68 (Ã¼st-alt)
// Ev sahibi sol kaleye yakÄ±n baÅŸlar, deplasman saÄŸ kaleye
export const getBaseFormationOffset = (formation: TacticType, role: Position, index: number, totalInRole: number): { x: number, y: number } => {
    // Y ekseninde oyuncularÄ± yay (0-68 arasÄ±, merkez 34)
    const spreadY = (idx: number, tot: number, spanPercent: number) => {
        if (tot <= 1) return PITCH_WIDTH / 2; // 34
        const span = (spanPercent / 100) * PITCH_WIDTH;
        return (PITCH_WIDTH / 2) - (span / 2) + (span / (tot - 1)) * idx;
    };

    // X pozisyonunu 0-100'den 0-105'e Ã§evir
    const xPos = (pct: number) => (pct / 100) * PITCH_LENGTH;

    // Kaleci: Kale Ã§izgisine yakÄ±n, ortada
    if (role === Position.GK) return { x: xPos(5), y: PITCH_WIDTH / 2 };

    if (role === Position.DEF) {
        // 3'lÃ¼ defans: kompakt merkez savunma
        if (formation.startsWith('3')) return { x: xPos(22), y: spreadY(index, totalInRole, 48) };
        // 5'li defans: daha kompakt
        if (formation.startsWith('5')) return { x: xPos(18), y: spreadY(index, totalInRole, 64) };
        // Standart 4'lÃ¼ defans
        if (index === 0) return { x: xPos(22), y: spreadY(0, 4, 70) };  // LB 
        if (index === 1) return { x: xPos(22), y: spreadY(1, 4, 70) };  // CB
        if (index === 2) return { x: xPos(22), y: spreadY(2, 4, 70) };  // CB
        if (index === 3) return { x: xPos(22), y: spreadY(3, 4, 70) };  // RB
        return { x: xPos(22), y: spreadY(index, totalInRole, 70) };
    }

    if (role === Position.MID) {
        if (formation === TacticType.T_433 || formation === TacticType.T_532) {
            return { x: xPos(50), y: spreadY(index, totalInRole, 70) };
        }
        if (formation === TacticType.T_442) {
            return { x: xPos(50), y: spreadY(index, totalInRole, 82) };
        }
        if (formation === TacticType.T_4231) {
            if (index < 2) return { x: xPos(42), y: index === 0 ? spreadY(0, 2, 44) : spreadY(1, 2, 44) }; // CDM'ler
            if (index === 2) return { x: xPos(65), y: spreadY(0, 3, 70) };  // LAM
            if (index === 3) return { x: xPos(65), y: PITCH_WIDTH / 2 };    // CAM (merkez)
            if (index === 4) return { x: xPos(65), y: spreadY(2, 3, 70) };  // RAM
        }
        if (formation === TacticType.T_4141) {
            if (index === 0) return { x: xPos(40), y: PITCH_WIDTH / 2 }; // CDM (merkez)
            return { x: xPos(62), y: spreadY(index - 1, 4, 82) }; // 4 orta saha
        }
        if (formation === TacticType.T_41212) {
            if (index === 0) return { x: xPos(40), y: PITCH_WIDTH / 2 };  // CDM
            if (index === 1) return { x: xPos(55), y: spreadY(0, 2, 60) };  // LM
            if (index === 2) return { x: xPos(55), y: spreadY(1, 2, 60) };  // RM
            if (index === 3) return { x: xPos(70), y: PITCH_WIDTH / 2 };  // CAM
        }
        if (formation === TacticType.T_352) {
            if (index < 2) return { x: xPos(45), y: spreadY(index, 2, 50) }; // 2 DM
            return { x: xPos(60), y: spreadY(index - 2, 3, 82) }; // 3 AM
        }
        if (formation === TacticType.T_4321) {
            if (index < 3) return { x: xPos(48), y: spreadY(index, 3, 70) }; // 3 CM
            return { x: xPos(68), y: index === 3 ? spreadY(0, 2, 44) : spreadY(1, 2, 44) }; // 2 AM
        }
        return { x: xPos(55), y: spreadY(index, totalInRole, 80) };
    }

    if (role === Position.FWD) {
        // === FIX: FORVETLERÄ° GERÄ° Ã‡EK (Daha Derin BaÅŸlangÄ±Ã§) ===
        // 88/86 -> 80/78 (BÃ¶ylece koÅŸu mesafesi artar, ofsayta dÃ¼ÅŸmezler)
        if (formation === TacticType.T_433 || formation === TacticType.T_343) {
            if (index === 1) return { x: xPos(80), y: PITCH_WIDTH / 2 };   // ST (merkez) - 88->80
            return { x: xPos(78), y: index === 0 ? spreadY(0, 2, 80) : spreadY(1, 2, 80) }; // Kanatlar - 82->78
        }
        if (totalInRole === 1) return { x: xPos(80), y: PITCH_WIDTH / 2 }; // Tek forvet - 88->80
        if (totalInRole === 2) return { x: xPos(78), y: index === 0 ? spreadY(0, 2, 44) : spreadY(1, 2, 44) }; // 2 forvet - 86->78
        return { x: xPos(78), y: spreadY(index, totalInRole, 60) };
    }

    return { x: PITCH_CENTER_X, y: PITCH_CENTER_Y }; // VarsayÄ±lan: orta saha merkezi
};

// UI koordinatlarÄ±nÄ± (0-100) motor koordinatlarÄ±na (0-105, 0-68) Ã§evir
// NOT: ArtÄ±k getBaseFormationOffset direkt motor koordinatlarÄ± dÃ¶ndÃ¼rÃ¼yor
// Bu fonksiyon sadece dÄ±ÅŸarÄ±dan gelen UI koordinatlarÄ± iÃ§in kullanÄ±lÄ±r
const scaleToMotor = (x: number, y: number): { x: number, y: number } => {
    return {
        x: (x / 100) * PITCH_LENGTH,
        y: (y / 100) * PITCH_WIDTH
    };
};

type SetPieceMode =
    | 'KICKOFF'
    | 'GOAL_KICK_HOME' | 'GOAL_KICK_AWAY'
    | 'CORNER_HOME_TOP' | 'CORNER_HOME_BOTTOM' | 'CORNER_AWAY_TOP' | 'CORNER_AWAY_BOTTOM'
    | 'FREE_KICK_HOME' | 'FREE_KICK_AWAY'
    | 'PENALTY_HOME' | 'PENALTY_AWAY'
    | 'THROW_IN_HOME' | 'THROW_IN_AWAY';

interface Signal {
    type: 'CALL' | 'POINT' | 'HOLD';
    targetId?: string;
    expiryTick: number;
}

export class MatchEngine {
    public match: Match;
    public homeTeam: Team;
    public awayTeam: Team;
    public homePlayers: Player[];
    public awayPlayers: Player[];
    private allPlayers: Player[] = [];

    private sim: SimulationState;
    private traceLog: string[] = [];
    private playerRoles: Record<string, Position> = {};
    private baseOffsets: Record<string, { x: number, y: number }> = {};

    // Helper for cover shadow calculation
    private distToSegment(px: number, py: number, x1: number, y1: number, x2: number, y2: number): number {
        const l2 = distSq(x1, y1, x2, y2);
        if (l2 === 0) return dist(px, py, x1, y1);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        return dist(px, py, x1 + t * (x2 - x1), y1 + t * (y2 - y1));
    }

    private homeMentality: TeamMentality = TeamMentality.BALANCED;
    private awayMentality: TeamMentality = TeamMentality.BALANCED;

    // Track ticks for possession calculation
    private possessionTicks = { home: 0, away: 0 };

    private playerStates: Record<string, {
        currentStamina: number,
        decisionTimer: number,
        possessionCooldown: number,
        actionLock: number,
        targetX: number,
        targetY: number,
        momentum: number,
        isPressing: boolean,
        incomingSignal?: Signal | null,
        outgoingSignal?: Signal | null,
        // === MESAFE BAZLI YORGUNLUK TAKÄ°BÄ° ===
        sprintDistance?: number,  // Toplam sprint mesafesi (birim)
        runDistance?: number,     // Toplam koÅŸu mesafesi (birim)
        supportRunUntil?: number, // === G MOTORU: VER-KAÃ‡ Ä°Ã‡Ä°N DESTEK KOÅžUSU SÃœRESÄ° ===
        // === DECISION PERSISTENCE (TITREME ENGELLEYÄ°CÄ°) ===
        tacticalDecision?: string, // 'COME_SHORT', 'RUN_BEHIND', etc.
        decisionExpiry?: number    // Bu kararÄ±n kaÃ§Ä±ncÄ± tick'e kadar geÃ§erli olduÄŸu
    }> = {};

    // === DEBUG MODE ===
    private DEBUG_MODE: boolean = true;  // SET TO FALSE TO DISABLE LOGGING
    private DEBUG_INTERVAL: number = 60; // Her 60 tick'te bir log (1 saniye) - detaylÄ± analiz iÃ§in
    private debugTickCounter: number = 0; // Global tick sayacÄ± - sÄ±fÄ±rlanmaz

    private tickCount: number = 0;
    private internalMinute: number = 0;
    private currentLooseBallChaserId: string | null = null;
    private lastTouchTeamId: string | null = null;
    private lastShooterId: string | null = null;
    private lastPossessingTeamId: string | null = null;

    // Substitution tracking
    private homeSubsMade: number = 0;
    private awaySubsMade: number = 0;
    private readonly MAX_SUBS: number = 5; // Modern rules allow 5 subs
    private lastAISubCheck: number = 0;
    private userTeamId: string | null = null; // User's team won't get AI subs

    // IMPORTANT: Once a player is substituted OUT, they CANNOT return (Football Rule!)
    private substitutedOutPlayerIds: Set<string> = new Set();

    // === GLOBAL PRESSING CONTROLLER ===
    // Her tick baÅŸÄ±nda merkezi olarak kimlerin pres yapacaÄŸÄ±nÄ± belirle
    // Bu Set'ler sadece "yetkili" oyuncularÄ± tutar - sÃ¼rÃ¼ zihniyetini engeller
    private homePresserIds: Set<string> = new Set();
    private awayPresserIds: Set<string> = new Set();

    // Pending events to be returned in step()
    private pendingEvents: MatchEvent[] = [];

    // Set piece positions - stored when foul/throw-in occurs
    private foulPosition: { x: number, y: number } | null = null;
    private throwInPosition: { x: number, y: number } | null = null;

    // Ball stuck detection - if ball speed < 0.1 for 180 ticks (~3 seconds), trigger out-of-play
    private ballStuckTicks: number = 0;
    private lastBallX: number = PITCH_CENTER_X; // 52.5
    private lastBallY: number = PITCH_CENTER_Y; // 34

    // === PERFORMANCE: Cached player lists to avoid repeated .filter() calls ===
    // These are invalidated on substitutions and refreshed at tick start
    private _cachedStarters: Player[] = [];
    private _cachedHomeStarters: Player[] = [];
    private _cachedAwayStarters: Player[] = [];
    private _starterCacheValid: boolean = false;
    private _statsLogged: boolean = false;
    // === OFSAYT: Defans hatlarÄ± (her tick gÃ¼ncellenir, actionPass'ta kullanÄ±lÄ±r) ===
    private _homeDefLine: number = 50;
    private _awayDefLine: number = 55;

    constructor(match: Match, homeTeam: Team, awayTeam: Team, homePlayers: Player[], awayPlayers: Player[], userTeamId?: string) {
        this.match = match;
        // Ensure stats object exists
        if (!this.match.stats) {
            this.match.stats = {
                homePossession: 50,
                awayPossession: 50,
                homeShots: 0,
                awayShots: 0,
                homeOnTarget: 0,
                awayOnTarget: 0,
                homeXG: 0,
                awayXG: 0,
                homeSaves: 0,
                awaySaves: 0
            };
        }
        // === AGRESÄ°FLÄ°K Ã‡ARPANI (RESTORED to Original) ===
        const aggressionMultipliers = {
            'Safe': 0.85,
            'Normal': 1.00,
            'Aggressive': 1.25,
            'Reckless': 1.45
        };
        this.homeTeam = homeTeam;
        this.awayTeam = awayTeam;
        // Keep all players (STARTING + BENCH) so substitutions can work
        this.homePlayers = homePlayers.filter(p => p.lineup === 'STARTING' || p.lineup === 'BENCH');
        this.awayPlayers = awayPlayers.filter(p => p.lineup === 'STARTING' || p.lineup === 'BENCH');
        this.allPlayers = [...this.homePlayers, ...this.awayPlayers];
        this.userTeamId = userTeamId || null;

        this.internalMinute = match.currentMinute;

        // === 11-PLAYER LIMIT SAFEGUARD ===
        // Ensure strictly max 11 starters per team to prevent '12 players' bug
        const filterRestToBench = (players: Player[]) => {
            let startersCount = 0;
            return players.map(p => {
                if (p.lineup === 'STARTING') {
                    startersCount++;
                    if (startersCount > 11) {
                        console.warn(`âš ï¸ SAFEGUARD: Player ${p.lastName} forced to BENCH (Max 11 starters exceeded)`);
                        return { ...p, lineup: 'BENCH' as LineupStatus, lineupIndex: 99 };
                    }
                }
                return p;
            });
        };

        this.homePlayers = filterRestToBench(this.homePlayers);
        this.awayPlayers = filterRestToBench(this.awayPlayers);
        // Update allPlayers reference with sanitized lists
        this.allPlayers = [...this.homePlayers, ...this.awayPlayers];

        // Only initialize STARTING players on the pitch
        this.initializeTactics(this.homePlayers.filter(p => p.lineup === 'STARTING'), this.homeTeam.tactic);
        this.initializeTactics(this.awayPlayers.filter(p => p.lineup === 'STARTING'), this.awayTeam.tactic);

        [...this.homePlayers, ...this.awayPlayers].forEach(p => {
            if (!p.personality) {
                p.personality = {
                    riskTaking: (p.attributes.aggression / 100) * 0.6 + Math.random() * 0.4,
                    discipline: (p.attributes.decisions / 100),
                    pressureHandling: (p.attributes.composure / 100)
                };
            }

            if (!this.playerStates[p.id]) {
                // Initialize stamina from player condition
                this.playerStates[p.id] = {
                    currentStamina: (p.condition !== undefined ? p.condition : 100),
                    decisionTimer: Math.random() * 5,
                    possessionCooldown: 0,
                    actionLock: 0,
                    targetX: 50, targetY: 50,
                    momentum: 0,
                    isPressing: false,
                    // === MESAFE BAZLI YORGUNLUK TAKÄ°BÄ° ===
                    sprintDistance: 0,  // Toplam sprint mesafesi (birim)
                    runDistance: 0      // Toplam koÅŸu mesafesi (birim)
                };
            }
        });

        if (match.liveData?.simulation && Object.keys(match.liveData.simulation.players).length > 0) {
            this.sim = JSON.parse(JSON.stringify(match.liveData.simulation));
            if (this.sim.ball.z === undefined) { this.sim.ball.z = 0; this.sim.ball.vz = 0; }
        } else {
            this.sim = {
                ball: { x: 50, y: 50, z: 0, vx: 0, vy: 0, vz: 0, curve: 0, ownerId: null, targetId: null },
                players: {},
                homeMentality: TeamMentality.BALANCED,
                awayMentality: TeamMentality.BALANCED
            };
            this.resetPositions('KICKOFF');
        }

        // Only add STARTING players to the pitch simulation
        [...this.homePlayers, ...this.awayPlayers]
            .filter(p => p.lineup === 'STARTING')
            .forEach(p => {
                if (!this.sim.players[p.id]) {
                    const base = this.baseOffsets[p.id] || { x: 50, y: 50 };
                    this.sim.players[p.id] = { x: base.x, y: base.y, facing: 0, vx: 0, vy: 0, state: 'IDLE' };
                }
            });

        // === MAÃ‡ BAÅžLANGIÃ‡ DEBUG LOGU ===
        if (DEBUG_MATCH) {
            const homeStarters = this.homePlayers.filter(p => p.lineup === 'STARTING');
            const awayStarters = this.awayPlayers.filter(p => p.lineup === 'STARTING');
            const homeAvg = Math.round(homeStarters.reduce((sum, p) => sum + p.overall, 0) / homeStarters.length);
            const awayAvg = Math.round(awayStarters.reduce((sum, p) => sum + p.overall, 0) / awayStarters.length);

            // Pozisyonlara gÃ¶re ortalama gÃ¼Ã§ hesapla
            const calcPositionAvg = (players: Player[], pos: Position) => {
                const posList = players.filter(p => this.playerRoles[p.id] === pos);
                return posList.length > 0 ? Math.round(posList.reduce((sum, p) => sum + p.overall, 0) / posList.length) : 0;
            };

            const homeGK = calcPositionAvg(homeStarters, Position.GK);
            const homeDEF = calcPositionAvg(homeStarters, Position.DEF);
            const homeMID = calcPositionAvg(homeStarters, Position.MID);
            const homeFWD = calcPositionAvg(homeStarters, Position.FWD);

            const awayGK = calcPositionAvg(awayStarters, Position.GK);
            const awayDEF = calcPositionAvg(awayStarters, Position.DEF);
            const awayMID = calcPositionAvg(awayStarters, Position.MID);
            const awayFWD = calcPositionAvg(awayStarters, Position.FWD);

            console.log(`\n${'â•'.repeat(80)}`);
            console.log(`ðŸŸï¸  MAÃ‡ BAÅžLIYOR: ${homeTeam.name} (${homeAvg}) vs ${awayTeam.name} (${awayAvg})`);
            console.log(`${'â•'.repeat(80)}\n`);

            const logTeamTactic = (team: Team, avg: number, side: 'HOME' | 'AWAY', gk: number, def: number, mid: number, fwd: number) => {
                console.log(`ðŸ“‹ ${side}: ${team.name}`);
                console.log(`   Genel GÃ¼Ã§: ${avg} | Kadro Detay: KP ${gk}, DF ${def}, OC ${mid}, FW ${fwd}`);
                console.log(`   Formasyon: ${team.tactic.formation} | Stil: ${team.tactic.style}`);
                console.log(`   Mentalite: ${team.tactic.mentality || 'BALANCED'}`);
                console.log(`   Detaylar: SaldÄ±rganlÄ±k=${team.tactic.aggression}, Tempo=${team.tactic.tempo}, GeniÅŸlik=${team.tactic.width}`);
                console.log(`   Savunma: Hat=${team.tactic.defensiveLine}, Markaj=${team.tactic.marking}`);
                console.log(`   PaslaÅŸma: ${team.tactic.passingStyle}`);
                console.log();
            };

            logTeamTactic(homeTeam, homeAvg, 'HOME', homeGK, homeDEF, homeMID, homeFWD);
            logTeamTactic(awayTeam, awayAvg, 'AWAY', awayGK, awayDEF, awayMID, awayFWD);
            console.log(`${'â•'.repeat(80)}\n`);
        }
    }

    public logCurrentTactics() {
        if (!this.homeTeam || !this.awayTeam) return;
        if (!DEBUG_MATCH) return;

        console.log(`\nðŸ“‹ CURRENT TACTICAL STATE (Minute ${this.internalMinute})`);

        const log = (team: Team, side: 'HOME' | 'AWAY') => {
            console.log(`\n== ${side}: ${team.name} ==`);
            console.log(`Style: ${team.tactic.style} | Mentality: ${team.tactic.mentality || 'BALANCED'}`);
            console.log(`Formation: ${team.tactic.formation}`);
            console.log(`Pass: ${team.tactic.passingStyle} | Tempo: ${team.tactic.tempo} | Width: ${team.tactic.width}`);
            console.log(`Def: ${team.tactic.defensiveLine} | Mark: ${team.tactic.marking} | Press: ${team.tactic.aggression}`);
        };

        log(this.homeTeam, 'HOME');
        log(this.awayTeam, 'AWAY');
        console.log('----------------------------------------\n');
    }

    public logMatchAnalysis() {
        console.log(`\nðŸ“Š FULL MATCH ANALYSIS REPORT (90')`);
        console.log(`----------------------------------------`);
        console.log(`${this.homeTeam.name} ${this.match.homeScore} - ${this.match.awayScore} ${this.awayTeam.name}`);

        // Possession
        const totalTicks = this.possessionTicks.home + this.possessionTicks.away;
        const homePoss = totalTicks > 0 ? Math.round((this.possessionTicks.home / totalTicks) * 100) : 50;
        const awayPoss = 100 - homePoss;
        console.log(`Possession: ${homePoss}% - ${awayPoss}%`);

        // Shots & xG
        console.log(`Shots: ${this.match.stats.homeShots} (${this.match.stats.homeOnTarget}) - ${this.match.stats.awayShots} (${this.match.stats.awayOnTarget})`);
        console.log(`xG: ${this.match.stats.homeXG.toFixed(2)} - ${this.match.stats.awayXG.toFixed(2)}`);

        // Tactical Summary
        console.log(`\n== TACTICAL MATCHUP ==`);
        console.log(`HOME (${this.homeTeam.tactic.style}): Formation ${this.homeTeam.tactic.formation}, Mentality ${this.homeTeam.tactic.mentality || 'N/A'}`);
        console.log(`AWAY (${this.awayTeam.tactic.style}): Formation ${this.awayTeam.tactic.formation}, Mentality ${this.awayTeam.tactic.mentality || 'N/A'}`);

        // Analysis
        console.log(`\n== AI INSIGHTS ==`);
        if (Math.abs(homePoss - 50) > 10) {
            const dominant = homePoss > 50 ? 'HOME' : 'AWAY';
            console.log(`- ${dominant} team dominated possession. Check if opponent is 'ParkTheBus' or pressing ineffective.`);
        }
        if (this.match.stats.homeShots > 15 || this.match.stats.awayShots > 15) {
            console.log(`- High shot count detected. Check 'Shot Spam' tuning if conversion rate is low.`);
        }

        console.log(`----------------------------------------\n`);
    }

    private initializeTactics(players: Player[], tactic: TeamTactic) {
        const grouped: Record<string, Player[]> = { GK: [], DEF: [], MID: [], FWD: [] };
        players.forEach(p => {
            let role = normalizePos(p);
            if (tactic.customPositions && tactic.customPositions[p.id]) {
                // customPositions UI koordinatlarÄ±nda (0-100), role hesaplamasÄ± iÃ§in kullan
                role = getRoleFromX(tactic.customPositions[p.id].x);
            }
            this.playerRoles[p.id] = role;
            grouped[role].push(p);
        });

        Object.entries(grouped).forEach(([role, plList]) => {
            // AI FIX: Sort players to ensure positional correctness (Left -> Right)
            // This ensures Index 0 is Left, Index 1 Center, Index 2 Right for 3-man lines
            if (role === Position.FWD || role === Position.MID || role === Position.DEF) {
                plList.sort((a, b) => {
                    const scorePos = (p: string) => {
                        const pos = p.toUpperCase();
                        if (['SLB', 'LB', 'SLO', 'LM', 'LW', 'LF'].includes(pos)) return 1;
                        if (['STP', 'CB', 'MDO', 'CDM', 'MO', 'CM', 'CAM', 'SNT', 'ST', 'CF'].includes(pos)) return 2;
                        if (['SÄžB', 'RB', 'SÄžO', 'RM', 'RW', 'RF'].includes(pos)) return 3;
                        return 2;
                    };
                    return scorePos(a.position) - scorePos(b.position);
                });
            }

            plList.forEach((p, idx) => {
                if (tactic.customPositions && tactic.customPositions[p.id]) {
                    // customPositions UI koordinatlarÄ±nda (0-100) kaydediliyor
                    // Motor koordinatlarÄ±na (105x68) Ã§evir
                    const customUI = tactic.customPositions[p.id];
                    this.baseOffsets[p.id] = {
                        x: (customUI.x / 100) * PITCH_LENGTH,
                        y: (customUI.y / 100) * PITCH_WIDTH
                    };
                } else {
                    // getBaseFormationOffset zaten motor koordinatlarÄ± (105x68) dÃ¶ndÃ¼rÃ¼yor
                    this.baseOffsets[p.id] = getBaseFormationOffset(tactic.formation, role as Position, idx, plList.length);
                }
            });
        });
    }

    private getPlayer(id: string) { return [...this.homePlayers, ...this.awayPlayers].find(p => p.id === id); }

    public getPlayerStamina(id: string): number | undefined {
        return this.playerStates[id]?.currentStamina;
    }

    // --- COMMUNICATION SYSTEM ---
    private emitTeamSignal(from: Player, type: 'CALL' | 'POINT' | 'HOLD', targetId?: string, radius: number = 45, durationTicks: number = 6) {
        try {
            const role = this.playerRoles[from.id] || normalizePos(from);
            // Defenders/GKs shouldn't spam CALL/POINT signals
            if ((role === Position.DEF || role === Position.GK) && type !== 'HOLD') return;

            const teammates = from.teamId === this.homeTeam.id ? this.homePlayers : this.awayPlayers;
            const expiry = this.tickCount + durationTicks;
            const simFrom = this.sim.players[from.id];
            if (!simFrom) return;

            if (this.playerStates[from.id]) {
                this.playerStates[from.id].outgoingSignal = { type, targetId, expiryTick: expiry };
            }

            teammates.forEach(tm => {
                if (tm.id === from.id) return;
                if (!this.sim.players[tm.id]) return;
                if (dist(simFrom.x, simFrom.y, this.sim.players[tm.id].x, this.sim.players[tm.id].y) > radius) return;

                if (this.playerStates[tm.id]) {
                    this.playerStates[tm.id].incomingSignal = { type, targetId: from.id, expiryTick: expiry };
                }
            });
        } catch (e) { }
    }

    private clearExpiredSignals() {
        Object.keys(this.playerStates).forEach(id => {
            const state = this.playerStates[id];
            if (state.incomingSignal && state.incomingSignal.expiryTick <= this.tickCount) state.incomingSignal = null;
            if (state.outgoingSignal && state.outgoingSignal.expiryTick <= this.tickCount) state.outgoingSignal = null;
        });
    }

    // OyuncularÄ±n otomatik konuÅŸmasÄ±
    // 3. OyuncularÄ±n otomatik konuÅŸmasÄ±nÄ± saÄŸlayan yapay zeka (Her tick Ã§alÄ±ÅŸmalÄ±)
    private updatePlayerSignals() {
        // Herkes her an konuÅŸmaz, biraz rastgelelik lazÄ±m
        this.allPlayers.forEach(p => {
            const state = this.playerStates[p.id];
            if (!state) return;

            // EÄŸer top bendeyse konuÅŸmam (genelde), top bende deÄŸilse konuÅŸurum
            if (p.id !== this.sim.ball.ownerId && this.sim.players[p.id]) {
                const simP = this.sim.players[p.id];

                // EÄŸer depar atÄ±yorsam ve Ã¶nÃ¼m boÅŸsa: "Ã–nÃ¼me At!" (POINT)
                if (simP.state === 'SPRINT' && Math.random() < 0.05) {
                    this.emitTeamSignal(p, 'POINT');
                }
                // EÄŸer duruyorsam/yÃ¼rÃ¼yorsam ve boÅŸtaysam: "AyaÄŸÄ±ma At!" (CALL)
                else if (simP.state !== 'SPRINT' && Math.random() < 0.02) {
                    this.emitTeamSignal(p, 'CALL');
                }
            }
        });
    }

    private clearSignalsForTeam(teamId: string | null) {
        if (!teamId) return;
        [...this.homePlayers, ...this.awayPlayers].forEach(p => {
            if (p.teamId !== teamId) return;
            const state = this.playerStates[p.id];
            if (!state) return;
            state.incomingSignal = null;
            state.outgoingSignal = null;
        });
    }

    public updateTactic(teamId: string, newTactic: TeamTactic) {
        const isHome = this.homeTeam.id === teamId;
        const list = isHome ? this.homePlayers : this.awayPlayers;
        const team = isHome ? this.homeTeam : this.awayTeam;

        if (isHome) this.homeTeam.tactic = newTactic;
        else this.awayTeam.tactic = newTactic;
        this.initializeTactics(list.filter(p => p.lineup === 'STARTING'), newTactic);

        // === PERFORMANCE: Invalidate starter cache after tactic change ===
        this._starterCacheValid = false;

        // === TAKTIK DEÄžIÅžIMI LOG ===
        if (DEBUG_MATCH) {
            console.log(`\nðŸ”„ TACTIC CHANGE (Minute ${this.internalMinute}): ${team.name}`);
            console.log(`New Formation: ${newTactic.formation} | Style: ${newTactic.style}`);
            console.log(`Aggression: ${newTactic.aggression} | Tempo: ${newTactic.tempo}`);
            console.log(`Defensive Line: ${newTactic.defensiveLine} | Passing: ${newTactic.passingStyle}`);
            console.log(`Mentality: ${newTactic.mentality || 'BALANCED'}`);
            console.log('----------------------------------------\n');
        }
    }

    public substitutePlayer(playerIn: Player, playerOutId: string, isAI: boolean = false) {
        const isHome = this.homeTeam.id === playerIn.teamId;
        const list = isHome ? this.homePlayers : this.awayPlayers;

        // Find BOTH players in the list
        const outIdx = list.findIndex(p => p.id === playerOutId);
        const inIdx = list.findIndex(p => p.id === playerIn.id);

        // Check sub limit
        const subsMade = isHome ? this.homeSubsMade : this.awaySubsMade;
        if (subsMade >= this.MAX_SUBS) {
            this.traceLog.push(`DEÄžÄ°ÅžÄ°KLÄ°K REDDEDÄ°LDÄ°: ${isHome ? 'Ev sahibi' : 'Deplasman'} maksimum deÄŸiÅŸiklik hakkÄ±nÄ± kullandÄ±.`);
            return;
        }

        // FOOTBALL RULE: A player who has been substituted OUT cannot return to the pitch!
        if (this.substitutedOutPlayerIds.has(playerIn.id)) {
            this.traceLog.push(`DEÄžÄ°ÅžÄ°KLÄ°K REDDEDÄ°LDÄ°: ${playerIn.lastName} zaten oyundan Ã§Ä±karÄ±ldÄ± ve tekrar giremez!`);
            return;
        }

        if (outIdx !== -1 && inIdx !== -1) {
            // Mark the outgoing player as substituted out - they can NEVER return this match
            this.substitutedOutPlayerIds.add(playerOutId);

            // --- 1. UPDATE SIMULATION DATA ---
            const oldPos = this.sim.players[playerOutId];

            // === KRÄ°TÄ°K FIX: TOP SAHÄ°BÄ° GÃœNCELLEME ===
            // EÄŸer Ã§Ä±kan oyuncu topa sahipse, topu yeni oyuncuya transfer et
            // Bu olmazsa oyun donuyor! (ball.ownerId silinmiÅŸ oyuncuyu gÃ¶sterir)
            if (this.sim.ball.ownerId === playerOutId) {
                console.log(`âš ï¸ TOP SAHÄ°BÄ° DEÄžÄ°ÅžÄ°YOR: ${playerOutId} â†’ ${playerIn.id}`);
                this.sim.ball.ownerId = playerIn.id;
            }

            // Remove outgoing player from simulation
            if (oldPos) delete this.sim.players[playerOutId];

            // Add incoming player to simulation
            // CRITICAL FIX: Reset velocity to ZERO! Otherwise inherits old player's speed -> "light speed bug"
            const base = this.baseOffsets[playerIn.id] || { x: PITCH_CENTER_X, y: PITCH_CENTER_Y };
            this.sim.players[playerIn.id] = {
                x: oldPos ? oldPos.x : base.x,
                y: oldPos ? oldPos.y : base.y,
                facing: oldPos ? oldPos.facing : 0,
                vx: 0, // RESET VELOCITY - Prevents "light speed" bug!
                vy: 0,
                state: 'IDLE'
            };

            // Initialize personality if missing
            if (!playerIn.personality) {
                playerIn.personality = {
                    riskTaking: (playerIn.attributes.aggression / 100) * 0.6 + Math.random() * 0.4,
                    discipline: (playerIn.attributes.decisions / 100),
                    pressureHandling: (playerIn.attributes.composure / 100)
                };
            }

            // Initialize player state
            this.playerStates[playerIn.id] = {
                currentStamina: (playerIn.condition !== undefined ? playerIn.condition : 100),
                decisionTimer: 0, possessionCooldown: 0, actionLock: 0,
                targetX: base.x, targetY: base.y, momentum: 0, isPressing: false
            };

            // === MORAL BOOST FOR SUBSTITUTES ===
            // Oyuna giren yedekler moral kazanÄ±r (11'de deÄŸildiler ama ÅŸimdi oyunculuklarÄ±!)
            playerIn.morale = Math.min(100, (playerIn.morale || 50) + 8);

            // --- 2. CRITICAL: SWAP ARRAY POSITIONS (Fixes duplicate reference bug!) ---
            // Get references to both player objects
            const playerOutObj = list[outIdx];
            const playerInObj = list[inIdx];

            // Update lineup statuses
            playerOutObj.lineup = 'BENCH';
            playerInObj.lineup = 'STARTING';
            playerInObj.lineupIndex = playerOutObj.lineupIndex; // Preserve slot index

            // SWAP positions in array - this prevents the "duplicate reference" bug!
            list[outIdx] = playerInObj;  // Incoming player to starting spot
            list[inIdx] = playerOutObj;  // Outgoing player to bench spot

            this.allPlayers = [...this.homePlayers, ...this.awayPlayers];

            // --- 3. REINITIALIZE TACTICS ---
            this.initializeTactics(list.filter(p => p.lineup === 'STARTING'), isHome ? this.homeTeam.tactic : this.awayTeam.tactic);

            // Increment sub counter
            if (isHome) this.homeSubsMade++;
            else this.awaySubsMade++;

            // Create SUB event for notification
            const team = isHome ? this.homeTeam : this.awayTeam;
            this.pendingEvents.push({
                minute: this.internalMinute,
                type: MatchEventType.SUB,
                description: `ðŸ”„ ${playerOutObj.lastName} â¬‡ï¸ ${playerIn.lastName} â¬†ï¸`,
                teamId: team.id,
                playerId: playerIn.id,
                playerOutId: playerOutObj.id // Added for accurate ratings engine tracking
            });

            this.traceLog.push(`OYUNCU DEÄžÄ°ÅžÄ°KLÄ°ÄžÄ°: ${playerIn.lastName} oyunda. (${isHome ? this.homeSubsMade : this.awaySubsMade}/${this.MAX_SUBS})`);
        }

        // === PERFORMANCE: Invalidate starter cache after substitution ===
        this._starterCacheValid = false;
    }

    // AI-driven substitutions for non-user teams
    private processAISubstitutions(isHome: boolean) {
        const team = isHome ? this.homeTeam : this.awayTeam;
        const players = isHome ? this.homePlayers : this.awayPlayers;
        const subsMade = isHome ? this.homeSubsMade : this.awaySubsMade;

        if (subsMade >= this.MAX_SUBS) return;

        // === GERÃ‡EKÃ‡Ä° DEÄžÄ°ÅžÄ°KLÄ°K ZAMANLARI ===
        // Teknik direktÃ¶rler genelde 55-70 arasÄ± ilk deÄŸiÅŸiklikleri yapar
        // 75+ dakikada son deÄŸiÅŸiklikler
        if (this.internalMinute < 55) return;

        const starters = players.filter(p => p.lineup === 'STARTING');
        // IMPORTANT: Filter out players who were already substituted out - they can't return!
        const bench = players.filter(p => p.lineup === 'BENCH' && !this.substitutedOutPlayerIds.has(p.id));

        if (bench.length === 0) return;

        // Find player with worst stamina/performance
        let worstPlayer: Player | null = null;
        let worstScore = Infinity;

        for (const p of starters) {
            if (normalizePos(p) === Position.GK) continue; // Don't sub GK unless injured

            const state = this.playerStates[p.id];
            if (!state) continue;

            // Score based on stamina and position match
            let score = state.currentStamina;

            // === POZÄ°SYONA GÃ–RE DEÄžÄ°ÅžÄ°KLÄ°K Ã–NCELÄ°ÄžÄ° ===
            // Orta sahalar daha Ã§abuk yorulduÄŸu iÃ§in Ã¶ncelikli deÄŸiÅŸtirilmeli
            const role = this.playerRoles[p.id];
            if (role === Position.MID && state.currentStamina < 55) {
                score -= 20; // Orta saha yorgunsa daha acil
            }

            // If very tired (below 45%), prioritize subbing greatly
            if (state.currentStamina < 45) {
                score -= 40;
            } else if (state.currentStamina < 55) {
                score -= 25;
            }

            if (score < worstScore) {
                worstScore = score;
                worstPlayer = p;
            }
        }

        // === GERÃ‡EKÃ‡Ä° DEÄžÄ°ÅžÄ°KLÄ°K EÅžÄ°KLERÄ° ===
        // GeÃ§ dakikalarda daha erken deÄŸiÅŸiklik (yorgunluk daha kritik)
        let subThreshold = 55;
        if (this.internalMinute >= 75) {
            subThreshold = 65; // Son 15 dakikada daha erken deÄŸiÅŸtir
        } else if (this.internalMinute >= 65) {
            subThreshold = 60; // 65-75 arasÄ± orta eÅŸik
        }

        if (!worstPlayer || worstScore > subThreshold) return;

        // Find best bench replacement for the position
        const neededPos = normalizePos(worstPlayer);
        let bestSub: Player | null = null;
        let bestSubScore = -Infinity;

        for (const sub of bench) {
            const subState = this.playerStates[sub.id];
            const stamina = subState ? subState.currentStamina : (sub.condition || 100);

            // CRITICAL FIX: NEVER SUB A GK FOR A FIELD PLAYER OR VICE VERSA
            const subIsGK = normalizePos(sub) === Position.GK;
            const neededIsGK = neededPos === Position.GK; // This theoretically won't happen for subs as we filtered GK out of 'starters' loop, but for safety.

            if (subIsGK !== neededIsGK) continue;

            // Prefer same position
            const posMatch = normalizePos(sub) === neededPos ? 10 : 0;
            const score = sub.overall + posMatch + (stamina / 10);

            if (score > bestSubScore) {
                bestSubScore = score;
                bestSub = sub;
            }
        }

        if (bestSub) {
            // Update lineup statuses
            worstPlayer.lineup = 'BENCH';
            bestSub.lineup = 'STARTING';
            bestSub.lineupIndex = worstPlayer.lineupIndex;

            this.substitutePlayer(bestSub, worstPlayer.id, true);
            this.traceLog.push(`AI DEÄžÄ°ÅžÄ°KLÄ°K: ${team.name} - ${worstPlayer.lastName} Ã§Ä±ktÄ±, ${bestSub.lastName} girdi (yorgunluk: ${Math.round(worstScore)}%)`);
        }
    }

    // AI Tactic Change based on match situation
    private processAITacticChange(isHome: boolean) {
        const team = isHome ? this.homeTeam : this.awayTeam;

        // Skip if this is the user's team
        if (team.id === this.userTeamId) return;

        const scoreDiff = isHome
            ? this.match.homeScore - this.match.awayScore
            : this.match.awayScore - this.match.homeScore;

        const currentMentality = isHome ? this.sim.homeMentality : this.sim.awayMentality;
        let newMentality = currentMentality;
        let tacticChanged = false;

        // Decision Logic based on score and minute
        if (this.internalMinute >= 70) {
            // Late game adjustments
            if (scoreDiff <= -2) {
                // Losing by 2+ â†’ Ultra Attacking
                newMentality = TeamMentality.ALL_OUT_ATTACK;
            } else if (scoreDiff === -1) {
                // Losing by 1 â†’ Attacking
                newMentality = TeamMentality.ATTACKING;
            } else if (scoreDiff >= 2) {
                // Winning by 2+ â†’ Defensive
                newMentality = TeamMentality.DEFENSIVE;
            } else if (scoreDiff === 1) {
                // Winning by 1 â†’ Balanced (protect lead but don't park bus)
                newMentality = TeamMentality.BALANCED;
            }
        } else if (this.internalMinute >= 55) {
            // Mid-late game
            if (scoreDiff <= -2) {
                newMentality = TeamMentality.ATTACKING;
            } else if (scoreDiff >= 2) {
                newMentality = TeamMentality.BALANCED; // Comfortable lead
            }
        } else if (this.internalMinute >= 30) {
            // First half adjustments (more conservative)
            if (scoreDiff <= -2) {
                newMentality = TeamMentality.ATTACKING;
            }
        }

        // BALANCING: Dynamic Aggression for Desperate Teams
        // If losing late, get aggressive (risk fouls for ball recovery)
        if (this.internalMinute >= 75 && scoreDiff <= -1) {
            if (team.tactic.aggression !== 'Aggressive') {
                team.tactic.aggression = 'Aggressive';
                tacticChanged = true;
                this.traceLog.push(`AI AGRESÄ°FLÄ°K: ${team.name} artÄ±k AGRESÄ°F oynuyor! (Risk aldÄ±, Gol LazÄ±m!)`);
            }
        } else if (scoreDiff >= 0 && team.tactic.aggression === 'Aggressive' && newMentality !== TeamMentality.ALL_OUT_ATTACK) {
            // If we caught up or took lead, maybe calm down?
            team.tactic.aggression = 'Normal';
            tacticChanged = true;
            this.traceLog.push(`AI SAKÄ°NLEÅžME: ${team.name} normale dÃ¶ndÃ¼.`);
        }

        // Only change if different from current
        if (newMentality !== currentMentality) {
            if (isHome) {
                this.sim.homeMentality = newMentality;
            } else {
                this.sim.awayMentality = newMentality;
            }
            tacticChanged = true;

            // Create event for notification
            const mentalityTR: Record<string, string> = {
                'Defensive': 'Defansif',
                'Balanced': 'Dengeli',
                'Attacking': 'HÃ¼cum',
                'Ultra-Attacking': 'TopyekÃ¼n HÃ¼cum'
            };

            this.pendingEvents.push({
                minute: this.internalMinute,
                type: MatchEventType.SUB, // Reuse SUB type for tactic (could create new type)
                description: `ðŸ“‹ Taktik: ${mentalityTR[newMentality] || newMentality}`,
                teamId: team.id
            });

            this.traceLog.push(`AI TAKTÄ°K: ${team.name} - ${mentalityTR[newMentality]} moduna geÃ§ti (skor: ${scoreDiff > 0 ? '+' : ''}${scoreDiff})`);
        }
    }

    public syncLineups(homePlayers: Player[], awayPlayers: Player[]) {
        // 1. Update lists (keep Bench for subs)
        this.homePlayers = homePlayers.filter(p => p.lineup === 'STARTING' || p.lineup === 'BENCH');
        this.awayPlayers = awayPlayers.filter(p => p.lineup === 'STARTING' || p.lineup === 'BENCH');
        this.allPlayers = [...this.homePlayers, ...this.awayPlayers];

        // === PERFORMANCE: Invalidate starter cache ===
        this._starterCacheValid = false;

        // 2. Get current simulation state for existing players (to preserve positions)
        const existingSimPlayers = { ...this.sim.players };
        const existingPlayerStates = { ...this.playerStates };

        // 3. Re-initialize tactics/offsets for NEW players only
        const homeStarters = this.homePlayers.filter(p => p.lineup === 'STARTING');
        const awayStarters = this.awayPlayers.filter(p => p.lineup === 'STARTING');

        // Initialize tactics (this sets baseOffsets)
        this.initializeTactics(homeStarters, this.homeTeam.tactic);
        this.initializeTactics(awayStarters, this.awayTeam.tactic);

        // 4. Sync Simulation State
        const allStarting = [...homeStarters, ...awayStarters];
        const newIds = new Set(allStarting.map(p => p.id));

        // Remove players no longer starting
        Object.keys(this.sim.players).forEach(id => {
            if (!newIds.has(id)) {
                // === KRÄ°TÄ°K FIX: TOP SAHÄ°BÄ° KONTROLÃœ ===
                // EÄŸer silinen oyuncu topa sahipse, topu bÄ±rak (sahipsiz yap)
                if (this.sim.ball.ownerId === id) {
                    console.log(`âš ï¸ syncLineups: Top sahibi ${id} siliniyor - top sahipsiz yapÄ±ldÄ±`);
                    this.sim.ball.ownerId = null;
                }
                delete this.sim.players[id];
                // Also remove their player state to prevent ghost states
                delete this.playerStates[id];
            }
        });

        // Add/Update players
        allStarting.forEach(p => {
            // baseOffsets artÄ±k direkt motor koordinatlarÄ±nda (105x68)
            const base = this.baseOffsets[p.id] || { x: PITCH_CENTER_X, y: PITCH_CENTER_Y };
            const isHome = p.teamId === this.homeTeam.id;
            const existingSim = existingSimPlayers[p.id];

            if (!this.sim.players[p.id]) {
                // NEW player entering pitch (substitution already handled by substitutePlayer)
                this.sim.players[p.id] = {
                    x: existingSim ? existingSim.x : (isHome ? base.x : PITCH_LENGTH - base.x),
                    y: existingSim ? existingSim.y : (isHome ? base.y : PITCH_WIDTH - base.y),
                    facing: existingSim ? existingSim.facing : 0,
                    vx: 0, // Reset velocity to prevent glitches
                    vy: 0,
                    state: 'IDLE'
                };
            }

            // Init/restore state if missing
            if (!this.playerStates[p.id]) {
                const existingState = existingPlayerStates[p.id];
                this.playerStates[p.id] = existingState || {
                    currentStamina: p.condition || 100,
                    decisionTimer: Math.random() * 5, possessionCooldown: 0, actionLock: 0,
                    targetX: base.x, targetY: base.y, momentum: 0, isPressing: false
                };
            }
        });

        this.traceLog.push("KADRO GÃœNCELLENDÄ°: Auto-Fix uygulandÄ±.");
    }

    private resetPositions(mode: SetPieceMode, concedingTeamId?: string) {
        this.sim.ball = { x: PITCH_CENTER_X, y: PITCH_CENTER_Y, z: 0, vx: 0, vy: 0, vz: 0, curve: 0, ownerId: null };
        this.currentLooseBallChaserId = null;
        this.lastTouchTeamId = null;

        // Only reset positions for STARTING players (BENCH players aren't on the pitch)
        [...this.homePlayers, ...this.awayPlayers]
            .filter(p => p.lineup === 'STARTING')
            .forEach(p => {
                const isHome = p.teamId === this.homeTeam.id;
                // baseOffsets artÄ±k direkt motor koordinatlarÄ±nda (105x68)
                const base = this.baseOffsets[p.id];
                if (!base) return; // Skip if no base offset defined

                let startX = isHome ? base.x : PITCH_LENGTH - base.x;
                let startY = isHome ? base.y : PITCH_WIDTH - base.y;

                if (mode === 'KICKOFF') {
                    if (isHome) startX = Math.min(startX, PITCH_CENTER_X - 1);
                    else startX = Math.max(startX, PITCH_CENTER_X + 1);
                }
                else if (mode.includes('GOAL_KICK')) {
                    const isHomeKick = mode === 'GOAL_KICK_HOME';
                    const kickingTeam = isHomeKick === isHome;
                    const role = this.playerRoles[p.id];

                    if (kickingTeam) {
                        if (role === Position.GK) { startX = isHome ? 5 : PITCH_LENGTH - 5; startY = PITCH_CENTER_Y; }
                        else if (role === Position.DEF) {
                            startX = isHome ? 13 : PITCH_LENGTH - 13;
                            startY = startY > PITCH_CENTER_Y ? 54 : 14; // 68*0.8 ve 68*0.2
                        }
                        else if (role === Position.MID) { startX = isHome ? 39 : PITCH_LENGTH - 39; }
                        else if (role === Position.FWD) { startX = isHome ? 66 : PITCH_LENGTH - 66; }
                    } else {
                        if (role === Position.FWD) { startX = isHome ? 83 : PITCH_LENGTH - 83; }
                        else if (role === Position.DEF) { startX = isHome ? 49 : PITCH_LENGTH - 49; }
                    }
                }
                else if (mode.includes('CORNER')) {
                    const isHomeCorner = mode.startsWith('CORNER_HOME');
                    const isTop = mode.includes('TOP');
                    const attacking = isHomeCorner === isHome;
                    const role = this.playerRoles[p.id];

                    if (attacking) {
                        if (role === Position.GK) { startX = isHome ? 10 : PITCH_LENGTH - 10; }
                        else if (role === Position.DEF) {
                            if (p.attributes.strength > 75) {
                                startX = isHome ? PITCH_LENGTH - 8 : 8;
                                startY = PITCH_CENTER_Y + (Math.random() * 14 - 7);
                            } else {
                                startX = isHome ? 66 : PITCH_LENGTH - 66;
                            }
                        }
                        else {
                            startX = isHome ? PITCH_LENGTH - 6 : 6;
                            startY = PITCH_CENTER_Y + (Math.random() * 20 - 10);
                        }
                    } else {
                        if (role === Position.GK) { startX = isHome ? 2 : PITCH_LENGTH - 2; startY = PITCH_CENTER_Y; }
                        else {
                            startX = isHome ? 6 : PITCH_LENGTH - 6;
                            startY = PITCH_CENTER_Y + (Math.random() * 20 - 10);
                        }
                    }
                }

                this.sim.players[p.id] = {
                    x: startX,
                    y: startY,
                    facing: isHome ? 0 : Math.PI,
                    vx: 0, vy: 0, state: 'IDLE'
                };

                if (this.playerStates[p.id]) {
                    this.playerStates[p.id].possessionCooldown = 0;
                    this.playerStates[p.id].actionLock = 0;
                    this.playerStates[p.id].targetX = startX;
                    this.playerStates[p.id].targetY = startY;
                    this.playerStates[p.id].isPressing = false;
                }
            });

        if (mode === 'KICKOFF') {
            let kickoffTeamPlayers = Math.random() > 0.5
                ? this.homePlayers.filter(p => p.lineup === 'STARTING')
                : this.awayPlayers.filter(p => p.lineup === 'STARTING');
            if (concedingTeamId) {
                kickoffTeamPlayers = concedingTeamId === this.homeTeam.id
                    ? this.homePlayers.filter(p => p.lineup === 'STARTING')
                    : this.awayPlayers.filter(p => p.lineup === 'STARTING');
            }

            const kickers = kickoffTeamPlayers.filter(p => this.playerRoles[p.id] === Position.FWD || this.playerRoles[p.id] === Position.MID).slice(0, 2);
            if (kickers.length < 2 && kickoffTeamPlayers.length > 0) kickers.push(kickoffTeamPlayers[0]);

            const k1 = kickers[0];
            const k2 = kickers[1];
            const isHomeKick = k1.teamId === this.homeTeam.id;

            this.sim.players[k1.id].x = PITCH_CENTER_X;
            this.sim.players[k1.id].y = PITCH_CENTER_Y;
            this.sim.ball.ownerId = k1.id;
            this.sim.players[k1.id].facing = isHomeKick ? 0 : Math.PI;

            this.sim.players[k2.id].x = PITCH_CENTER_X + (isHomeKick ? -0.5 : 0.5);
            this.sim.players[k2.id].y = PITCH_CENTER_Y + 3;
            this.sim.players[k2.id].facing = isHomeKick ? 0 : Math.PI;

            const enemyPlayers = (isHomeKick ? this.awayPlayers : this.homePlayers).filter(p => p.lineup === 'STARTING');
            enemyPlayers.forEach(ep => {
                if (this.sim.players[ep.id] && dist(PITCH_CENTER_X, PITCH_CENTER_Y, this.sim.players[ep.id].x, this.sim.players[ep.id].y) < 10) {
                    this.sim.players[ep.id].x = isHomeKick ? 65 : 40;
                }
            });

        } else if (mode.includes('GOAL_KICK')) {
            const isHome = mode === 'GOAL_KICK_HOME';
            const team = (isHome ? this.homePlayers : this.awayPlayers).filter(p => p.lineup === 'STARTING');
            const gk = team.find(p => this.playerRoles[p.id] === Position.GK);
            if (gk && this.sim.players[gk.id]) {
                this.sim.players[gk.id].x = isHome ? 5 : 100;
                this.sim.players[gk.id].y = PITCH_CENTER_Y;
                this.sim.ball.ownerId = gk.id;
                this.sim.ball.x = isHome ? 5 : 100;
                this.sim.ball.y = PITCH_CENTER_Y;
            }
        } else if (mode.includes('CORNER')) {
            const isHome = mode.startsWith('CORNER_HOME');
            const isTop = mode.includes('TOP');
            const team = (isHome ? this.homePlayers : this.awayPlayers).filter(p => p.lineup === 'STARTING');
            const taker = team.sort((a, b) => (b.attributes.passing + b.attributes.vision) - (a.attributes.passing + a.attributes.vision))[0];

            const cX = isHome ? PITCH_LENGTH : 0;
            const cY = isTop ? 0 : PITCH_WIDTH;

            if (taker && this.sim.players[taker.id]) {
                this.sim.players[taker.id].x = cX;
                this.sim.players[taker.id].y = cY;
                this.sim.ball.ownerId = taker.id;
                this.sim.ball.x = cX;
                this.sim.ball.y = cY;
                this.sim.players[taker.id].facing = Math.atan2(PITCH_CENTER_Y - cY, (isHome ? 95 : 10) - cX);
                this.playerStates[taker.id].actionLock = 5;
            }
        } else if (mode.includes('FREE_KICK')) {
            // Free kick - ball placed where foul occurred (stored in foulPosition)
            const isHome = mode === 'FREE_KICK_HOME';
            const team = (isHome ? this.homePlayers : this.awayPlayers).filter(p => p.lineup === 'STARTING');
            // Best passer/vision player takes the free kick
            const taker = team.sort((a, b) => (b.attributes.passing + b.attributes.vision) - (a.attributes.passing + a.attributes.vision))[0];

            // Use stored foul position or default to midfield
            const fkX = this.foulPosition?.x ?? PITCH_CENTER_X;
            const fkY = this.foulPosition?.y ?? PITCH_CENTER_Y;

            if (taker && this.sim.players[taker.id]) {
                this.sim.players[taker.id].x = fkX;
                this.sim.players[taker.id].y = fkY;
                this.sim.ball.ownerId = taker.id;
                this.sim.ball.x = fkX;
                this.sim.ball.y = fkY;
                this.sim.players[taker.id].facing = isHome ? 0 : Math.PI;
                this.playerStates[taker.id].actionLock = 5;
            }

            // === SERBEST VURUÅž BARAJI ===
            // FIFA kuralÄ±: Baraj en az 9.15m (10 yard) uzaklÄ±kta olmalÄ±
            // Baraj top ile kale arasÄ±nda, kaleye dik aÃ§Ä±yla dizilmeli
            const enemyTeam = (isHome ? this.awayPlayers : this.homePlayers).filter(p => p.lineup === 'STARTING');
            const goalX = isHome ? PITCH_LENGTH : 0; // Hedef kale
            const goalY = GOAL_Y_CENTER;

            // Top-Kale vektÃ¶rÃ¼
            const toGoalX = goalX - fkX;
            const toGoalY = goalY - fkY;
            const toGoalDist = Math.sqrt(toGoalX * toGoalX + toGoalY * toGoalY);

            // Baraj pozisyonu: Top ile kale arasÄ±nda, 9.15m uzaklÄ±kta
            const WALL_DISTANCE = 9.15; // FIFA kuralÄ±
            const wallCenterX = fkX + (toGoalX / toGoalDist) * WALL_DISTANCE;
            const wallCenterY = fkY + (toGoalY / toGoalDist) * WALL_DISTANCE;

            // Baraja dik vektÃ¶r (oyuncularÄ± yan yana dizmek iÃ§in)
            const perpX = -toGoalY / toGoalDist;
            const perpY = toGoalX / toGoalDist;

            // KaÃ§ kiÅŸilik baraj? Mesafeye gÃ¶re karar ver
            const distToGoal = toGoalDist;
            let wallSize = 3; // VarsayÄ±lan
            if (distToGoal < 25) wallSize = 5; // Tehlikeli bÃ¶lge: 5 kiÅŸi
            else if (distToGoal < 35) wallSize = 4; // Orta mesafe: 4 kiÅŸi

            // Savunma oyuncularÄ±nÄ± seÃ§ (kaleci hariÃ§)
            const wallCandidates = enemyTeam
                .filter(ep => this.playerRoles[ep.id] !== Position.GK)
                .sort((a, b) => {
                    // Ã–nce defans oyuncularÄ±, sonra orta saha
                    const roleA = this.playerRoles[a.id] === Position.DEF ? 0 : 1;
                    const roleB = this.playerRoles[b.id] === Position.DEF ? 0 : 1;
                    return roleA - roleB;
                })
                .slice(0, wallSize);

            // BarajÄ± diz (yan yana, 0.8m aralÄ±kla)
            const PLAYER_SPACING = 0.8; // Omuz omuza
            wallCandidates.forEach((ep, idx) => {
                if (!this.sim.players[ep.id]) return;
                const offset = (idx - (wallCandidates.length - 1) / 2) * PLAYER_SPACING;
                this.sim.players[ep.id].x = wallCenterX + perpX * offset;
                this.sim.players[ep.id].y = wallCenterY + perpY * offset;
                this.sim.players[ep.id].vx = 0;
                this.sim.players[ep.id].vy = 0;
                // Topa bak
                this.sim.players[ep.id].facing = Math.atan2(fkY - this.sim.players[ep.id].y, fkX - this.sim.players[ep.id].x);
            });

            // DiÄŸer savunma oyuncularÄ±nÄ± da uzaklaÅŸtÄ±r (barajda olmayanlar)
            enemyTeam.forEach(ep => {
                if (wallCandidates.includes(ep)) return; // Barajdakiler zaten yerleÅŸti
                if (!this.sim.players[ep.id]) return;
                const d = dist(fkX, fkY, this.sim.players[ep.id].x, this.sim.players[ep.id].y);
                if (d < WALL_DISTANCE) {
                    // Radyal olarak uzaklaÅŸtÄ±r
                    const dx = this.sim.players[ep.id].x - fkX;
                    const dy = this.sim.players[ep.id].y - fkY;
                    const currentDist = Math.max(0.1, Math.sqrt(dx * dx + dy * dy));
                    this.sim.players[ep.id].x = fkX + (dx / currentDist) * (WALL_DISTANCE + 2);
                    this.sim.players[ep.id].y = fkY + (dy / currentDist) * (WALL_DISTANCE + 2);
                }
            });
        } else if (mode.includes('THROW_IN')) {
            // Throw in - ball placed where it went out
            const isHome = mode === 'THROW_IN_HOME';
            const team = (isHome ? this.homePlayers : this.awayPlayers).filter(p => p.lineup === 'STARTING');
            // Closest non-GK player to throw position takes it
            const throwY = this.throwInPosition?.y ?? PITCH_CENTER_Y;
            const throwX = this.throwInPosition?.x ?? (throwY < PITCH_CENTER_Y ? 0 : PITCH_LENGTH);

            const taker = team
                .filter(p => this.playerRoles[p.id] !== Position.GK)
                .sort((a, b) => {
                    const distA = this.sim.players[a.id] ? dist(throwX, throwY, this.sim.players[a.id].x, this.sim.players[a.id].y) : 999;
                    const distB = this.sim.players[b.id] ? dist(throwX, throwY, this.sim.players[b.id].x, this.sim.players[b.id].y) : 999;
                    return distA - distB;
                })[0];

            if (taker && this.sim.players[taker.id]) {
                this.sim.players[taker.id].x = throwX;
                this.sim.players[taker.id].y = throwY;
                this.sim.ball.ownerId = taker.id;
                this.sim.ball.x = throwX;
                this.sim.ball.y = throwY;
                this.sim.players[taker.id].facing = throwX < PITCH_CENTER_X ? 0 : Math.PI;
                this.playerStates[taker.id].actionLock = 3;
            }
        }
    }

    private updateTeamMentality() {
        const time = this.internalMinute;
        const diff = this.match.homeScore - this.match.awayScore;

        const update = (teamDiff: number): TeamMentality => {
            if (time > 80 && teamDiff > 0) return TeamMentality.PARK_THE_BUS;
            if (time > 75 && teamDiff < 0) return TeamMentality.ALL_OUT_ATTACK;
            if (teamDiff > 1) return TeamMentality.DEFENSIVE;
            if (teamDiff < -1) return TeamMentality.ATTACKING;
            return TeamMentality.BALANCED;
        };

        this.homeMentality = update(diff);
        this.awayMentality = update(-diff);
        this.sim.homeMentality = this.homeMentality;
        this.sim.awayMentality = this.awayMentality;
    }

    public logMatchStats() {
        if (this._statsLogged) return;
        this._statsLogged = true;
        if (!DEBUG_MATCH) return;

        const h = this.homeTeam;
        const a = this.awayTeam;
        const s = this.match.stats;

        // === TAKIMLARIN TAKTIK VE ORTALAMA GÃœÃ‡Ãœ ===
        const homeAvgStr = (this.homePlayers.reduce((sum, p) => sum + (p.attributes?.strength || 50), 0) / this.homePlayers.length).toFixed(1);
        const awayAvgStr = (this.awayPlayers.reduce((sum, p) => sum + (p.attributes?.strength || 50), 0) / this.awayPlayers.length).toFixed(1);

        const homeAvgPace = (this.homePlayers.reduce((sum, p) => sum + (p.attributes?.speed || 50), 0) / this.homePlayers.length).toFixed(1);
        const awayAvgPace = (this.awayPlayers.reduce((sum, p) => sum + (p.attributes?.speed || 50), 0) / this.awayPlayers.length).toFixed(1);

        const homeTactic = this.homeTeam.tactic;
        const awayTactic = this.awayTeam.tactic;

        console.log(`\n${'â•'.repeat(80)}`);
        console.log(`âš½ MAÃ‡ ANALIZ RAPORU: ${h.name} ${this.match.homeScore} - ${this.match.awayScore} ${a.name}`);
        console.log(`${'â•'.repeat(80)}\n`);

        // TakÄ±m Genel Bilgiler
        console.log(`ðŸ“‹ TAKIMLAR:`);
        console.log(`  ${h.name.padEnd(30)} | Taktik: ${homeTactic.style.padEnd(12)} | Ort. GÃ¼Ã§: ${homeAvgStr} | Ort. HÄ±z: ${homeAvgPace}`);
        console.log(`  ${a.name.padEnd(30)} | Taktik: ${awayTactic.style.padEnd(12)} | Ort. GÃ¼Ã§: ${awayAvgStr} | Ort. HÄ±z: ${awayAvgPace}`);
        console.log();

        // Sahiplik ve Temel Ä°statistikler
        const homePoss = (s.homePossession || 50);
        const awayPoss = (s.awayPossession || 50);
        console.log(`ðŸ“Š TEMEL Ä°STATÄ°STÄ°KLER:`);
        console.log(`  Topa Sahiplik:     ${homePoss}%`.padEnd(35) + `| ${awayPoss}%`);
        console.log(`  Åžut SayÄ±sÄ±:        ${s.homeShots}`.padEnd(35) + `| ${s.awayShots}`);
        console.log(`  Ä°sabetli Åžut:      ${s.homeOnTarget}`.padEnd(35) + `| ${s.awayOnTarget}`);
        console.log(`  Åžut DoÄŸruluÄŸu:     %${(s.homeShots > 0 ? (s.homeOnTarget / s.homeShots * 100).toFixed(1) : 0)}`.padEnd(35) + `| %${(s.awayShots > 0 ? (s.awayOnTarget / s.awayShots * 100).toFixed(1) : 0)}`);
        console.log();

        // xG ve Beklentiler
        const homeXG = (s.homeXG || 0).toFixed(2);
        const awayXG = (s.awayXG || 0).toFixed(2);
        console.log(`ðŸŽ¯ BEKLENTÄ° VE VERIMLILIK:`);
        console.log(`  Expected Goals:    ${homeXG}`.padEnd(35) + `| ${awayXG}`);
        console.log(`  Kaleci KurtarÄ±ÅŸ:   ${s.homeSaves || 0}`.padEnd(35) + `| ${s.awaySaves || 0}`);
        const homeGoalEff = s.homeShots > 0 ? ((this.match.homeScore / s.homeShots * 100).toFixed(1)) : 0;
        const awayGoalEff = s.awayShots > 0 ? ((this.match.awayScore / s.awayShots * 100).toFixed(1)) : 0;
        console.log(`  Gol VerimliliÄŸi:   %${homeGoalEff}`.padEnd(35) + `| %${awayGoalEff}`);
        console.log();

        // DetaylÄ± Taktik Bilgisi
        console.log(`ðŸŽ² TAKTIK AYARLARI:`);
        console.log(`  ${h.name.substring(0, 20).padEnd(25)} ${a.name.substring(0, 20).padEnd(25)}`);
        console.log(`  Stili: ${homeTactic.style.padEnd(18)} | Stili: ${awayTactic.style.padEnd(18)}`);
        console.log(`  SaldÄ±rganlÄ±k: ${homeTactic.aggression.padEnd(12)} | SaldÄ±rganlÄ±k: ${awayTactic.aggression.padEnd(12)}`);
        console.log(`  Tempo: ${homeTactic.tempo.padEnd(16)} | Tempo: ${awayTactic.tempo.padEnd(16)}`);
        console.log(`  Savunma HattÄ±: ${homeTactic.defensiveLine.padEnd(9)} | Savunma HattÄ±: ${awayTactic.defensiveLine.padEnd(9)}`);
        console.log(`  Pas Stili: ${homeTactic.passingStyle.padEnd(13)} | Pas Stili: ${awayTactic.passingStyle.padEnd(13)}`);
        console.log();

        console.log(`${'â•'.repeat(80)}\n`);
    }

    public logHalfTimeStats() {
        if (!DEBUG_MATCH) return;

        const h = this.homeTeam;
        const a = this.awayTeam;
        const s = this.match.stats;

        console.log(`\n${'â•'.repeat(80)}`);
        console.log(`â¸ï¸  Ä°LK YARI SONU: ${h.name} ${this.match.homeScore} - ${this.match.awayScore} ${a.name}`);
        console.log(`${'â•'.repeat(80)}\n`);

        // Sahiplik
        const homePoss = (s.homePossession || 50);
        const awayPoss = (s.awayPossession || 50);
        console.log(`ðŸ“Š Ä°LK YARI Ä°STATÄ°STÄ°KLER:`);
        console.log(`  Topa Sahiplik:     ${homePoss}%`.padEnd(35) + `| ${awayPoss}%`);
        console.log(`  Åžut:               ${s.homeShots} (${s.homeOnTarget} isabetli)`.padEnd(35) + `| ${s.awayShots} (${s.awayOnTarget} isabetli)`);
        console.log(`  Kaleci KurtarÄ±ÅŸ:   ${s.homeSaves || 0}`.padEnd(35) + `| ${s.awaySaves || 0}`);
        console.log(`  Expected Goals:    ${(s.homeXG || 0).toFixed(2)}`.padEnd(35) + `| ${(s.awayXG || 0).toFixed(2)}`);
        console.log();

        console.log(`${'â•'.repeat(80)}\n`);
    }

    public step() {
        this.traceLog = [];
        this.tickCount++;
        this.debugTickCounter++; // Global tick sayacÄ±
        let event: MatchEvent | null = null;

        // === DEBUG LOGGING - Her DEBUG_INTERVAL tick'te bir ===
        if (this.DEBUG_MODE && this.debugTickCounter % this.DEBUG_INTERVAL === 0) {
            this.logDebugSnapshot();
        }

        if (this.tickCount >= TICKS_PER_MINUTE) {
            this.internalMinute++;
            this.tickCount = 0;
            this.updateTeamMentality();

            // === DEBUG: Her 15 dakikada bir oyun durumunu logla ===
            if (DEBUG_MATCH && (this.internalMinute % 15 === 0 || this.internalMinute === 45 || this.internalMinute === 90)) {
                const ballSpeed = Math.sqrt(this.sim.ball.vx ** 2 + this.sim.ball.vy ** 2);
                console.log(`â±ï¸ ${this.internalMinute}' | Top: (${this.sim.ball.x.toFixed(0)},${this.sim.ball.y.toFixed(0)}) hÄ±z:${ballSpeed.toFixed(2)} | Sahip: ${this.sim.ball.ownerId ? this.getPlayer(this.sim.ball.ownerId)?.lastName || 'YOK' : 'Sahipsiz'}`);

                // Ä°lk YarÄ± Raporu
                if (this.internalMinute === 45) {
                    this.logHalfTimeStats();
                }

                // MaÃ§ Sonu Raporu
                if (this.internalMinute >= 90) {
                    this.logMatchStats();
                }
            }

            // AI substitution check every 5 minutes for non-user teams
            if (this.internalMinute >= 40 && this.internalMinute % 5 === 0) {
                // Only process AI subs for teams that are NOT user-controlled
                if (this.userTeamId !== this.homeTeam.id) {
                    this.processAISubstitutions(true);
                }
                if (this.userTeamId !== this.awayTeam.id) {
                    this.processAISubstitutions(false);
                }
            }

            // AI TACTIC CHANGE - Check at 30', 60', 75'
            if ([30, 60, 75].includes(this.internalMinute)) {
                this.processAITacticChange(true);
                this.processAITacticChange(false);
            }

            // === SECOND HALF KICKOFF ===
            // Trigger kickoff immediately when we transition TO minute 46 (right after 45)
            if (this.internalMinute === 46 && this.tickCount === 0) {
                // Only do this once - when we first hit 46
                this.resetPositions('KICKOFF');
                this.pendingEvents.push({
                    minute: this.internalMinute,
                    type: MatchEventType.KICKOFF,
                    description: '2nd Half',
                    teamId: this.awayTeam.id
                });
            }
        }


        this.updateBallPhysics();

        // === VISUAL STATE CLEANUP ===
        Object.keys(this.sim.players).forEach(id => {
            const simP = this.sim.players[id] as any;
            const state = this.playerStates[id] as any;

            // Reset collision flag every tick (it's re-calculated in resolveCollisions)
            // But resolveCollisions runs every 2 ticks, so we might want to keep it?
            // Actually, let's just clear it. If it flickers, we can increase persistence.
            if (this.tickCount % 2 === 0) simP.isCollided = false;

            // Clear shot type if expired
            if (simP.shotType && state.shotTypeExpiry && this.tickCount > state.shotTypeExpiry) {
                simP.shotType = undefined;
                state.shotTypeExpiry = undefined;
            }
        });

        // === GLOBAL PRESSING CONTROLLER (Merkezi Pres DaÄŸÄ±tÄ±cÄ±) ===
        // Her tick baÅŸÄ±nda kimlerin pres yapacaÄŸÄ±nÄ± MERKEZI olarak belirle
        // Bu sayede 5-6 kiÅŸi birden topa saldÄ±rmaz!
        this.homePresserIds.clear();
        this.awayPresserIds.clear();

        const ballOwnerForPressing = this.sim.ball.ownerId ? this.getPlayer(this.sim.ball.ownerId) : null;

        if (ballOwnerForPressing) {
            const defendingTeamId = ballOwnerForPressing.teamId === this.homeTeam.id ? this.awayTeam.id : this.homeTeam.id;
            const isDefendingHome = defendingTeamId === this.homeTeam.id;
            const defendingPlayers = (isDefendingHome ? this._cachedHomeStarters : this._cachedAwayStarters)
                .filter(p => this.sim.players[p.id] && this.playerRoles[p.id] !== Position.GK);

            const ballX = this.sim.ball.x;
            const ballY = this.sim.ball.y;
            const myGoalX = isDefendingHome ? 0 : PITCH_LENGTH;

            // === ZONAL HANDOVER (BÃ¶lgesel Devir Teslim) - Ä°KÄ° GEMÄ°NÄ°'NÄ°N Ã–NERÄ°SÄ° ===
            // Sadece mesafeye bakmak YETMÄ°YOR! Topun arkasÄ±nda kalan (Ã§alÄ±mlanmÄ±ÅŸ) oyuncular
            // mesafesi kÄ±sa olsa bile "ana presÃ§i" olmamalÄ±. Yetki Ã¶nÃ¼ndeki taze oyuncuya geÃ§meli!
            const sortedDefenders = defendingPlayers.map(p => {
                const pos = this.sim.players[p.id];
                const d = dist(pos.x, pos.y, ballX, ballY);
                const stamina = this.playerStates[p.id]?.currentStamina || 100;

                // === KRÄ°TÄ°K: Ã‡ALIMLANMIÅž OYUNCU TESPÄ°TÄ° ===
                // Top oyuncuyu geÃ§miÅŸ mi? (Kaleye oyuncudan daha yakÄ±n mÄ±?)
                // Home takÄ±m: Kale x=0, yani top < oyuncu.x ise oyuncu geÃ§ilmiÅŸ
                // Away takÄ±m: Kale x=105, yani top > oyuncu.x ise oyuncu geÃ§ilmiÅŸ
                // 2.5 metre tolerans - sÄ±rt sÄ±rta mÃ¼cadele iÃ§in (GÃœNCELLENDÄ°!)
                const isBeaten = isDefendingHome ? (ballX < pos.x - 2.5) : (ballX > pos.x + 2.5);

                return { id: p.id, dist: d, stamina, isBeaten, x: pos.x };
            })
                // === KATILI FILTRE: Yorgunluk + GeÃ§ilmiÅŸ Oyuncu ===
                // 1. %30 altÄ±: Pres yapma hakkÄ± YOK
                // 2. GeÃ§ilmiÅŸ (isBeaten) VE mesafe > 3m: Elendi! 
                //    (Ä°stisna: Topa < 3m yakÄ±nsa recover yapabilir)
                .filter(p => {
                    if (p.stamina <= 30) return false; // Yorgun eleniyor
                    if (p.isBeaten && p.dist > 3.0) return false; // GeÃ§ilmiÅŸ + uzakta = eleniyor!
                    return true;
                })
                // === ZONAL HANDOVER SIRALAMA ===
                // Ã–nce topun Ã¶nÃ¼ndekilere (isBeaten: false) Ã¶ncelik ver, sonra mesafeye bak
                // Bu sayede orta saha geÃ§ildiÄŸinde yetki otomatik defansa devredilir!
                .sort((a, b) => {
                    // Ã–ncelik 1: Ã‡alÄ±mlanmamÄ±ÅŸ oyuncular Ã¶ne
                    if (a.isBeaten !== b.isBeaten) return a.isBeaten ? 1 : -1;
                    // Ã–ncelik 2: Mesafeye gÃ¶re sÄ±rala
                    return a.dist - b.dist;
                });

            // Taktiksel Pres Kapasitesi
            const defenderTactic = isDefendingHome ? this.homeTeam.tactic : this.awayTeam.tactic;
            let maxPressers = 2; // VarsayÄ±lan: 2 kiÅŸi

            // Taktik bazlÄ± ayarlama
            const pressIntensity = defenderTactic.pressingIntensity || 'Balanced';

            if (pressIntensity === 'StandOff') {
                maxPressers = 1; // Alan savunmasÄ±
            } else if (pressIntensity === 'Balanced') {
                maxPressers = 2; // Standart
            } else if (pressIntensity === 'HighPress') {
                maxPressers = 3; // Agresif baskÄ±
            } else if (pressIntensity === 'Gegenpress') {
                maxPressers = 4; // Topa ÅŸok baskÄ±!
            }

            // Tehlike bÃ¶lgesi: Ceza sahasÄ± yakÄ±nÄ±nda +1 presÃ§i
            const distToGoal = Math.abs(ballX - myGoalX);
            const isBallInDangerZone = distToGoal < 30; // Ceza sahasÄ± civarÄ±
            if (isBallInDangerZone) maxPressers += 1;

            // === KONTRA ATAK KONTROLÃœ ===
            // EÄŸer topun Ã¶nÃ¼nde hiÃ§ oyuncu kalmadÄ±ysa (herkes geÃ§ildi), kovalayanlara izin ver!
            const unbeatenCount = sortedDefenders.filter(p => !p.isBeaten).length;
            const useBeatenPlayers = unbeatenCount < maxPressers; // Yeterli "taze" oyuncu yoksa

            // SeÃ§ilen oyunculara "Pres Yetkisi" ver
            let pressersAdded = 0;
            for (const defender of sortedDefenders) {
                if (pressersAdded >= maxPressers) break;

                // EÄŸer yeterli taze oyuncu varsa, Ã§alÄ±mlanmÄ±ÅŸ oyuncularÄ± atla
                if (defender.isBeaten && !useBeatenPlayers) continue;

                if (isDefendingHome) {
                    this.homePresserIds.add(defender.id);
                } else {
                    this.awayPresserIds.add(defender.id);
                }
                pressersAdded++;
            }
        }

        // === BALL STUCK DETECTION & RESET ===
        const ballSpeed = Math.sqrt(this.sim.ball.vx ** 2 + this.sim.ball.vy ** 2);
        const ballMoved = Math.sqrt((this.sim.ball.x - this.lastBallX) ** 2 + (this.sim.ball.y - this.lastBallY) ** 2) > 0.5;

        if (ballSpeed < 0.1 && !ballMoved && this.sim.ball.ownerId === null) {
            this.ballStuckTicks++;

            // If ball stuck for 3+ seconds (180 ticks), reset it
            if (this.ballStuckTicks >= 180) {
                console.warn(`âš ï¸ BALL STUCK FOR 3 SECONDS at (${this.sim.ball.x.toFixed(1)}, ${this.sim.ball.y.toFixed(1)}). RESETTING.`);

                // Determine which team throws in
                const isGoalBox = (this.sim.ball.x < 15 || this.sim.ball.x > 85) && (this.sim.ball.y > 35 && this.sim.ball.y < 65);
                const isNearHome = this.sim.ball.x < 50;

                // Goal kick if in goal box, throw-in otherwise
                if (isGoalBox) {
                    const throwTeam = isNearHome ? this.homeTeam.id : this.awayTeam.id;
                    this.resetPositions(isNearHome ? 'GOAL_KICK_HOME' : 'GOAL_KICK_AWAY');
                } else {
                    const throwTeam = isNearHome ? this.awayTeam.id : this.homeTeam.id;
                    this.throwInPosition = { x: this.sim.ball.x, y: this.sim.ball.y };
                    this.resetPositions(isNearHome ? 'THROW_IN_AWAY' : 'THROW_IN_HOME');
                }

                this.ballStuckTicks = 0;
                this.pendingEvents.push({
                    minute: this.internalMinute,
                    type: MatchEventType.THROW_IN,
                    description: 'âš ï¸ Ball Reset (Stuck Detection)'
                });
            }
        } else {
            this.ballStuckTicks = 0; // Reset counter if ball moves
        }

        this.lastBallX = this.sim.ball.x;
        this.lastBallY = this.sim.ball.y;

        const ballOwner = this.sim.ball.ownerId ? this.getPlayer(this.sim.ball.ownerId) : null;
        const owningTeamId = ballOwner ? ballOwner.teamId : null;

        // Clear stale signals when possession changes or ball is loose
        if (owningTeamId !== this.lastPossessingTeamId) {
            this.clearSignalsForTeam(this.lastPossessingTeamId);
            if (!owningTeamId) {
                this.clearSignalsForTeam(this.homeTeam.id);
                this.clearSignalsForTeam(this.awayTeam.id);
            }
            this.lastPossessingTeamId = owningTeamId;
        }

        // Possession Tracking
        if (owningTeamId) {
            if (owningTeamId === this.homeTeam.id) this.possessionTicks.home++;
            else this.possessionTicks.away++;

            const total = this.possessionTicks.home + this.possessionTicks.away;
            if (total > 0) {
                this.match.stats.homePossession = Math.round((this.possessionTicks.home / total) * 100);
                this.match.stats.awayPossession = 100 - this.match.stats.homePossession;
            }
        }

        if (ballOwner) {
            this.lastTouchTeamId = ballOwner.teamId;
        }

        const homeDefLine = this.calculateDefensiveLine(true);
        const awayDefLine = this.calculateDefensiveLine(false);
        // === OFSAYT: defLine'larÄ± instance olarak sakla (actionPass'ta kullanÄ±lacak) ===
        this._homeDefLine = homeDefLine;
        this._awayDefLine = awayDefLine;

        // === PERFORMANCE: Use cached starter lists instead of repeated .filter() calls ===
        // Cache is rebuilt when invalidated (after substitutions) or on first tick
        if (!this._starterCacheValid) {
            this._cachedStarters = this.allPlayers.filter(p => p.lineup === 'STARTING');
            this._cachedHomeStarters = this.homePlayers.filter(p => p.lineup === 'STARTING');
            this._cachedAwayStarters = this.awayPlayers.filter(p => p.lineup === 'STARTING');
            this._starterCacheValid = true;
        }
        const allPlayers = this._cachedStarters;

        if (!ballOwner) {
            let bestChaserId: string | null = null;
            let minScore = 9999;

            allPlayers.forEach(p => {
                if (!this.sim.players[p.id]) return;
                const state = this.playerStates[p.id];
                if (state.possessionCooldown > 0) return;

                // Tired players react slower to loose balls
                let staminaPenalty = 0;
                if (state.currentStamina < 40) staminaPenalty = 5.0;

                // PERFORMANCE: Use distSq for comparison (avoid sqrt)
                const dSq = distSq(this.sim.players[p.id].x, this.sim.players[p.id].y, this.sim.ball.x, this.sim.ball.y);
                const d = Math.sqrt(dSq); // Only sqrt when we need actual distance for calculation
                let effectiveDist = d + staminaPenalty;
                if (p.id === this.currentLooseBallChaserId) effectiveDist -= 3.0;

                if (effectiveDist < minScore) {
                    minScore = effectiveDist;
                    bestChaserId = p.id;
                }
            });
            this.currentLooseBallChaserId = bestChaserId;
        } else {
            this.currentLooseBallChaserId = null;
        }

        allPlayers.forEach(p => {
            // SKIP RED CARDED PLAYERS (not in starting lineup)
            if (p.lineup !== 'STARTING') return;

            // SAFETY: Auto-initialize player if missing from simulation (fixes freeze bug)
            if (!this.sim.players[p.id]) {
                const isHome = p.teamId === this.homeTeam.id;
                // baseOffsets artÄ±k direkt motor koordinatlarÄ±nda (105x68)
                const base = this.baseOffsets[p.id] || { x: PITCH_CENTER_X, y: PITCH_CENTER_Y };
                this.sim.players[p.id] = {
                    x: isHome ? base.x : PITCH_LENGTH - base.x,
                    y: isHome ? base.y : PITCH_WIDTH - base.y,
                    facing: 0, vx: 0, vy: 0, state: 'IDLE'
                };
            }
            if (!this.playerStates[p.id]) {
                const base = this.baseOffsets[p.id] || { x: PITCH_CENTER_X, y: PITCH_CENTER_Y };
                this.playerStates[p.id] = {
                    currentStamina: p.condition || 100,
                    decisionTimer: Math.random() * 5, possessionCooldown: 0, actionLock: 0,
                    targetX: base.x, targetY: base.y, momentum: 0, isPressing: false
                };
            }

            const isHome = p.teamId === this.homeTeam.id;
            const hasBall = p.id === this.sim.ball.ownerId;
            const state = this.playerStates[p.id];
            const tactic = isHome ? this.homeTeam.tactic : this.awayTeam.tactic;

            if (state.possessionCooldown > 0) state.possessionCooldown--;
            if (state.actionLock > 0) state.actionLock--;

            if (state.actionLock > 0 && !hasBall) {
                const simP = this.sim.players[p.id];
                simP.vx *= 0.85;
                simP.vy *= 0.85;
                simP.x += simP.vx;
                simP.y += simP.vy;

                // Gravity even when locked
                if (simP.z && simP.z > 0) {
                    simP.z -= 0.2;
                    if (simP.z < 0) simP.z = 0;
                }
                return;
            }

            // Gravity for Jump (Player Z-axis physics)
            if (this.sim.players[p.id].z && this.sim.players[p.id].z! > 0) {
                this.sim.players[p.id].z! -= 0.2;
                if (this.sim.players[p.id].z! < 0) this.sim.players[p.id].z = 0;
            }

            if (hasBall) {
                this.updateBallCarrierAI(p, isHome, isHome ? awayDefLine : homeDefLine, isHome ? 100 : 0);
                this.sim.players[p.id].state = 'RUN';
                state.isPressing = false;
            } else {
                // Check if it's a set piece and player should hold position
                const isSetPiece = this.sim.mode === 'KICKOFF' || this.sim.mode?.includes('GOAL_KICK') || this.sim.mode?.includes('CORNER') || this.sim.mode?.includes('FREE_KICK') || this.sim.mode?.includes('PENALTY') || this.sim.mode?.includes('THROW_IN');
                if (isSetPiece && this.sim.ball.ownerId) {
                    // If ball owner is on my team, hold position or move to base offset
                    const ballOwnerTeam = this.getPlayer(this.sim.ball.ownerId)?.teamId;
                    if (ballOwnerTeam === p.teamId) {
                        const base = this.baseOffsets[p.id];
                        if (base) {
                            const targetX = p.teamId === this.homeTeam.id ? base.x : PITCH_LENGTH - base.x;
                            const targetY = p.teamId === this.homeTeam.id ? base.y : PITCH_WIDTH - base.y;
                            this.applySteeringBehavior(p, targetX, targetY, MAX_PLAYER_SPEED * 0.5);
                            this.sim.players[p.id].state = 'IDLE';
                        }
                        return;
                    }
                }

                if (!ballOwner && p.id === this.currentLooseBallChaserId) {
                    // === AKILLI SAHIPSÄ°Z TOP KOVALAMASI (v2) ===
                    const ballSpeed = Math.sqrt(this.sim.ball.vx ** 2 + this.sim.ball.vy ** 2);
                    const distToBall = dist(this.sim.players[p.id].x, this.sim.players[p.id].y, this.sim.ball.x, this.sim.ball.y);

                    const lookAhead = ballSpeed > 2.0 ? Math.min(8, distToBall / ballSpeed)
                        : ballSpeed > 1.0 ? 4
                            : 2;
                    let interceptX = this.sim.ball.x + (this.sim.ball.vx * lookAhead);
                    const interceptY = this.sim.ball.y + (this.sim.ball.vy * lookAhead);

                    // === OFSAYT KONTROLÃœ: Forvet sahipsiz topa koÅŸarken ofsayda girmesin! ===
                    if (this.playerRoles[p.id] === Position.FWD) {
                        const fwdDefLine = isHome ? awayDefLine : homeDefLine;
                        if (isHome) {
                            interceptX = Math.min(interceptX, fwdDefLine - 2.0);
                        } else {
                            interceptX = Math.max(interceptX, fwdDefLine + 2.0);
                        }
                    }

                    this.applySteeringBehavior(p, interceptX, interceptY, MAX_PLAYER_SPEED);
                    this.sim.players[p.id].state = 'SPRINT';
                    state.isPressing = true;
                }
                else if (this.playerRoles[p.id] === Position.GK) {
                    this.updateGoalkeeperAI(p, isHome);
                } else {
                    this.updateOffBallAI(p, isHome, owningTeamId === p.teamId, owningTeamId !== null, isHome ? awayDefLine : homeDefLine, isHome ? 100 : 0);
                }
            }
        });

        this.resolveCollisions();

        // === G MOTORU: PROAKTÄ°F SÄ°NYAL SÄ°STEMÄ° ===
        // Oyuncular her an Ã§evrelerini tarar ve uygunsa sinyal verir
        this.updatePlayerSignals();
        this.clearExpiredSignals();

        event = this.checkGameEvents();

        // DEBUG: Log event from checkGameEvents
        if (DEBUG_MATCH && event) {
            console.log(`ðŸ”´ EVENT RETURNED: type=${event.type}, desc=${event.description}`);
        }

        // Collect all pending events (subs, etc.) and clear
        const allEvents = [...this.pendingEvents];
        if (event) allEvents.push(event);
        this.pendingEvents = [];

        // === PRIORITY FIX: GOAL events must be returned first! ===
        // Sort so GOAL comes first, then FOUL/CARD, then others
        allEvents.sort((a, b) => {
            const priority = (e: MatchEvent) => {
                if (e.type === MatchEventType.GOAL) return 0;
                if (e.type === MatchEventType.CARD_RED) return 1;
                if (e.type === MatchEventType.CARD_YELLOW) return 2;
                if (e.type === MatchEventType.FOUL) return 3;
                if (e.type === MatchEventType.FREE_KICK) return 4;
                if (e.type === MatchEventType.CORNER) return 5;
                if (e.type === MatchEventType.KICKOFF) return 10; // Low priority
                return 6;
            };
            return priority(a) - priority(b);
        });

        // DEBUG: Sadece Ã¶nemli olaylarÄ± logla (GOAL, CARD)
        // Removed console.log for production performance

        // === PERFORMANCE CRITICAL FIX ===
        // REMOVED: JSON.parse(JSON.stringify(this.sim)) - was killing mobile performance!
        // The deep clone was executing 60-83 times per second (depending on speed setting)
        // causing massive GC pressure and CPU thrashing.
        // 
        // NEW: Inject stamina directly into sim.players. This is safe because:
        // 1. UI only READS simulation data, never modifies it
        // 2. Stamina values are recalculated every tick anyway
        // 3. This eliminates ~95% of per-tick memory allocation
        Object.keys(this.playerStates).forEach(id => {
            if (this.sim.players[id]) {
                (this.sim.players[id] as any).stamina = this.playerStates[id].currentStamina;
                (this.sim.players[id] as any).outgoingSignal = this.playerStates[id].outgoingSignal;
            }
        });

        return {
            minuteIncrement: this.tickCount === 0,
            event: allEvents.length > 0 ? allEvents[0] : null, // Primary event (GOAL now takes priority!)
            additionalEvents: allEvents.length > 1 ? allEvents.slice(1) : [], // Other events (subs, kickoff)
            trace: this.traceLog,
            liveData: {
                ballHolderId: this.sim.ball.ownerId,
                pitchZone: this.sim.ball.x,
                lastActionText: this.getActionText(owningTeamId),
                simulation: this.sim // Direct reference - no cloning!
            },
            stats: { ...this.match.stats }
        };
    }

    private calculateDefensiveLine(isHome: boolean): number {
        const teamPlayers = isHome ? this.homePlayers : this.awayPlayers;
        // === OFSAYT HATTI FIX: KALECÄ° HARÄ°Ã‡! ===
        // GerÃ§ek futbolda ofsayt, son 2 SAHA oyuncusuna (kaleci hariÃ§) gÃ¶re belirlenir.
        // Eski kod kaleci dahil ediyordu â†’ hat yanlÄ±ÅŸ hesaplanÄ±yordu.
        const outfieldPositionsX = teamPlayers
            .filter(p => this.sim.players[p.id] && this.playerRoles[p.id] !== Position.GK)
            .map(p => this.sim.players[p.id].x);

        if (outfieldPositionsX.length < 2) {
            return isHome ? 10 : 90;
        }

        if (isHome) {
            outfieldPositionsX.sort((a, b) => a - b);
            // Ä°lk deÄŸer = en geri saha oyuncusu (genelde stoper)
            // Ä°kinci deÄŸer = ikinci en geri saha oyuncusu â†’ OFSAYT HATTI
            return outfieldPositionsX[1];
        } else {
            outfieldPositionsX.sort((a, b) => b - a);
            return outfieldPositionsX[1];
        }
    }

    private updateBallPhysics() {
        if (this.sim.ball.ownerId) return;

        const b = this.sim.ball;
        const friction = (b.z > 0.5) ? BALL_AIR_DRAG : BALL_FRICTION;

        if (b.curve && Math.abs(b.curve) > 0.01 && b.z > 0) {
            const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
            const curveForce = b.curve * speed * 0.005;
            const angle = Math.atan2(b.vy, b.vx);
            b.vx += Math.cos(angle + Math.PI / 2) * curveForce;
            b.vy += Math.sin(angle + Math.PI / 2) * curveForce;
            b.curve *= 0.95;
        }

        b.vx *= friction; b.vy *= friction;
        b.x += b.vx; b.y += b.vy;

        if (b.z > 0 || b.vz > 0) {
            b.vz -= GRAVITY;
            b.z += b.vz;
            if (b.z < 0) {
                // === GELÄ°ÅžTÄ°RÄ°LMÄ°Åž TOP ZIPLAYIÅžI ===
                b.z = 0;
                b.vz = -b.vz * BALL_BOUNCE; // Sabit zÄ±plama katsayÄ±sÄ± kullan

                // Ã‡ok dÃ¼ÅŸÃ¼k zÄ±plama varsa durdur
                if (Math.abs(b.vz) < 0.3) b.vz = 0;

                // Yere deÄŸince sÃ¼rtÃ¼nme
                b.vx *= 0.85;
                b.vy *= 0.85;
            }
        }

        if (b.z === 0 && Math.abs(b.vx) < 0.02 && Math.abs(b.vy) < 0.02) { b.vx = 0; b.vy = 0; }
        b.y = clamp(b.y, 0.5, PITCH_WIDTH - 0.5);

        // ========== GOALKEEPER SAVE MECHANIC (PANTHER MODE v2) ==========
        const ballSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        const isShotOnGoal = ballSpeed > 1.2; // Biraz daha yavaÅŸ toplarÄ± da ÅŸut saysÄ±n

        if (isShotOnGoal) {
            // Check if ball is heading towards a goal
            const headingToLeftGoal = b.vx < -0.5 && b.x < 26;  // Ceza sahasÄ± + birkaÃ§ metre
            const headingToRightGoal = b.vx > 0.5 && b.x > 79;  // 105-26 = 79

            if (headingToLeftGoal || headingToRightGoal) {
                const defendingTeam = headingToLeftGoal ? this.homePlayers : this.awayPlayers;
                const gk = defendingTeam.find(p => this.playerRoles[p.id] === Position.GK);

                if (gk && this.sim.players[gk.id]) {
                    const gkPos = this.sim.players[gk.id];
                    const distToGK = dist(b.x, b.y, gkPos.x, gkPos.y);

                    // === KALECÄ° YORGUNLUK SÄ°STEMÄ° ===
                    const gkState = this.playerStates[gk.id];
                    const gkFatigueMods = getAllFatigueModifiers(gkState?.currentStamina || 100, true);

                    // Kaleci statlarÄ±nÄ± "Floor" ile yukarÄ± Ã§ekiyoruz (Kumbara olmasÄ±nlar diye)
                    const effectiveGKing = applyStatFloor(gk.attributes.goalkeeping, 55) * gkFatigueMods.goalkeeping;
                    const effectiveReflexes = applyStatFloor(gk.attributes.goalkeeping, 55) * 0.7 + applyStatFloor(gk.attributes.composure, 50) * 0.3;
                    const effectivePositioning = applyStatFloor(gk.attributes.positioning, 50) * gkFatigueMods.positioning;

                    // === ERÄ°ÅžÄ°M MESAFESÄ° (REACH - NERF: Kaleci Daha Ä°nsani) ===
                    // Kalecinin uzanabileceÄŸi alan. BUFF: Ä°yi ÅŸutlar artÄ±k gol olabilir!
                    const isCloseRange = distToGK < 7;
                    let gkReachBase = 4.0; // 4.5 -> 4.0 (Daha insani eriÅŸim)
                    if (isCloseRange) gkReachBase = 3.0; // 3.5 -> 3.0 (YakÄ±nda daha zor)

                    // === 1v1 NERF: Kaleci direkt karÅŸÄ± karÅŸÄ±ya geldiÄŸinde ===
                    // GerÃ§ek futbolda 1v1'lerde kaleci %30-40 kurtarma oranÄ±na sahip
                    let is1v1Shot = false;
                    if (isCloseRange) {
                        // Top taÅŸÄ±yanÄ± bul, kaleciye Ã§ok yakÄ±n mÄ±?
                        const ballOwnerBefore = this.lastTouchTeamId;
                        const isAttackOnThisGoal = headingToLeftGoal
                            ? (ballOwnerBefore !== this.homeTeam.id)
                            : (ballOwnerBefore !== this.awayTeam.id);
                        if (isAttackOnThisGoal && distToGK < 12) {
                            is1v1Shot = true;
                            gkReachBase -= 0.8; // 1v1'de eriÅŸim azalsÄ±n
                        }
                    }

                    // Kaleci hÄ±zÄ± eriÅŸimi artÄ±rÄ±r
                    const speedBonus = (gk.attributes.speed || 50) / 100;

                    // Refleks HesaplamasÄ±: Top hÄ±zÄ±na yetiÅŸebilir mi?
                    // Top Ã§ok hÄ±zlÄ±ysa eriÅŸim mesafesi dÃ¼ÅŸer
                    const speedFactor = ballSpeed * 1.2; // BUFF: Zorluk katsayÄ±sÄ± dÃ¼ÅŸÃ¼rÃ¼ldÃ¼ (1.5 -> 1.2)
                    const reactionDeficit = Math.max(0, speedFactor - (effectiveReflexes / 7)); // BUFF: /8 -> /7
                    const reflexPenalty = reactionDeficit * 0.30; // FINAL HYBRID: 0.30 (Stronger than base, balanced)

                    const gkReach = Math.max(2.5, gkReachBase + (effectiveGKing / 60) - reflexPenalty + speedBonus);

                    // Top kalecinin eriÅŸim alanÄ±ndaysa ve Ã§ok yÃ¼ksek deÄŸilse (aÅŸÄ±rtma hariÃ§)
                    if (distToGK < gkReach && b.z < 3.0) {

                        // === KURTARIÅž ÅžANSI HESABI (v5 - GK FINAL NERF) ===
                        // 17 ÅŸut, 11 isabet, 0 gol = kaleci hala panter
                        // FINAL FIX: baseSaveChance negatif baÅŸlat, sadece yetenekli kaleciler kurtarsÄ±n
                        const speedPenalty = ballSpeed * (isCloseRange ? 14 : 11); // 13/10 â†’ 14/11
                        const heightBonus = b.z > 0 ? -12 : 0; // -10 â†’ -12
                        const distanceBonus = (gkReach - distToGK) * 5; // 6 â†’ 5

                        const positioningBonus = (effectivePositioning - 50) / 6; // /5 â†’ /6


                        // BASE CHANCE: Temel kurtarÄ±ÅŸ ÅŸansÄ±
                        // PANTHER MODE v2: -10 -> -5
                        let baseSaveChance = -5;

                        // === 1v1 NERF ===
                        // Direkt karÅŸÄ± karÅŸÄ±yada kaleci kurtarma ÅŸansÄ± dÃ¼ÅŸsÃ¼n!
                        if (is1v1Shot) {
                            baseSaveChance -= 15; // 1v1'de -15 ceza
                        }

                        // PlayStyles (Ã–zel Yetenekler) Etkisi
                        if (gk.playStyles?.includes("Kedi Refleks") || gk.playStyles?.includes("Kedi Refleks+")) {
                            baseSaveChance += 12;
                        }
                        if (gk.playStyles?.includes("Birebir") && isCloseRange) {
                            baseSaveChance += 15; // "Birebir" yeteneÄŸi 1v1 nerf'ini kÄ±smen karÅŸÄ±lar!
                        }

                        // RESTORE: 0.65 -> 0.78 (Kaleci stat etkisi artÄ±rÄ±ldÄ±)
                        const saveChance = baseSaveChance + (effectiveGKing * 0.78) + distanceBonus + heightBonus + positioningBonus - speedPenalty;

                        // Åžans faktÃ¶rÃ¼ (Zar atÄ±yoruz)
                        const saveRoll = Math.random() * 100;

                        if (saveRoll < saveChance) {
                            // === KURTARIÅž BAÅžARILI! ===

                            // Topu tutacak mÄ± yoksa Ã§elecek mi?
                            const catchRoll = Math.random();
                            const catchThreshold = 0.4 * gkFatigueMods.composure; // %40 ÅŸansla tutar (nerf: daha Ã§ok sektirme)

                            if (catchRoll < catchThreshold && ballSpeed < 3.5) {
                                // YAPIÅžTIRDI (Catch)
                                this.sim.ball.ownerId = gk.id;
                                this.sim.ball.vx = 0; this.sim.ball.vy = 0; this.sim.ball.vz = 0; this.sim.ball.z = 0;
                                this.lastTouchTeamId = gk.teamId;
                                this.traceLog.push(`ðŸ§¤ ${gk.lastName} topu kontrolÃ¼ne aldÄ±!`);
                            } else {
                                // Ã‡ELDÄ° (Parry/Deflect)
                                // Topu rastgele ama kaleden uzaÄŸa sektir
                                const deflectAngle = Math.atan2(b.vy, b.vx) + (Math.random() > 0.5 ? 1.5 : -1.5); // 90 derece yana
                                let deflectPower = ballSpeed * (0.3 + Math.random() * 0.2); // NERF: Daha az sekme
                                // PENALTI FIX: KurtarÄ±ÅŸta top karÅŸÄ± kaleye gitmesin!
                                deflectPower = Math.min(deflectPower, 1.5); // Maksimum 1.5 birim hÄ±z

                                b.vx = Math.cos(deflectAngle) * deflectPower;
                                b.vy = Math.sin(deflectAngle) * deflectPower;
                                b.vz = 1.0 + Math.random() * 0.5; // Daha az havaya (1.5-2.5 â†’ 1.0-1.5)

                                this.playerStates[gk.id].possessionCooldown = 10; // Ã‡abuk toparlan
                                this.lastTouchTeamId = gk.teamId;
                                this.traceLog.push(`ðŸ§¤ ${gk.lastName} son anda Ã§eldi!`);
                            }

                            // Ä°statistik GÃ¼ncelle
                            if (headingToLeftGoal) this.match.stats.homeSaves = (this.match.stats.homeSaves || 0) + 1;
                            else this.match.stats.awaySaves = (this.match.stats.awaySaves || 0) + 1;

                            return; // Gol iptal, dÃ¶ngÃ¼den Ã§Ä±k
                        }
                    }
                }
            }
        }
        // ========== END GOALKEEPER SAVE MECHANIC ==========

        // Hava toplarÄ± iÃ§in yakalama - yÃ¼kseklik ve mesafe sÄ±nÄ±rlandÄ±
        const maxPickupHeight = 4.0;  // 15 â†’ 4 (oyuncu zÄ±plama yÃ¼ksekliÄŸi)
        if (b.z < maxPickupHeight) {
            let closestP: Player | null = null;

            // Yakalama mesafesi hesaplama
            const ballSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
            // YavaÅŸ toplar daha kolay yakalanÄ±r (daha geniÅŸ mesafe)
            const speedBonus = Math.max(0, (2.0 - ballSpeed) * 0.5); // YavaÅŸ top â†’ +1.0 mesafe
            const basePickupDist = b.z < 0.5 ? 3.0 : 2.5;  // Yerdeki top iÃ§in daha geniÅŸ
            const heightPenalty = b.z * 0.3;  // YÃ¼kseldikÃ§e yakalama zorlaÅŸÄ±r
            let minD = Math.max(1.2, basePickupDist + speedBonus - heightPenalty);

            // === HAVA TOPU MÃœCADELESÄ° (Korner/Orta) ===
            // EÄŸer top havada ve birden fazla oyuncu yakÄ±nsa, dÃ¼ello yap!
            const nearbyPlayers: { player: Player, dist: number, jumpPower: number }[] = [];

            [...this.homePlayers, ...this.awayPlayers].forEach(p => {
                if (!this.playerStates[p.id] || this.playerStates[p.id].possessionCooldown > 0 || !this.sim.players[p.id]) return;
                if (p.lineup !== 'STARTING') return;

                const pPos = this.sim.players[p.id];
                const d = dist(pPos.x, pPos.y, b.x, b.y);

                // Hava topuna koÅŸma davranÄ±ÅŸÄ± - top havada ve yakÄ±nsa topa koÅŸ!
                if (b.z > 1.0 && d < 12 && d > 3) {
                    // Topun dÃ¼ÅŸeceÄŸi yere koÅŸ
                    const landingX = b.x + b.vx * 5;
                    const landingY = b.y + b.vy * 5;

                    // Sadece kendi bÃ¶lgesine yakÄ±nsa koÅŸ (herkes koÅŸmasÄ±n)
                    const isInMyZone = Math.abs(pPos.x - landingX) < 20 && Math.abs(pPos.y - landingY) < 20;

                    if (isInMyZone) {
                        const state = this.playerStates[p.id];
                        state.targetX = landingX;
                        state.targetY = landingY;
                    }
                }

                if (d < minD + 2) { // Biraz daha geniÅŸ alanda rakip kontrolÃ¼
                    // Kafa gÃ¼cÃ¼ hesapla
                    let jumpPower = (p.attributes.strength || 50) * 0.4 + (p.attributes.positioning || 50) * 0.3;

                    // Hava Hakimi yeteneÄŸi
                    if (p.playStyles?.includes("Hava Hakimi") || p.playStyles?.includes("Hava Hakimi+")) {
                        jumpPower += 40;
                    }
                    if (p.playStyles?.includes("Hassas Kafa VuruÅŸu") || p.playStyles?.includes("Hassas Kafa VuruÅŸu+")) {
                        jumpPower += 25;
                    }

                    nearbyPlayers.push({ player: p, dist: d, jumpPower });
                }

                if (d < minD) { minD = d; closestP = p; }
            });

            // EÄŸer 2+ oyuncu varsa ve top yeterince yÃ¼ksekte, kafa dÃ¼ellosu!
            if (nearbyPlayers.length >= 2 && b.z > 1.5) {
                // En yÃ¼ksek jump power'a sahip oyuncu kazanÄ±r (mesafe de etkili)
                nearbyPlayers.sort((a, b2) => {
                    const scoreA = a.jumpPower - (a.dist * 8);
                    const scoreB = b2.jumpPower - (b2.dist * 8);
                    return scoreB - scoreA;
                });

                const winner = nearbyPlayers[0];
                const loser = nearbyPlayers[1];

                // DÃ¼ello animasyonu - her iki oyuncu da zÄ±pla
                if (this.sim.players[winner.player.id]) {
                    this.sim.players[winner.player.id].z = Math.min(b.z, 2.5);
                }
                if (this.sim.players[loser.player.id]) {
                    this.sim.players[loser.player.id].z = Math.min(b.z * 0.8, 2.0);
                }

                // Kazanan topu alÄ±r
                if (winner.dist < minD + 1) {
                    closestP = winner.player;
                }
            }

            if (closestP) {
                const p = closestP as Player;
                const ballSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                let technique = p.attributes.dribbling || 50;

                // === YETENEK ETKÄ°SÄ°: Ä°LK DOKUNUÅž ===
                // "Ä°lk DokunuÅŸ" yeteneÄŸi: Zor paslarÄ± %30 daha kolay kontrol
                if (p.playStyles?.includes("Ä°lk DokunuÅŸ") || p.playStyles?.includes("Ä°lk DokunuÅŸ+")) {
                    technique += 25;
                }

                // === YETENEK ETKÄ°SÄ°: TEKNÄ°K ===
                // "Teknik" yeteneÄŸi: Genel top kontrolÃ¼ %15 artar
                if (p.playStyles?.includes("Teknik") || p.playStyles?.includes("Teknik+")) {
                    technique += 15;
                }

                // Hava toplarÄ± iÃ§in strength etkisi - gÃ¼Ã§lÃ¼ oyuncular daha iyi kafa vuruyor
                let strengthBonus = b.z > 1 ? (p.attributes.strength || 50) * 0.3 : 0;

                // === YETENEK ETKÄ°SÄ°: HAVA HAKÄ°MÄ° ===
                // "Hava Hakimi" yeteneÄŸi: Kafa vuruÅŸlarÄ± ve hava toplarÄ±nda %40 bonus
                if (b.z > 0.5 && (p.playStyles?.includes("Hava Hakimi") || p.playStyles?.includes("Hava Hakimi+"))) {
                    strengthBonus += 35;
                }

                // === YETENEK ETKÄ°SÄ°: HASSAS KAFA VURUÅžU ===
                // "Hassas Kafa VuruÅŸu" yeteneÄŸi: Hava toplarÄ±nda isabet %25 bonus
                if (b.z > 0.5 && (p.playStyles?.includes("Hassas Kafa VuruÅŸu") || p.playStyles?.includes("Hassas Kafa VuruÅŸu+"))) {
                    strengthBonus += 20;
                }

                const heightDifficulty = b.z > 1 ? 25 : 0;
                const difficulty = ballSpeed * 12 + heightDifficulty;

                // Strength hava topu kontrolÃ¼nÃ¼ etkiler
                if (Math.random() * 110 + technique + strengthBonus > difficulty) {
                    // === OFSAYT KONTROLÃœ: TOP ALMA ANINDA ===
                    // Pas veya ÅŸut sonrasÄ± sahipsiz topa deÄŸen oyuncu ofsaytta mÄ±?
                    const pPos = this.sim.players[p.id];
                    const isPlayerHome = p.teamId === this.homeTeam.id;
                    const wasOwnTeamTouch = this.lastTouchTeamId === p.teamId;
                    const playerRole = this.playerRoles[p.id];
                    let offsideCaught = false;

                    // Sadece kendi takÄ±mdan gelen top + ileri oyuncular kontrol edilsin
                    // (Rakip topunu Ã§alan oyuncu ofsayt olmaz!)
                    if (wasOwnTeamTouch && playerRole !== Position.GK && playerRole !== Position.DEF && pPos) {
                        const defLine = isPlayerHome ? this._awayDefLine : this._homeDefLine;
                        if (defLine !== undefined) {
                            const isOffside = isPlayerHome
                                ? pPos.x > defLine + 1.5  // 1.5m tolerans
                                : pPos.x < defLine - 1.5;

                            if (isOffside) {
                                // OFSAYT! Top alma iptal
                                this.sim.ball.ownerId = null;
                                this.sim.ball.vx = 0;
                                this.sim.ball.vy = 0;
                                this.sim.ball.vz = 0;
                                this.sim.ball.x = pPos.x;
                                this.sim.ball.y = pPos.y;
                                this.traceLog.push(`ðŸš© OFSAYT! ${p.lastName} sahipsiz topu ofsayt pozisyonda aldÄ±!`);
                                this.pendingEvents.push({
                                    minute: this.internalMinute,
                                    type: MatchEventType.OFFSIDE,
                                    description: `ðŸš© ${p.lastName} ofsayt! Serbest vuruÅŸ.`,
                                    teamId: p.teamId,
                                    playerId: p.id
                                });
                                // Rakip takÄ±ma ver
                                const enemyTeamPlayers = isPlayerHome ? this.awayPlayers : this.homePlayers;
                                const nearestEnemy = enemyTeamPlayers
                                    .filter(ep => ep.lineup === 'STARTING' && this.playerRoles[ep.id] === Position.DEF)
                                    .sort((a2, b2) => dist(this.sim.players[a2.id]?.x || 0, this.sim.players[a2.id]?.y || 0, pPos.x, pPos.y) - dist(this.sim.players[b2.id]?.x || 0, this.sim.players[b2.id]?.y || 0, pPos.x, pPos.y))[0];
                                if (nearestEnemy) {
                                    this.sim.ball.ownerId = nearestEnemy.id;
                                }
                                this.playerStates[p.id].possessionCooldown = 20;
                                offsideCaught = true;
                            }
                        }
                    }

                    if (!offsideCaught) {
                        this.sim.ball.ownerId = p.id;
                        (this.sim.ball as any).targetId = null; // Hedef artÄ±k ulaÅŸtÄ±, temizle
                        this.sim.ball.vx = 0; this.sim.ball.vy = 0; this.sim.ball.z = 0; this.sim.ball.curve = 0;
                        this.lastTouchTeamId = p.teamId;

                        // Visual Jump Effect
                        if (b.z > 0.5) {
                            this.sim.players[p.id].z = Math.min(b.z, 2.0); // Jump to ball height
                        }
                    }
                } else {
                    b.vx *= 0.6; b.vy *= 0.6;
                    this.playerStates[p.id].possessionCooldown = 8;
                    this.lastTouchTeamId = p.teamId;
                }
            }
        }
    }

    private updateGoalkeeperAI(p: Player, isHome: boolean) {
        if (!this.sim.players[p.id]) return;
        const simP = this.sim.players[p.id];
        const goalX = isHome ? 0 : PITCH_LENGTH;
        const goalY = PITCH_CENTER_Y;
        const ballX = this.sim.ball.x;
        const ballY = this.sim.ball.y;
        const distToBall = dist(simP.x, simP.y, ballX, ballY);
        const isBallLoose = this.sim.ball.ownerId === null;
        const ballCarrierId = this.sim.ball.ownerId;

        // === 1V1 DURUMU TESPÄ°TÄ° ===
        // Top taÅŸÄ±yan rakip kaleye yakÄ±n ve tek baÅŸÄ±naysa
        let is1v1Situation = false;
        if (ballCarrierId) {
            const carrier = this.getPlayer(ballCarrierId);
            if (carrier && carrier.teamId !== p.teamId) {
                const carrierPos = this.sim.players[ballCarrierId];
                if (carrierPos) {
                    const carrierDistToGoal = isHome ? carrierPos.x : (PITCH_LENGTH - carrierPos.x);
                    // Kaleciye 25 metreden yakÄ±n ve savunmacÄ± yok
                    if (carrierDistToGoal < 25) {
                        // Arada savunmacÄ± var mÄ± kontrol et
                        const myTeam = isHome ? this.homePlayers : this.awayPlayers;
                        const defendersInPath = myTeam.filter(def => {
                            if (def.id === p.id) return false; // Kaleci hariÃ§
                            const defPos = this.sim.players[def.id];
                            if (!defPos) return false;
                            // SavunmacÄ± top taÅŸÄ±yan ile kale arasÄ±nda mÄ±?
                            const defDistToGoal = isHome ? defPos.x : (PITCH_LENGTH - defPos.x);
                            return defDistToGoal < carrierDistToGoal && dist(defPos.x, defPos.y, carrierPos.x, carrierPos.y) < 10;
                        });

                        is1v1Situation = defendersInPath.length === 0;
                    }
                }
            }
        }

        // === ORTA/CROSS TESPÄ°TÄ° ===
        // Top kanattan geliyor ve ceza sahasÄ±na doÄŸru mu?
        const isCrossIncoming = !isBallLoose &&
            (ballY < 17 || ballY > 51) && // Kanat (68m geniÅŸlikte)
            ((isHome && ballX < 37) || (!isHome && ballX > 68)) && // Ceza sahasÄ± yakÄ±nÄ±
            Math.abs(this.sim.ball.vy) > 0.5; // Top iÃ§eri doÄŸru hareket ediyor

        // === SAHÄ°PSÄ°Z TOP - Ã‡IKIÅž ===
        if (isBallLoose && distToBall < 25 && ((isHome && ballX < 32) || (!isHome && ballX > 73))) {
            const ballSpeed = Math.sqrt(this.sim.ball.vx ** 2 + this.sim.ball.vy ** 2);
            if (ballSpeed > 0.5 || distToBall < 10) {
                this.applySteeringBehavior(p, ballX + this.sim.ball.vx * 2, ballY + this.sim.ball.vy * 2, MAX_PLAYER_SPEED);
                simP.state = 'SPRINT';
                return;
            }
        }

        // === 1V1 POZÄ°SYON ALMA ===
        if (is1v1Situation && ballCarrierId) {
            const carrierPos = this.sim.players[ballCarrierId];
            if (carrierPos) {
                // Kaleci hÃ¼cumcuya doÄŸru Ã§Ä±ksÄ±n, aÃ§Ä±yÄ± kapatsÄ±n
                const rushDist = Math.min(12, distToBall * 0.4); // Maksimum 12m Ã§Ä±k
                const angleToCarrier = Math.atan2(carrierPos.y - simP.y, carrierPos.x - simP.x);

                let targetX = simP.x + Math.cos(angleToCarrier) * rushDist * 0.3;
                let targetY = simP.y + Math.sin(angleToCarrier) * rushDist * 0.3;

                // Ã‡izgiden fazla uzaklaÅŸma (16.5m = ceza sahasÄ±)
                targetX = isHome ? clamp(targetX, 0, PENALTY_BOX_DEPTH) : clamp(targetX, PITCH_LENGTH - PENALTY_BOX_DEPTH, PITCH_LENGTH);

                // "Ortaya Ã‡Ä±kan" yeteneÄŸi: Daha agresif Ã§Ä±kÄ±ÅŸ
                if (p.playStyles?.includes("Ortaya Ã‡Ä±kan") || p.playStyles?.includes("Ortaya Ã‡Ä±kan+")) {
                    targetX = isHome ? clamp(targetX, 0, 22) : clamp(targetX, PITCH_LENGTH - 22, PITCH_LENGTH);
                }

                this.applySteeringBehavior(p, targetX, targetY, MAX_PLAYER_SPEED * 0.85);
                simP.facing = angleToCarrier;
                simP.state = 'RUN';
                return;
            }
        }

        // === ORTA POZÄ°SYONU ===
        if (isCrossIncoming && this.sim.ball.z > 0.5) {
            // Topun dÃ¼ÅŸeceÄŸi yere doÄŸru hareket et
            const predictedY = ballY + this.sim.ball.vy * 5;
            const predictedX = ballX + this.sim.ball.vx * 5;

            // Sadece ceza sahasÄ± iÃ§inde hareket et
            const maxOutX = isHome ? 8 : PITCH_LENGTH - 8;
            let targetX = isHome ? Math.min(predictedX, maxOutX) : Math.max(predictedX - 2, PITCH_LENGTH - 12);
            let targetY = clamp(predictedY, GOAL_Y_TOP - 2, GOAL_Y_BOTTOM + 2); // Kale geniÅŸliÄŸi civarÄ±nda kal

            // "UzaÄŸa FÄ±rlatma" yeteneÄŸi: Cross'lara daha iyi mÃ¼dahale
            if (p.playStyles?.includes("UzaÄŸa FÄ±rlatma") || p.playStyles?.includes("UzaÄŸa FÄ±rlatma+")) {
                targetX = isHome ? Math.min(predictedX + 2, 12) : Math.max(predictedX - 2, PITCH_LENGTH - 12);
            }

            this.applySteeringBehavior(p, targetX, targetY, MAX_PLAYER_SPEED * 0.8);
            simP.state = 'RUN';
            return;
        }

        // === NORMAL POZÄ°SYON ALMA ===
        const angleToBall = Math.atan2(ballY - goalY, ballX - goalX);
        let idealDistFromLine = 2;
        if (distToBall < 30 && distToBall > 10) idealDistFromLine = 5;
        if (distToBall <= 10) idealDistFromLine = 3;

        let targetX = goalX + (Math.cos(angleToBall) * idealDistFromLine);
        let targetY = goalY + (Math.sin(angleToBall) * idealDistFromLine);

        let clampedX = isHome ? clamp(targetX, 0, PENALTY_BOX_DEPTH) : clamp(targetX, PITCH_LENGTH - PENALTY_BOX_DEPTH, PITCH_LENGTH);

        this.applySteeringBehavior(p, clampedX, targetY, MAX_PLAYER_SPEED * 0.7);
        simP.facing = angleToBall;
        simP.state = 'IDLE';
    }

    // === G MOTORU: GÃ–RÃœÅž AÃ‡ISI HESAPLAMA (GÃœNCELLENMÄ°Åž) ===
    private calculateShotOpening(x: number, y: number, targetX: number, isHome: boolean): number {
        const dx = targetX - x;
        const dy = PITCH_CENTER_Y - y;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const distToTarget = Math.sqrt(dx * dx + dy * dy);

        // Hedefe giden vektÃ¶r
        const angleToTarget = Math.atan2(dy, dx);

        // Tarama konisi (45 derece)
        const coneWidth = Math.PI / 4;

        let blockage = 0;
        const enemies = isHome ? this.awayPlayers : this.homePlayers;

        // Ã–nÃ¼mdeki rakiplere bak
        for (const e of enemies) {
            const ePos = this.sim.players[e.id];
            if (!ePos) continue;

            const d = dist(x, y, ePos.x, ePos.y);
            if (d > 25) continue; // Ã‡ok uzaktakiler Ã¶nemli deÄŸil

            const angleToE = Math.atan2(ePos.y - y, ePos.x - x);
            const angleDiff = Math.abs(angleToE - angleToTarget);

            // EÄŸer rakip hedef aÃ§Ä±mÄ±n iÃ§indeyse
            if (angleDiff < coneWidth / 2) {
                // YakÄ±nlÄ±k cezasÄ±: Ne kadar yakÄ±nsa o kadar bloklar
                const proximityPenalty = 1.0 - (d / 25); // 0m=1.0, 25m=0.0
                blockage += proximityPenalty;
            }
        }

        // AÃ§Ä±klÄ±k skoru (0 ile 1 arasÄ±)
        return Math.max(0, 1.0 - blockage);
    }



    private updateBallCarrierAI(p: Player, isHome: boolean, offsideLineX: number, goalX: number) {
        if (!this.sim.players[p.id]) return;
        const simP = this.sim.players[p.id];
        const state = this.playerStates[p.id];
        const tactic = isHome ? this.homeTeam.tactic : this.awayTeam.tactic;

        // === MERKEZÄ° YORGUNLUK ETKÄ°SÄ° ===
        const technicalMod = getFatigueModifier(state.currentStamina, 'technical');
        const mentalMod = getFatigueModifier(state.currentStamina, 'mental');

        const dribbleSkill = (p.attributes.dribbling || 50) * technicalMod;
        let closeControl = 1.0 + ((100 - dribbleSkill) / 100);
        // Yorgunluk top kontrolÃ¼nÃ¼ zorlaÅŸtÄ±rÄ±r
        closeControl *= (2 - technicalMod); // technicalMod 1.0 â†’ 1.0x, 0.6 â†’ 1.4x zorluk

        this.sim.ball.x = simP.x + (Math.cos(simP.facing) * closeControl);
        this.sim.ball.y = simP.y + (Math.sin(simP.facing) * closeControl);

        // === PENALTY KICK EXECUTION ===
        // Force shoot if in penalty mode
        if (this.sim.mode === 'PENALTY_HOME' || this.sim.mode === 'PENALTY_AWAY') {
            state.decisionTimer++;
            // Wait 1 second (20 ticks) before shooting
            if (state.decisionTimer > 20) {
                this.actionShoot(p, isHome);
                this.sim.mode = undefined; // Reset mode to normal play (allows rebounds etc)

                // === PENALTI SONRASI: TÃ¼m oyuncularÄ± serbest bÄ±rak! ===
                // Aksi halde D-arc'ta donup kalÄ±yorlar
                const allPlayersArr = [...this.homePlayers, ...this.awayPlayers];
                for (const pp of allPlayersArr) {
                    if (pp.lineup === 'STARTING' && this.playerStates[pp.id]) {
                        this.playerStates[pp.id].actionLock = 0;
                    }
                }
            }
            return;
        }

        // --- GOALKEEPER AI (Clearance) ---
        if (this.playerRoles[p.id] === Position.GK) {
            const bestPass = this.findBestPassOption(p, isHome, offsideLineX, goalX);
            // GK prefers safe ground passing if available (high score)
            if (bestPass && bestPass.score > 20) {
                this.actionPass(p, bestPass.player, bestPass.type, bestPass.targetX, bestPass.targetY);
            } else {
                // Clear the ball
                this.sim.ball.ownerId = null;
                const clearAngle = isHome ? 0 : Math.PI;
                const power = 3.5 + Math.random();
                this.sim.ball.vx = Math.cos(clearAngle) * power;
                this.sim.ball.vy = Math.sin(clearAngle) * power;
                this.sim.ball.vz = 2.5;
                this.playerStates[p.id].possessionCooldown = 25;
            }
            return;
        }

        // --- CORNER KICK AI ---
        // KÃ¶ÅŸe vuruÅŸu pozisyonu: Saha kÃ¶ÅŸeleri (0,0), (0,68), (105,0), (105,68)
        const isCorner = (isHome ? simP.x > PITCH_LENGTH - 5 : simP.x < 5) && (simP.y < 5 || simP.y > PITCH_WIDTH - 5);
        if (isCorner) {
            const bestPass = this.findBestPassOption(p, isHome, offsideLineX, goalX);
            if (bestPass) {
                // Corners are usually Aerial unless short option is great
                const type = bestPass.score > 80 ? 'GROUND' : 'AERIAL';
                this.actionPass(p, bestPass.player, type, bestPass.targetX, bestPass.targetY);
                this.traceLog.push(`${p.lastName} korneri kullandÄ±.`);
                return;
            }
        }

        // --- GENERAL DECISION MAKING ---
        const obstacles = this.detectObstacles(p, simP.x, simP.y);
        const pressure = obstacles.length;
        let isHoldingUp = false;

        // Hold up play if strong and under pressure, but no pass
        // STRENGTH IMPACT - Strong players shield the ball better
        const strengthBonus = Math.max(0, (p.attributes.strength - 50) / 50); // 0-1 scale
        if (p.attributes.strength > 65 && pressure > 0 && state.currentStamina > 30) {
            const bestPass = this.findBestPassOption(p, isHome, offsideLineX, goalX);
            // Strong players can hold longer (extra timer reduction)
            const holdDuration = 15 + (strengthBonus * 10); // 15-25 ticks based on strength
            if ((!bestPass || bestPass.score < 20) && state.decisionTimer < holdDuration) {
                simP.vx *= (0.75 + strengthBonus * 0.1); // Strong players slow down less
                simP.vy *= (0.75 + strengthBonus * 0.1);
                state.decisionTimer -= 0.5;
                isHoldingUp = true;

                // HOLD signal - Tell teammates "I'm holding, find space!"
                if (Math.random() < 0.02) {
                    this.emitTeamSignal(p, 'HOLD');
                }
            }
        }

        let decisionSpeed = 8 - ((p.attributes.decisions || 50) / 25);
        if (tactic.tempo === 'Fast') decisionSpeed *= 0.6; // Faster decisions (0.7â†’0.6)
        else if (tactic.tempo === 'Slow') decisionSpeed *= 1.5; // Slower decisions (1.4â†’1.5)

        // === YILDIZ OYUNCU BONUSU ===
        // OVR 85+ oyuncular: Daha hÄ±zlÄ± ve daha iyi kararlar
        // Bu sayede City gibi takÄ±mlar "kilitlenmez"
        const playerOVR = p.overall || 70;
        if (playerOVR >= 85) {
            decisionSpeed *= 0.75; // %25 daha hÄ±zlÄ± karar
        } else if (playerOVR >= 80) {
            decisionSpeed *= 0.90; // %10 daha hÄ±zlÄ± karar
        }

        // NERF: Increase possession cooldown after shooting to prevent instant follow-up actions
        if (state.possessionCooldown > 0) state.possessionCooldown--;

        // === MERKEZÄ° YORGUNLUK ETKÄ°SÄ° - ZÄ°HÄ°NSEL ===
        // Yorgun oyuncular daha yavaÅŸ karar verir
        decisionSpeed *= (2 - mentalMod); // mentalMod 1.0 â†’ 1.0x, 0.6 â†’ 1.4x yavaÅŸ

        state.decisionTimer++;

        if (state.decisionTimer > decisionSpeed) {
            state.decisionTimer = 0;

            const distToGoal = dist(simP.x, simP.y, goalX, PITCH_CENTER_Y);

            // 1. EVALUATE SHOOTING
            let shootScore = 0;
            const shotOpenness = this.calculateShotOpening(simP.x, simP.y, goalX, isHome);
            const isStationary = Math.abs(simP.vx) < 0.1 && Math.abs(simP.vy) < 0.1;

            // === SMART FREE KICK LOGIC (GELÄ°ÅžTÄ°RÄ°LMÄ°Åž) ===
            // Serbest vuruÅŸ tespiti: GERÃ‡EK free kick modu VEYA duraÄŸan pozisyon
            const isRealFreeKick = this.sim.mode === 'FREE_KICK_HOME' || this.sim.mode === 'FREE_KICK_AWAY';
            const isFreeKickSituation = (isRealFreeKick || (isStationary && pressure === 0)) && distToGoal < 35;

            if (isFreeKickSituation) {
                // === BARAJ HESABI ===
                // Rakip oyuncularÄ±n serbest vuruÅŸ noktasÄ± ile kale arasÄ±nda duvarÄ± var mÄ±?
                const enemies = isHome ? this.awayPlayers : this.homePlayers;
                let wallBlockers = 0;
                let wallQuality = 0; // Baraj kalitesi (boylarÄ±, pozisyonlarÄ±)

                const shotAngleToGoal = Math.atan2(PITCH_CENTER_Y - simP.y, goalX - simP.x);

                enemies.forEach(e => {
                    if (!this.sim.players[e.id]) return;
                    const ePos = this.sim.players[e.id];

                    // Oyuncu top ile kale arasÄ±nda mÄ±?
                    const isInPath = isHome
                        ? (ePos.x > simP.x && ePos.x < goalX)
                        : (ePos.x < simP.x && ePos.x > goalX);

                    if (!isInPath) return;

                    // Åžut aÃ§Ä±sÄ±na ne kadar yakÄ±n?
                    const angleToEnemy = Math.atan2(ePos.y - simP.y, ePos.x - simP.x);
                    const angleDiff = Math.abs(shotAngleToGoal - angleToEnemy);

                    // AÃ§Ä± farkÄ± 0.3 radyan (~17 derece) iÃ§indeyse barajda
                    if (angleDiff < 0.3) {
                        wallBlockers++;
                        // Uzun oyuncular daha iyi engelliyor
                        wallQuality += (e.attributes.strength || 50) / 100;
                    }
                });

                // Serbest vuruÅŸ kararÄ±
                const finishingSkill = p.attributes.finishing || 50;
                const hasDeadBall = p.playStyles?.includes("Ã–lÃ¼ Top UzmanÄ±") || p.playStyles?.includes("Ã–lÃ¼ Top UzmanÄ±+");
                const hasCurve = p.playStyles?.includes("Plase Åžut") || p.playStyles?.includes("Plase Åžut+");

                // Åžut yeteneÄŸi hesabÄ±
                let fkShootSkill = finishingSkill;
                if (hasDeadBall) fkShootSkill += 25;
                if (hasCurve) fkShootSkill += 15;

                // Baraj etkisi: Her bloker ÅŸansÄ± dÃ¼ÅŸÃ¼rÃ¼r
                // Baraj cezasÄ± azaltÄ±ldÄ± (%30)
                const wallPenalty = (wallBlockers * 10 + wallQuality * 7);

                // === GERÃ‡EK SERBEST VURUÅž BONUSU ===
                // EÄŸer gerÃ§ek free kick modundaysak, neredeyse kesin ÅŸut Ã§ek!
                const realFkBonus = isRealFreeKick ? 500 : 0; // 150 -> 500 (Pas vermeyi engellemek iÃ§in)

                // === SERBEST VURUÅž KARARI ===
                // YakÄ±n mesafe (< 22m): Ä°yi ÅŸutÃ§ular direkt vurur
                // EÅŸikler dÃ¼ÅŸÃ¼rÃ¼ldÃ¼: 60 -> 50
                if (distToGoal < 22 && fkShootSkill > 50) {
                    const netScore = 400 + realFkBonus - wallPenalty + (fkShootSkill - 50) * 3;
                    if (netScore > 180) {
                        shootScore += netScore;
                        if (wallBlockers > 0) {
                            this.traceLog.push(`${p.lastName} frikik kullanÄ±yor... ${wallBlockers} kiÅŸilik barajÄ±n Ã¼stÃ¼nden!`);
                        } else {
                            this.traceLog.push(`${p.lastName} frikik kullanÄ±yor... Direkt Kaleye!`);
                        }
                    } else {
                        // Baraj Ã§ok gÃ¼Ã§lÃ¼, ama gerÃ§ek frikikse yine de dene
                        if (isRealFreeKick) shootScore += 200;
                        else shootScore -= 50;
                    }
                }
                // Orta mesafe (22-30m): Sadece uzman oyuncular
                // EÅŸikler dÃ¼ÅŸÃ¼rÃ¼ldÃ¼: 70 -> 60
                else if (distToGoal < 30 && fkShootSkill > 60) {
                    const netScore = 300 + realFkBonus - wallPenalty + (fkShootSkill - 60) * 5;
                    if (netScore > 120 && wallBlockers < 5) {
                        shootScore += netScore;
                        this.traceLog.push(`${p.lastName} uzak mesafeden frikik deniyor!`);
                    } else {
                        if (isRealFreeKick) shootScore += 150; // Uzak ama yine de dene
                        else shootScore -= 100;
                    }
                }
                // Uzak mesafe (30-35m): Ã‡ok nadir, sadece efsaneler
                else if (distToGoal < 35 && fkShootSkill > 80 && wallBlockers < 4) {
                    shootScore += 200 + realFkBonus;
                    this.traceLog.push(`${p.lastName} Ã§ok uzaktan frikik deniyor! (${Math.round(distToGoal)}m)`);
                }
                // Aksi halde pas tercih edilir (ama gerÃ§ek frikikse ÅŸut ÅŸansÄ± ver)
                else {
                    if (isRealFreeKick && distToGoal < 25) shootScore += 200; // YakÄ±nsa mecburen vur
                    else shootScore -= 200;
                }
            }
            // === NORMAL PLAY LOGIC ===
            else if (distToGoal < SHOOT_RANGE) {
                // BASE: Closer = Better
                // NERF: 120 -> 90 base score to significantly reduce random long shots
                shootScore = 90 - (distToGoal * 2.5);

                // === FINISHING-BASED DISTANCE PENALTY ===
                // Low finishing players should prefer VERY close shots
                const finishingFactor = Math.max(0.6, 2.0 - (p.attributes.finishing / 50));
                const distancePenalty = distToGoal * finishingFactor * 1.5; // Increased penalty multiplier

                // Low finishers get EXTRA penalty for long range (>20m)
                if (distToGoal > 20 && p.attributes.finishing < 75) {
                    shootScore -= (distToGoal - 20) * 5;
                }

                // Apply finishing factor penalty
                shootScore -= distancePenalty;

                // Openness is critical
                if (shotOpenness > 0.8) shootScore += 300; // Wide open!
                else if (shotOpenness > 0.5) shootScore += 100;
                else if (shotOpenness > 0.3) shootScore += 30;
                else shootScore -= 80;

                // FINISHING IMPACT
                shootScore += (p.attributes.finishing * 1.2) - 30;

                // FORWARD BONUS
                if (this.playerRoles[p.id] === Position.FWD) {
                    shootScore += 50;
                }

                // Angle penalty - AZALTILDI (kÃ¶ÅŸeden de ÅŸut Ã§ekilebilmeli)
                const angle = Math.abs(Math.atan2(PITCH_CENTER_Y - simP.y, goalX - simP.x));
                if (angle > 1.2) shootScore -= 80; // Ã‡ok kÃ¶tÃ¼ aÃ§Ä± (>70 derece)
                else if (angle > 0.9) shootScore -= 40; // Orta aÃ§Ä± (52-70 derece)

                // === DEATH ZONE (KILLER INSTINCT) ===
                // 10m within central goal area -> FORCE SHOT unless impossible
                const isDeathZone = distToGoal < 10 && Math.abs(simP.y - PITCH_CENTER_Y) < 10;
                if (isDeathZone && shotOpenness > 0.2) {
                    shootScore += 500; // NERFED: 1000 -> 500 (Less "Shoot on Sight")
                }

                // === PENALTY BOX SHOT BONUS ===
                // Ceza sahasÄ± iÃ§inde (< 16m) ve Ã¶nÃ¼ boÅŸsa, ÅŸut Ã§ek!
                // KÃ¶ÅŸeden bile olsa, boÅŸ kaleye ÅŸut atÄ±lmalÄ±
                const isPenaltyBox = distToGoal < 16;
                if (isPenaltyBox && shotOpenness > 0.6) {
                    shootScore += 200; // Ceza sahasÄ±nda aÃ§Ä±k pozisyon
                }
                // 6 yard box (< 6m) - neredeyse her zaman ÅŸut
                if (distToGoal < 6 && shotOpenness > 0.1) {
                    shootScore += 500;
                }

                // Tactic: Shoot On Sight
                if (distToGoal < 25 && p.playStyles?.includes("Uzaktan Åžut")) shootScore += 40;
            }

            // 2. EVALUATE PASSING
            let passScore = 0;
            const bestPass = this.findBestPassOption(p, isHome, offsideLineX, goalX);
            if (bestPass) {
                passScore = bestPass.score;
                // Bonus if "Playmaker" class
                if (this.playerRoles[p.id] === Position.MID) passScore += 10;

                // "Better Teammate" Rule: If I have low chance (<40%) but teammate has great chance, PASS
                if (shootScore < 50 && bestPass.score > 150) {
                    passScore += 100; // Prioritize the assist
                }
            }

            // 3. EVALUATE DRIBBLING
            // 3. EVALUATE DRIBBLING
            let dribbleScore = 10; // Base dÃ¼ÅŸÃ¼rÃ¼ldÃ¼ (30 -> 10)

            // Check space ahead
            const forwardAngle = isHome ? 0 : Math.PI;
            const checkDist = 10;
            const checkX = simP.x + Math.cos(forwardAngle) * checkDist;
            const checkY = simP.y + Math.sin(forwardAngle) * checkDist;
            const spaceObstacles = this.detectObstacles(p, checkX, checkY);

            // BoÅŸ alan bonusu azaltÄ±ldÄ±
            if (spaceObstacles.length === 0) dribbleScore += 30; // 50 -> 30
            else dribbleScore -= (spaceObstacles.length * 30); // Engel cezasÄ± arttÄ±

            // Yetenek etkisi
            if (p.attributes.dribbling > 60) {
                dribbleScore += ((p.attributes.dribbling - 60) * 1.5);
            }

            // === TAKTÄ°KSEL KÄ°LÄ°T ===
            // KÄ±sa Pas taktiÄŸinde driblingi Ã–LDÃœR
            if (tactic.passingStyle === 'Short') {
                dribbleScore -= 100; // -30 -> -100 (ArtÄ±k Ã§alÄ±m atmaya korkar)
            } else if (tactic.passingStyle === 'Mixed') {
                dribbleScore -= 20;  // Mixed'de de biraz pasÄ± tercih etsin
            }

            // IMPROVED DRIBBLING IMPACT
            if (p.attributes.dribbling > 60) {
                dribbleScore += ((p.attributes.dribbling - 60) * 1.8);
            }
            // Smart Dribbling: High dribbler in open space -> Drive!
            if (p.attributes.dribbling > 80 && spaceObstacles.length === 0) {
                dribbleScore += 40;
            }

            // === MATCHUP ANALÄ°ZÄ° (RAKÄ°BÄ° TARTMA) ===
            // pressure ve spaceObstacles yukarÄ±da hesaplandÄ± (detectObstacles ile)
            if (pressure > 0 && spaceObstacles.length > 0) {
                // En yakÄ±ndaki engeli (savunmacÄ±yÄ±) bul
                const nearestDefender = spaceObstacles[0];

                if (nearestDefender) {
                    // --- 1. HIZ FARKI (Speed Mismatch) ---
                    // EÄŸer ben rakibimden Ã§ok hÄ±zlÄ±ysam, topu dÃ¼rtÃ¼p geÃ§erim (Kick and Rush)
                    const mySpeed = p.attributes.speed || 50;
                    const defSpeed = nearestDefender.attributes.speed || 50;

                    if (mySpeed > defSpeed + 10) {
                        // Ciddi hÄ±z farkÄ± var, Ã§alÄ±m atmayÄ± Ã§ok iste!
                        dribbleScore += 40;
                        // EÄŸer boÅŸ alan da varsa bu skor uÃ§ar
                        if (spaceObstacles.length === 1) dribbleScore += 30; // Ã–nÃ¼mde sadece o varsa
                    }

                    // --- 2. YETENEK FARKI (Skill Mismatch) ---
                    // Benim driblingim vs Rakibin Top KapmasÄ± + GÃ¼cÃ¼
                    const mySkill = p.attributes.dribbling || 50;
                    // SavunmacÄ± skoru: Tackling %70 + Strength %30
                    const defSkill = (nearestDefender.attributes.tackling || 50) * 0.7 + (nearestDefender.attributes.strength || 50) * 0.3;

                    const mismatch = mySkill - defSkill;

                    if (mismatch > 15) {
                        // Rakip savunmada Ã§ok zayÄ±f, Ã¼zerine git!
                        dribbleScore += 35;
                    } else if (mismatch < -10) {
                        // Rakip duvar gibi (Ã¶rn: Van Dijk), Ã§alÄ±m deneme, pas ver!
                        dribbleScore -= 50;
                    }

                    // --- 3. SARI KART KORKUSU (BasitleÅŸtirilmiÅŸ) ---
                    // (Åžimdilik pendingEvents kullanÄ±lamadÄ±ÄŸÄ± iÃ§in burayÄ± es geÃ§iyoruz veya
                    // basitÃ§e agresifliÄŸine bakabiliriz ama ÅŸimdilik kapalÄ± kalsÄ±n)
                }
            } else if (pressure > 0) {
                // Eski mantÄ±k fallback (DetectObstacles menzili dÄ±ÅŸÄ±ndaki genel baskÄ± iÃ§in)
                dribbleScore -= (pressure * 15);
            }

            // POSITION-AWARE BEHAVIOR
            // HÃ¼cum bÃ¶lgesi: SahanÄ±n son 1/3'Ã¼ (0-35m veya 70-105m)
            const isInAttackingThird = isHome ? (simP.x > PITCH_LENGTH * 0.7) : (simP.x < PITCH_LENGTH * 0.3);
            const isInShootingZone = distToGoal < 30;

            if (isInAttackingThird || isInShootingZone) {
                dribbleScore += 35;
                if (isInShootingZone) {
                    shootScore += 30;
                }
                if (state.possessionCooldown > 8) {
                    passScore -= 40; // Don't just pass back immediately
                }
            }

            // FORWARD AGGRESSION
            if (this.playerRoles[p.id] === Position.FWD && distToGoal < 35) {
                dribbleScore += 25;
            }

            // SELFISHNESS / TEAMWORK
            if (p.playStyles.includes("Bencil")) {
                passScore -= 40;
                shootScore += 30;
                dribbleScore += 30;
                // Guarantee Goal threshold logic handled by scores
            }

            // === TACTIC EFFECTS ===
            // PAS STÄ°LÄ° ETKÄ°LERÄ° (v2 - Mixed standart, Direct agresif)
            if (tactic.passingStyle === 'Mixed') {
                // Mixed: Standart denge - eski Direct deÄŸerleri
                shootScore += 15;
                dribbleScore += 10;
                passScore -= 10;
            } else if (tactic.passingStyle === 'Direct') {
                // Direct: Agresif uzun top, daha az pas
                // REHBER UPDATE: Åžut +40, Dribble +50
                shootScore += 40;     // 30 -> 40
                dribbleScore += 50;   // 20 -> 50
                passScore -= 25;      // -25 (Sabit)
            } else if (tactic.passingStyle === 'Short') {
                // Short: Kisa pas, sabirli oyun (Tiki-Taka)
                // REHBER UPDATE: Pas +50, Åžut -30, Dribble -30
                shootScore -= 30;     // -20 -> -30
                dribbleScore -= 30;   // -10 -> -30
                passScore += 50;      // +30 -> +50
            } else if (tactic.passingStyle === 'LongBall') {
                // Long: Uzun Top
                if (isInAttackingThird) {
                    // Forvetler topu alinca ne yapsin?
                    shootScore += 25;     // VUR! (Hedef sensin)
                    dribbleScore += 10;   // Topu sakla (Target Man)
                } else {
                    // Defans/Orta Saha: Ileri sisir
                    shootScore += 5;
                    dribbleScore -= 20;   // Ezme
                    passScore += 40;      // Doldur
                }
            }

            // OYUN STÄ°LÄ° ETKÄ°LERÄ° (Playing Style)
            if (tactic.style === 'Counter') {
                // Counter: Kontra Atak - HÄ±zlÄ± Ã§Ä±k, dÃ¼ÅŸÃ¼nme vur!
                if (isInAttackingThird) {
                    // REHBER UPDATE: Åžut +80, Dribble +50
                    shootScore += 80; // 25 -> 80 (Affetme!)
                    dribbleScore += 50; // 15 -> 50
                }
                // Box iÃ§i ekstra ÅŸut isteÄŸi
                if (distToGoal < 16) shootScore += 60; // 20 -> 60
            } else if (tactic.style === 'Attacking') {
                // REHBER UPDATE: Åžut +40, Dribble +30
                shootScore += 40;
                dribbleScore += 30;
            } else if (tactic.style === 'Defensive') {
                // REHBER UPDATE: Åžut -40, Dribble -30, Pas +50
                shootScore -= 40;
                dribbleScore -= 30;
                passScore += 50;
            } else if (tactic.style === 'Possession') {
                // POSSESSION: KÄ±sa pas ve sabÄ±rlÄ± oyun
                passScore += 40;
                shootScore -= 20;
                dribbleScore += 15; // Topu tut, alan aÃ§
            }

            // === MENTALITY ETKÄ°SÄ° (YENÄ°) ===
            const mentality = tactic.mentality || 'Balanced';
            if (mentality === 'Attacking') {
                shootScore += 25;
                dribbleScore += 20;
                passScore -= 10;
            } else if (mentality === 'Defensive') {
                shootScore -= 20;
                dribbleScore -= 15;
                passScore += 25;
            }

            // === TEMPO ETKÄ°SÄ° (GENÄ°ÅžLETÄ°LMÄ°Åž) ===
            if (tactic.tempo === 'Fast') {
                // HÄ±zlÄ± tempo: Daha az dÃ¼ÅŸÃ¼n, daha Ã§ok risk al
                shootScore += 15;
                dribbleScore += 10;
            } else if (tactic.tempo === 'Slow') {
                // YavaÅŸ tempo: Daha sabÄ±rlÄ±, daha gÃ¼venli
                passScore += 20;
                shootScore -= 10;
            }

            // PRESIING INTENSITY EFFECTS
            if (tactic.pressingIntensity === 'HighPress' || tactic.pressingIntensity === 'Gegenpress') {
                if (shotOpenness > 0.6) shootScore += 10;
                else shootScore -= 10;
                dribbleScore += 10;
            } else if (tactic.pressingIntensity === 'StandOff') {
                passScore += 20;
                shootScore -= 30;
                dribbleScore -= 20;
            }

            // === PLAYER INSTRUCTIONS EFFECTS ===
            const instructions = tactic.instructions || [];

            // 1. Work Ball Into Box (Uzaktan ÅŸutu azalt)
            if (instructions.includes('WorkBallIntoBox')) {
                if (distToGoal > 25) {
                    shootScore -= 40; // Uzaktan ÅŸut deneme
                    passScore += 15;  // Pas yap
                }
            }

            // 2. Shoot On Sight (GÃ¶rdÃ¼ÄŸÃ¼n yerden vur)
            if (instructions.includes('ShootOnSight')) {
                if (distToGoal < 35 && shotOpenness > 0.4) {
                    shootScore += 25; // Mesafeye bakma vur
                }
            }

            // 3. FreeRoam (Serbest DolaÅŸ - Gizli Forvet)
            // MID oyuncularÄ± daha agresif oyna: dribble/ÅŸut artÄ±r, pas azalt
            // DEF ve FWD'ye etkisi minimal (zaten farklÄ± roller)
            if (instructions.includes('RoamFromPosition')) {
                if (this.playerRoles[p.id] === Position.MID) {
                    dribbleScore += 30;  // TaÅŸÄ±, ileri git!
                    shootScore += 20;    // FÄ±rsat gÃ¶rdÃ¼ÄŸÃ¼nde Ã§ek
                    passScore -= 15;     // Hep pas atma, kendin de gir
                } else if (this.playerRoles[p.id] === Position.FWD) {
                    dribbleScore += 10;  // Forvetler zaten agresif
                }
            }

            // Width Logic - Kanat bÃ¶lgesi (0-17m ve 51-68m)
            const isOnWing = simP.y < 17 || simP.y > PITCH_WIDTH - 17;
            if (tactic.width === 'Wide' && isOnWing) {
                dribbleScore += 20;
                if (isInAttackingThird) passScore += 15;
            } else if (tactic.width === 'Narrow' && !isOnWing) {
                passScore += 15;
                dribbleScore += 10;
            }

            // === ANTI-BACKPASS LOGIC (KORKAK OYUNU ENGELLEME) ===
            // EÄŸer Ã¶nÃ¼m boÅŸsa ve baskÄ± yoksa, geriye pas atmayÄ± cezalandÄ±r!
            const isBackPass = bestPass && (isHome ? (bestPass.targetX < simP.x) : (bestPass.targetX > simP.x));

            // Ã–nÃ¼mde engel yoksa
            if (spaceObstacles.length === 0) {
                // 1. Dribbling'i daha da teÅŸvik et
                dribbleScore += 60;

                // 2. EÄŸer en iyi pas seÃ§eneÄŸi geriyeyse, puanÄ±nÄ± dÃ¼ÅŸÃ¼r
                if (isBackPass && pressure === 0) {
                    // BaskÄ± yokken geri dÃ¶nmek korkaklÄ±ktÄ±r!
                    passScore -= 150;
                }
            }

            // REHBER SÄ°NC: Direct Passing - Geri pas yasak (-50)
            if (tactic.passingStyle === 'Direct' && isBackPass) {
                passScore -= 50;
            }

            // REHBER SÄ°NC: Defensive Style - Geri pas Ã¶dÃ¼l (+60)
            // Defansif takÄ±mlar topu geride tutup sÃ¼reyi eritmek ister
            if (tactic.style === 'Defensive' && isBackPass) {
                passScore += 60;
            }

            // "Dribbler" (Top SÃ¼ren) Ã¶zelliÄŸi olanlar boÅŸluÄŸu asla affetmez
            if (p.attributes.dribbling > 75 && spaceObstacles.length === 0) {
                dribbleScore += 40;
            }

            // --- EXECUTE DECISION ---
            let decision = 'DRIBBLE';

            // 1v1 DETECTION
            const is1v1 = distToGoal < 18 && shotOpenness > 0.4;

            // FORWARD SPECULATIVE SHOT
            const isForward = this.playerRoles[p.id] === Position.FWD;
            const isMidfielder = this.playerRoles[p.id] === Position.MID;
            const speculativeShot = isForward && distToGoal < 25 && shotOpenness > 0.3 && Math.random() < 0.25;

            // MIDFIELDER LONG SHOT
            const hasLongShot = p.playStyles?.includes("Uzaktan Åžut") || p.playStyles?.includes("Uzaktan Åžut+");
            const longShotAttr = (p.attributes as any).longShots || p.attributes.finishing || 50;
            const longShotChance = isMidfielder && distToGoal < 35 && distToGoal > 18 && shotOpenness > 0.35
                ? (0.08 + (longShotAttr - 50) / 500 + (hasLongShot ? 0.15 : 0))
                : 0;
            const midfielderLongShot = Math.random() < longShotChance;

            // === DECISION HIERARCHY (DÄ°NAMÄ°K EÅžÄ°K SÄ°STEMÄ° v4 - DAHA FAZLA ÅžUT) ===
            // FORVET BONUSU: Forvetler daha dÃ¼ÅŸÃ¼k eÅŸikle ÅŸut Ã§eker
            const isAttacker = this.playerRoles[p.id] === Position.FWD;
            const attackerBonus = isAttacker ? 0.6 : 1.0; // Forvetler %40 daha dÃ¼ÅŸÃ¼k eÅŸik (0.7 â†’ 0.6)

            let shootThreshold: number;
            if (distToGoal < 10) {
                // DEATH ZONE (<10m): Åžut at!
                shootThreshold = 100 * attackerBonus; // 80 -> 100, Forvet: 60
            } else if (distToGoal < 18) {
                // CEZA SAHASI (10-18m): Ä°yi fÄ±rsat varsa ÅŸut
                shootThreshold = 160 * attackerBonus; // 130 -> 160, Forvet: 96
            } else if (distToGoal < 25) {
                // CEZA SAHASI DIÅžI (18-25m): SeÃ§ici ol
                shootThreshold = 280 * attackerBonus; // 220 -> 280, Forvet: 168
            } else {
                // UZAK MESAFE (25m+): Ã‡ok iyi fÄ±rsat lazÄ±m
                shootThreshold = 400 * attackerBonus; // 320 -> 400, Forvet: 240
            }

            // 1v1 durumunda eÅŸiÄŸi dÃ¼ÅŸÃ¼r
            if (is1v1) shootThreshold = Math.min(shootThreshold, 80); // 60 -> 80

            // === KILLER INSTINCT (1v1 BÄ°TÄ°RÄ°CÄ°LÄ°K - TEK VURUÅž) v2 ===
            // Forvet, ceza sahasÄ±nda, 1v1 ve kaleyi gÃ¶rÃ¼yorsa normalde HÄ°Ã‡ DÃœÅžÃœNMEZ!
            // AMA: YanÄ±nda boÅŸ kaleye atacak arkadaÅŸÄ± varsa (2v0, 2v1) pas verebilir.
            if (is1v1 && isAttacker && distToGoal < 16) {
                // EÄŸer Ã§ok net bir pas opsiyonu varsa (Al da at)
                // bestPass > 200 genelde "boÅŸ kale" veya "Ã§ok net pozisyon" demek
                if (bestPass && bestPass.score > 200) {
                    // Pas opsiyonunu KORU, ÅŸutu da KORU. Karar hiyerarÅŸisi en iyisini seÃ§sin.
                    // Sadece bekleme sÃ¼resini sÄ±fÄ±rla ki hemen karar versin.
                    state.decisionTimer = 0;
                    // Åžut puanÄ±nÄ± biraz artÄ±r ama pasÄ± ezme
                    shootScore += 50;
                } else {
                    // Ä°yi pas yoksa -> BENCÄ°L OL VE VUR!
                    shootScore += 200;
                    dribbleScore = -100;
                    passScore = -100;
                    state.decisionTimer = 0;
                }
            }

            // Karar hiyerarÅŸisi
            if (shootScore > shootThreshold) decision = 'SHOOT';
            else if (speculativeShot && distToGoal < 20) decision = 'SHOOT'; // 22 â†’ 20
            else if (midfielderLongShot) decision = 'SHOOT';
            else if (bestPass && bestPass.type === 'THROUGH' && bestPass.score > 200) decision = 'PASS'; // 180 â†’ 200
            else if (passScore > dribbleScore + 70) decision = 'PASS'; // 40 â†’ 70 (daha az pas)
            else if (dribbleScore > 0) decision = 'DRIBBLE';
            else decision = 'PASS';

            if (!is1v1 && Math.random() < 0.1) decision = 'DRIBBLE';

            if (decision === 'SHOOT') {
                this.actionShoot(p, isHome);
                state.decisionTimer = -10; // Daha uzun bekleme
                state.possessionCooldown = 45; // NERFED: 15 -> 45 ticks cooldown

                // Reset sprint status
                simP.state = 'RUN';
                return;
            } else if (decision === 'PASS' && bestPass) {
                this.actionPass(p, bestPass.player, bestPass.type, bestPass.targetX, bestPass.targetY);
                return;
            }
        }

        // --- DRIBBLE EXECUTION ---
        let targetX = goalX;
        let targetY = PITCH_CENTER_Y;

        // CORNER / GOAL LINE AVOIDANCE
        const distToGoalX = Math.abs(simP.x - goalX);
        const isNearEndLine = isHome ? (simP.x > PITCH_LENGTH - 11) : (simP.x < 11);
        const isNearSideLine = simP.y < 4 || simP.y > PITCH_WIDTH - 4;

        if (isNearEndLine) {
            targetX = goalX;
            targetY = lerp(simP.y, PITCH_CENTER_Y, 0.9);
            this.sim.players[p.id].vx *= 0.7;
            this.sim.players[p.id].vy *= 0.7;
        } else if (isNearSideLine) {
            targetY = PITCH_CENTER_Y;
            targetX = goalX;
        } else {
            const nearestEnemy = this.findNearestEnemyInCone(p, isHome);
            if (nearestEnemy) {
                const enemyY = this.sim.players[nearestEnemy.id].y;
                let deviation = (simP.y > enemyY) ? 10 : -10;
                if (simP.y < 8 && deviation < 0) deviation = 14;
                if (simP.y > PITCH_WIDTH - 8 && deviation > 0) deviation = -14;
                targetY = simP.y + deviation;
                targetX = isHome ? simP.x + 10 : simP.x - 10;
            } else {
                targetX = goalX;
                if (Math.abs(simP.y - PITCH_CENTER_Y) > 20) targetY = lerp(simP.y, PITCH_CENTER_Y, 0.15);
                else targetY = simP.y;
            }
        }

        // DRIBBLE HIZ NERF v2: Top sÃ¼rerken daha yavaÅŸ
        this.applySteeringBehavior(p, targetX, targetY, MAX_PLAYER_SPEED * 0.85);
    }

    // === SMART RECOVERY LOGIC (ENGINE 4 PORT) ===
    private applyDefensiveRecoveryLogic(p: Player, state: PlayerState, offsideLineX: number, isHome: boolean): boolean {
        // 1. Topun geleceÄŸi noktayÄ± tahmin et (Intercept Vector)
        const simP = this.sim.players[p.id];
        if (!simP) return false;

        const b = this.sim.ball;
        const ballSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);

        // Sadece top hÄ±zlÄ±ysa ve rakip hÃ¼cum ediyorsa
        const isAttacking = isHome ? (b.vx < -0.5) : (b.vx > 0.5);

        if (ballSpeed > 1.5 && isAttacking) {
            // Topun 1.5 saniye sonraki konumu
            const interceptX = b.x + b.vx * 45; // 30 tick = 1 sec (approx 1.5s -> 45)
            const interceptY = b.y + b.vy * 45;

            // EÄŸer top benim savunma bÃ¶lgeme geliyorsa
            const isDangerous = isHome ? (interceptX < 50) : (interceptX > 55);

            if (isDangerous) {
                // Topa deÄŸil, topun GÄ°DECEÄžÄ° yere koÅŸ (Smart Cut)
                const distToIntercept = dist(simP.x, simP.y, interceptX, interceptY);
                const distToBall = dist(simP.x, simP.y, b.x, b.y);

                // EÄŸer topa yetiÅŸme ÅŸansÄ±m varsa (Benim mesafem < Topun mesafesi + avantaj)
                if (distToIntercept < 40) {
                    state.targetX = interceptX;
                    state.targetY = interceptY;
                    // SPRINT!
                    this.applySteeringBehavior(p, interceptX, interceptY, MAX_PLAYER_SPEED * 1.05);
                    return true; // Logic handled
                }
            }
        }
        return false;
    }

    private findBestPassOption(p: Player, isHome: boolean, offsideLineX: number, goalX: number): { player: Player, score: number, type: 'GROUND' | 'THROUGH' | 'AERIAL', targetX: number, targetY: number } | null {
        let bestTarget: Player | null = null;
        let maxScore = -9999;
        let bestType: 'GROUND' | 'THROUGH' | 'AERIAL' = 'GROUND';
        let bestTx = 0;
        let bestTy = 0;

        const teammates = isHome ? this.homePlayers : this.awayPlayers;
        const simP = this.sim.players[p.id];
        const distToMyGoal = dist(simP.x, simP.y, goalX, PITCH_CENTER_Y);
        const tactic = isHome ? this.homeTeam.tactic : this.awayTeam.tactic;

        // Don't pass from very close to own goal line if possible (Clearance preferred in outer logic)
        if (distToMyGoal < 7 && this.playerRoles[p.id] !== Position.GK) return null;

        teammates.forEach(tm => {
            if (tm.id === p.id) return;
            if (!this.sim.players[tm.id]) return;
            const simTm = this.sim.players[tm.id];

            const d = dist(simP.x, simP.y, simTm.x, simTm.y);
            const visionStat = p.attributes.vision || 50;
            const visionBonus = p.playStyles?.includes("Uzun Topla Pas") ? 25 : 0;

            if (d > PASS_RANGE_VISION + visionBonus) return;

            // Base Score: Closer to enemy goal is better
            const distToGoal = dist(simTm.x, simTm.y, goalX, PITCH_CENTER_Y);
            let score = (126 - distToGoal);  // 120 â†’ 126 (Ã¶lÃ§eklendi)

            // === PAS DAÄžITIMI: Kanat forvetleri ve Ã§eÅŸitlilik ===
            // Merkez forvet her zaman kaleye en yakÄ±n â†’ hep en yÃ¼ksek skor alÄ±yor
            // Bu dÃ¼zeltme kanat forvetlerini de cazip hale getiriyor
            const tmRole = this.playerRoles[tm.id];
            if (tmRole === Position.FWD) {
                // Kanat forvetlerine aÃ§Ä±lma bonusu (merkez dÄ±ÅŸÄ±ndaki forvetler)
                const isOnWing = simTm.y < 25 || simTm.y > PITCH_WIDTH - 25;
                if (isOnWing) {
                    score += 15; // Kanat aÃ§Ä±k â†’ iyi seÃ§enek!
                }
                // Ã‡eÅŸitlilik: Hep aynÄ± adama pas atmak yerine rastlantÄ±
                score += (Math.random() * 12) - 6; // Â±6 puan rastgelelik
            }

            // === OYUNU GENÄ°ÅžLETME (SPREAD PLAY) ===
            // Daha akÄ±llÄ± kanat kullanÄ±mÄ± (Ã–zellikle 4-3-3 iÃ§in)
            const amICentral = Math.abs(simP.y - PITCH_CENTER_Y) < 15;
            const isTeammateWide = Math.abs(simTm.y - PITCH_CENTER_Y) > 20;

            if (amICentral && isTeammateWide) {
                score += 40; // Kanata pasÄ± teÅŸvik et
            }

            // Forward Progress: Pozitifse ileri, negatifse geri pas (Moved Up for LongBall Logic)
            const forwardProgress = isHome ? (simTm.x - simP.x) : (simP.x - simTm.x);

            // === SÄ°NYAL OKUMA SÄ°STEMÄ° (G MOTORU) ===
            const tmState = this.playerStates[tm.id]; // Variable declaration fixed
            if (tmState?.incomingSignal?.type === 'CALL') {
                score += 50; // BaÄŸÄ±ran oyuncuya pas atma isteÄŸi ciddi artar
            }
            if (tmState?.outgoingSignal?.type === 'POINT') {
                // EÄŸer oyuncu ileriye koÅŸuyorsa ve ileriye doÄŸru pas veriyorsak bonus
                if (forwardProgress > 10) score += 40;
            }

            // === G MOTORU: SAVUNMA YOÄžUNLUÄžU KONTROLÃœ (Interception Risk) ===
            let proximityRisk = 0;
            const opponents = isHome ? this.awayPlayers : this.homePlayers;

            opponents.forEach(e => {
                if (!this.sim.players[e.id]) return;
                const simE = this.sim.players[e.id];

                // Pas yolu Ã¼zerinde mi?
                const distToLine = this.distToSegment(simE.x, simE.y, simP.x, simP.y, simTm.x, simTm.y);

                if (distToLine < 2.5) { // EÄŸer rakip pas yoluna 2.5m yakÄ±nsa
                    proximityRisk += 150; // PasÄ±n geÃ§me ihtimalini bitir
                }
            });
            score -= proximityRisk;

            // === GLOBAL OFSAYT KONTROLÃœ (TÃœM PAS TÃœRLERÄ° Ä°Ã‡Ä°N) ===
            // GerÃ§ek futbolda ofsayt, PASIN ATILDIÄžI ANDAKÄ° alÄ±cÄ±nÄ±n pozisyonuna bakÄ±lÄ±r.
            // EÄŸer alÄ±cÄ± ofsayt Ã§izgisinin Ã¶tesindeyse VE pas ileriye gidiyorsa â†’ OFSAYT!
            // Geri paslar ofsayt deÄŸildir (forwardProgress < 0).
            // PasÃ¶rÃ¼n kendi yarÄ± sahasÄ±ndan atÄ±lan paslarda ofsayt yoktur.
            if (forwardProgress > 0) {
                const isReceiverOffside = isHome
                    ? simTm.x > offsideLineX + 0.5  // 0.5m tolerans (VAR hassasiyeti)
                    : simTm.x < offsideLineX - 0.5;

                // PasÃ¶r kendi yarÄ± sahasÄ±nda mÄ±? (Ofsayt sadece rakip yarÄ± sahada geÃ§erli)
                const isPasserInOwnHalf = isHome
                    ? simP.x < PITCH_CENTER_X
                    : simP.x > PITCH_CENTER_X;

                if (isReceiverOffside && !isPasserInOwnHalf) {
                    return; // Bu alÄ±cÄ± ofsayt - pas seÃ§eneÄŸi tamamen iptal!
                }
            }


            // === LONG BALL LOGIC ===
            if (tactic && tactic.passingStyle === 'LongBall') {
                if (d > 35) {
                    // SADECE Ä°LERÄ° OYNAMALI! (User Request: Geriye uzun top yasak)
                    if (forwardProgress > 5) {
                        score += 50; // Ä°leri uzun pasa bÃ¼yÃ¼k Ã¶dÃ¼l
                    } else if (forwardProgress < -5) {
                        score -= 500; // Geriye uzun top KESÄ°NLÄ°KLE yasak
                    }
                }
                if (d < 20) score -= 30; // Kisa pas sevmez
            }

            // === KRÄ°TÄ°K FIX: ALICININ YANINDA RAKÄ°P VARSA PAS RÄ°SKLÄ°! ===
            // Bu kontrol olmadan, pas yolu aÃ§Ä±k olsa bile alÄ±cÄ±nÄ±n yanÄ±nda rakip varsa top kaybediliyordu
            const enemies = isHome ? this.awayPlayers : this.homePlayers;
            let receiverPressure = 0;
            let closestEnemyToReceiver = 999;

            enemies.forEach(e => {
                if (!this.sim.players[e.id]) return;
                const simE = this.sim.players[e.id];
                const enemyDistToReceiver = dist(simE.x, simE.y, simTm.x, simTm.y);

                if (enemyDistToReceiver < closestEnemyToReceiver) {
                    closestEnemyToReceiver = enemyDistToReceiver;
                }

                // 3m iÃ§inde rakip = ciddi baskÄ±
                if (enemyDistToReceiver < 3) receiverPressure += 100;
                // 5m iÃ§inde rakip = orta baskÄ±
                else if (enemyDistToReceiver < 5) receiverPressure += 50;
                // 7m iÃ§inde rakip = hafif baskÄ±
                else if (enemyDistToReceiver < 7) receiverPressure += 20;
            });

            // === CRITICAL FIX: PAS YOLU (LANE) KONTROLÃœ ===
            // Sadece alÄ±cÄ±nÄ±n yanÄ±na bakmak yetmez, pasÄ±n GÄ°DECEÄžÄ° YOL temiz mi?
            // Ã–zellikle geriye paslarda araya giren rakipler Ã§ok tehlikeli
            let interceptionRisk = 0;
            const px = simP.x, py = simP.y;
            const tx = simTm.x, ty = simTm.y;
            const passDist = d;

            enemies.forEach(e => {
                if (!this.sim.players[e.id]) return;
                const ex = this.sim.players[e.id].x;
                const ey = this.sim.players[e.id].y;

                // NoktanÄ±n doÄŸruya uzaklÄ±ÄŸÄ± formÃ¼lÃ¼ (Line Segment Distance)
                // P(x,y) noktasÄ±nÄ±n AB doÄŸru parÃ§asÄ±na en yakÄ±n uzaklÄ±ÄŸÄ±
                const l2 = passDist * passDist;
                if (l2 === 0) return;

                // t = projection factor
                let t = ((ex - px) * (tx - px) + (ey - py) * (ty - py)) / l2;
                t = Math.max(0, Math.min(1, t)); // Segment dÄ±ÅŸÄ±na taÅŸmayÄ± engelle

                const projectionX = px + t * (tx - px);
                const projectionY = py + t * (ty - py);

                const distToLine = dist(ex, ey, projectionX, projectionY);

                // EÄŸer rakip pas yoluna Ã§ok yakÄ±nsa (1.5m) ve pasÃ¶r/alÄ±cÄ±ya Ã§ok yakÄ±n deÄŸilse
                // (PasÃ¶rÃ¼n dibindeki adam interception deÄŸil baskÄ±dÄ±r, onu ayrÄ± sayÄ±yoruz)
                const distToPasser = dist(ex, ey, px, py);
                const distToReceiver = dist(ex, ey, tx, ty);

                if (distToLine < 1.5 && distToPasser > 2 && distToReceiver > 2) {
                    // BLOKE EDÄ°LDÄ°! Pas yolu kapalÄ±
                    interceptionRisk += 500;
                } else if (distToLine < 3.0 && distToPasser > 2 && distToReceiver > 2) {
                    // Riskli alan
                    interceptionRisk += 40;
                }
            });

            // Geriye paslarda interception riski AFFEDÄ°LMEZ
            if (interceptionRisk > 0 && forwardProgress < 0) {
                score -= 500; // Asla geriye riskli pas atma
            } else if (interceptionRisk >= 500) {
                // Ä°leri paslarda AERIAL (Havadan) veya THROUGH (Ara Pas) ile aÅŸÄ±labilir mi?
                // EÄŸer "Uzun Topla Pas" yeteneÄŸi varsa havadan denesin
                if (p.playStyles?.includes("Uzun Topla Pas")) {
                    score -= 50; // Havadan denerim, Ã§ok dÃ¼ÅŸÃ¼rme
                    bestType = 'AERIAL';
                } else {
                    score -= 300; // Yerden pas kapalÄ±
                }
            } else if (interceptionRisk > 0) {
                score -= interceptionRisk;
            }

            // AlÄ±cÄ±nÄ±n Ã§ok yakÄ±nÄ±nda rakip varsa, pas riskli
            if (receiverPressure >= 100) {
                score -= 120; // 300â†’120: Ã‡ok riskli ama imkansÄ±z deÄŸil
            } else if (receiverPressure >= 50) {
                score -= 50; // 100â†’50: Orta riskli pas
            } else if (receiverPressure >= 20) {
                score -= 15; // 30â†’15: Hafif riskli pas
            }

            // === ALICI HAZIRLIK KONTROLÃœ ===
            // TakÄ±m arkadaÅŸÄ±nÄ±n yÃ¼zÃ¼ pas yÃ¶nÃ¼ne dÃ¶nÃ¼k mÃ¼?
            const angleToReceiver = Math.atan2(simTm.y - simP.y, simTm.x - simP.x);
            const receiverFacing = simTm.facing || 0;
            let facingDiff = Math.abs(angleToReceiver - receiverFacing);
            if (facingDiff > Math.PI) facingDiff = 2 * Math.PI - facingDiff;

            // ArkasÄ± tamamen dÃ¶nÃ¼kse pas skoru dÃ¼ÅŸer
            const isBackTurned = facingDiff > Math.PI * 0.7;
            if (isBackTurned) {
                score -= 30; // ArkasÄ± dÃ¶nÃ¼k - pas riskli
                // Ama "Ä°lk DokunuÅŸ" yeteneÄŸi varsa ceza azalÄ±r
                if (tm.playStyles?.includes("Ä°lk DokunuÅŸ") || tm.playStyles?.includes("Ä°lk DokunuÅŸ+")) {
                    score += 15; // Ä°lk dokunuÅŸ yeteneÄŸi telafi eder
                }
            }

            // Sprint halindeyken top almak zor
            const tmSpeed = Math.sqrt((simTm.vx || 0) ** 2 + (simTm.vy || 0) ** 2);
            if (tmSpeed > MAX_PLAYER_SPEED * 0.8) {
                score -= 15; // Tam sprint - kontrol zorlaÅŸÄ±r
                // "Ä°lk DokunuÅŸ" yeteneÄŸi telafi
                if (tm.playStyles?.includes("Ä°lk DokunuÅŸ") || tm.playStyles?.includes("Ä°lk DokunuÅŸ+")) {
                    score += 10;
                }
            }

            // Forward Progress Bonus - AI CONSENSUS: Dikine pas Ã¶dÃ¼lÃ¼ artÄ±rÄ±ldÄ±
            // (forwardProgress calculated above)

            // Dinamik forward bias: Gerideyken daha agresif
            let forwardBias = 4.5; // 3.0â†’4.5
            const scoreDiff = isHome ? (this.match.homeScore - this.match.awayScore) : (this.match.awayScore - this.match.homeScore);
            if (scoreDiff < 0) forwardBias += 1.5; // Gerideyken daha dikine
            if (tactic.style === 'Possession' && distToGoal < 40) forwardBias += 1.5; // Son 1/3'te dikine

            if (forwardProgress > 0) score += (forwardProgress * forwardBias);

            // === SÄ°NYAL OKUMA SÄ°STEMÄ° (G MOTORU ENTEGRASYONU) ===

            // EÄŸer takÄ±m arkadaÅŸÄ±m "Bana at!" (CALL) diyorsa skoru artÄ±r
            if (tmState?.incomingSignal?.type === 'CALL') {
                score += 50; // Ã–ncelik ver
            }

            // EÄŸer "Ã–nÃ¼me at" (POINT) diyorsa ve pas ileri gidiyorsa skoru artÄ±r
            if (tmState?.outgoingSignal?.type === 'POINT') {
                if (forwardProgress > 10) score += 40; // KoÅŸu yoluna at (G Motoru verisi: +40)
            }

            // ANTI-COWARD LOGIC (REFINED)
            // Geriye pas atarken korkaklÄ±k cezasÄ± - AMA taktiksel geri paslara izin ver
            // EÄŸer "Possession" oynuyorsak, geriye pas normaldir
            if (forwardProgress < 0) { // Backward pass
                // EÄŸer baskÄ± altÄ±ndaysak, geriye pas "gÃ¼venli" seÃ§enektir - CEZA YOK
                const pressureForPass = this.detectObstacles(p, simP.x, simP.y).length;
                if (pressureForPass > 0) {
                    score += 5; // Panic relief bonus
                } else {
                    // BaskÄ± yokken geriye oynamak
                    if (tactic.style === 'Possession') {
                        score *= 0.95; // Hafif ceza (hala ileri gitmeyi tercih etmeli ama yasak deÄŸil)
                    } else if (tactic.style === 'Counter') {
                        score *= 0.70; // Counter'da geriye oynamak kÃ¶tÃ¼dÃ¼r
                    } else {
                        score *= 0.85; // Normal ceza
                    }
                }
            } else {
                // Forward pass bonus
                if (tactic.style === 'Counter') score *= 1.2;
                if (tactic.style === 'Attacking') score *= 1.1;
            }

            // VISION IMPACT ON PASS DECISION - High vision sees better options!
            // Vision 50 = +0, Vision 70 = +20, Vision 85 = +35, Vision 100 = +50
            if (visionStat > 50) {
                score += ((visionStat - 50) * 1.0); // DOUBLED: Vision bonus to all passes
                // Extra bonus for long forward passes (vision helps see them)
                if (forwardProgress > 20 && d > 25) {
                    score += ((visionStat - 50) * 0.6); // DOUBLED: Extra for long through balls
                }
            }

            // === YETENEK: YARATICI ===
            // "YaratÄ±cÄ±" yeteneÄŸi olan pasÃ¶rler riskli paslarÄ± daha iyi gÃ¶rÃ¼r
            if (p.playStyles?.includes("YaratÄ±cÄ±") || p.playStyles?.includes("YaratÄ±cÄ±+")) {
                if (forwardProgress > 15) score += 20;
            }



            // --- CROSSING LOGIC (KANAT ORTASI - ENHANCED) ---
            // Deep: Son 25m (X ekseni), Wide: Kanat (Y<17 veya Y>51)
            const isDeep = isHome ? simP.x > PITCH_LENGTH * 0.76 : simP.x < PITCH_LENGTH * 0.24;
            const isWide = simP.y < 17 || simP.y > PITCH_WIDTH - 17;

            // === FORCE AERIAL CROSS FROM WINGS ===
            // Kanattan ceza sahasÄ±na pas = MUTLAKA HAVADAN olmalÄ± (gerÃ§ek futbol!)
            let forcedAerialCross = false;
            if (isDeep && isWide) {
                // If I am in Crossing Zone, prioritize players in the box!
                const isTargetCentral = Math.abs(simTm.y - PITCH_CENTER_Y) < 18; // GeniÅŸ merkez bÃ¶lge (14 â†’ 18)
                const isTargetDeep = isHome ? simTm.x > 80 : simTm.x < 25; // 84/21 â†’ 80/25

                if (isTargetCentral && isTargetDeep) {
                    score += 500; // MASSIVE BONUS FOR CROSS TARGET
                    forcedAerialCross = true; // AERIAL ZORUNLU!
                }
            }

            // --- 1. ANALYZE PASS TYPES ---

            // A. GROUND PASS (AYAÄžA)
            const groundTime = d / 2.5;
            const groundTx = simTm.x + (simTm.vx || 0) * groundTime;
            const groundTy = simTm.y + (simTm.vy || 0) * groundTime;

            // BOUNDS CHECK 1: Ground Pass (Pass to empty space fix)
            // Motor koordinatlarÄ±: X=0-105, Y=0-68
            if (groundTy < 2 || groundTy > PITCH_WIDTH - 2 || groundTx < 1 || groundTx > PITCH_LENGTH - 1) return;

            // B. THROUGH BALL (KOÅžU YOLUNA)
            const throughTime = d / 2.0;
            const runDirX = simTm.vx || 0;
            const runDirY = simTm.vy || 0;
            const runSpeed = Math.sqrt(runDirX * runDirX + runDirY * runDirY);

            const isMakingRun = runSpeed > 0.5;
            let throughTx = simTm.x + runDirX * 15;
            let throughTy = simTm.y + runDirY * 15;

            // BOUNDS CHECK 2: Through Ball (Strict)
            // Motor koordinatlarÄ±: Y=0-68
            if (throughTy < 3 || throughTy > PITCH_WIDTH - 3) {
                // If aiming out of bounds, penalize heavily
                score -= 200;
            }
            if (throughTx < 0 || throughTx > PITCH_LENGTH) throughTx = clamp(throughTx, 1, PITCH_LENGTH - 1);

            // C. AERIAL PASS (HAVADAN) used as fallback or Cross

            // --- 2. CALCULATE INTERCEPTION RISK FOR GROUND ---
            // enemies zaten yukarÄ±da tanÄ±mlandÄ± (alÄ±cÄ± baskÄ±sÄ± kontrolÃ¼nde)
            let groundRisk = 0;

            enemies.forEach(e => {
                if (!this.sim.players[e.id]) return;
                const simE = this.sim.players[e.id];

                const dx = groundTx - simP.x;
                const dy = groundTy - simP.y;
                const l2 = dx * dx + dy * dy;
                if (l2 == 0) return;

                let t = ((simE.x - simP.x) * dx + (simE.y - simP.y) * dy) / l2;
                t = Math.max(0, Math.min(1, t));
                const px = simP.x + t * dx; const py = simP.y + t * dy;

                // PAS KESÄ°M RÄ°SKÄ°: Daha gerÃ§ekÃ§i mesafe
                // ESKÄ°: 2.8m (pressing 3.5m) - Ã‡OK YÃœKSEK, paslar kesiliyordu
                // YENÄ°: 2.0m (pressing 2.8m) - Daha dengeli
                let riskDist = 2.0;
                if (this.playerStates[e.id]?.isPressing) riskDist = 2.8;

                if (dist(simE.x, simE.y, px, py) < riskDist) {
                    groundRisk += 100; // Blocked!
                }
            });

            // --- 3. EVALUATE OPTIONS ---

            // === PAS STÄ°LÄ°: MESAFE ETKÄ°SÄ° (v5 - OVERHAUL) ===
            // Ana kontrol mekanizmasÄ±: MESAFE!
            // Forward progress bonus 50m = +225 puan olduÄŸu iÃ§in
            // cezalar bunu dengeleyecek kadar gÃ¼Ã§lÃ¼ olmalÄ±
            if (tactic.passingStyle === 'Short') {
                // Short: 5-25m ideal, >25m sert ceza
                // TIKI-TAKA: Kisa pas odul, uzun pas agir ceza
                if (d < 12) score += 50;          // Cok kisa pas buyuk bonus
                else if (d < 20) score += 25;     // Kisa-orta pas bonus
                else if (d < 25) score += 5;      // Kabul edilebilir
                else {
                    // 25m+ agir ceza
                    score -= Math.min(250, (d - 25) * 10);
                    // Ileri sisirmeyi engelle
                    if (forwardProgress > 15) {
                        score -= (forwardProgress - 15) * 6;
                    }
                }
            } else if (tactic.passingStyle === 'LongBall') {
                // LongBall: 30-55m ideal, kisa paslari cezalandir
                if (d < 12) score -= Math.min(80, (12 - d) * 7);  // Cok kisa = buyuk ceza
                else if (d < 20) score -= Math.min(40, (20 - d) * 5); // Kisa pas ceza
                else if (d > 30) score += Math.min(80, (d - 30) * 4); // Uzun pas guclu bonus
            } else if (tactic.passingStyle === 'Direct') {
                // Direct: 15-40m ideal, ileri pas odul, geri/kisa ceza
                if (d < 10) score -= 30;          // Cok kisa pas buyuk ceza
                else if (d < 15) score -= 10;     // Kisa pas hafif ceza
                else if (d > 20 && forwardProgress > 10) score += Math.min(50, (d - 20) * 2.5); // Ileri uzun pas bonus
                else if (d > 40) score -= Math.min(30, (d - 40) * 2); // Asiri uzun ceza
            } else if (tactic.passingStyle === 'Mixed') {
                // Mixed: 10-35m ideal, uc noktalari hafif cezalandir
                if (d < 8) score -= 15;           // Cok kisa hafif ceza
                else if (d > 35) score -= Math.min(50, (d - 35) * 3); // Uzun pas ceza
                else if (d >= 12 && d <= 30) score += 10; // Ideal aralik bonus
            }

            let currentBestScore = -9999;
            let currentType: 'GROUND' | 'THROUGH' | 'AERIAL' = 'GROUND';
            let finalTx = groundTx;
            let finalTy = groundTy;

            // OPTION 1: GROUND PASS
            let groundScore = score;

            // === PAS STÄ°LÄ°: TÄ°P BONUSU KALDIRILDI (v5) ===
            // Mesafe zaten doÄŸru tipi zorluyor:
            // - KÄ±sa pas â†’ doÄŸal olarak GROUND (risk dÃ¼ÅŸÃ¼k)
            // - Uzun pas â†’ doÄŸal olarak AERIAL (Ã¼zerinden geÃ§mesi gerek)
            // ArtÄ±k ekstra tip bonusu YOK, sadece mesafe kontrol ediyor

            // === KRÄ°TÄ°K FIX: PAS YOLUNDA RAKÄ°P VARSA, BU PASI YAPMA! ===
            const isGroundBlocked = groundRisk > 0;

            if (isGroundBlocked) {
                groundScore = -9999; // Bu pas seÃ§eneÄŸi iptal!
            }

            // === CHIP PASS (LÃ–B PAS) ===
            // Arada rakip var ve mesafe uygunsa, havadan aÅŸÄ±rt
            let useChipPass = false;
            if (isGroundBlocked && d < 25 && d > 5) {
                // KÄ±sa/orta mesafe, arada rakip var - chip pass mantÄ±klÄ±
                useChipPass = true;
            }

            if (groundScore > currentBestScore && !isGroundBlocked) {
                currentBestScore = groundScore;
                currentType = 'GROUND';
                finalTx = groundTx;
                finalTy = groundTy;
            }

            // OPTION 2: THROUGH BALL
            if (isMakingRun && forwardProgress > 5) {
                const boundsCheck = throughTx > 1 && throughTx < PITCH_LENGTH - 1 && throughTy > 2 && throughTy < PITCH_WIDTH - 2;
                const offsideCheck = isHome ? (throughTx < offsideLineX) : (throughTx > offsideLineX);

                if (boundsCheck && offsideCheck) {
                    let throughRisk = 0;
                    enemies.forEach(e => {
                        const simE = this.sim.players[e.id];
                        if (!simE) return; // Fix crash
                        const dx = throughTx - simP.x; const dy = throughTy - simP.y;
                        const l2 = dx * dx + dy * dy;
                        if (l2 === 0) return;
                        const t = ((simE.x - simP.x) * dx + (simE.y - simP.y) * dy) / l2;
                        const px = simP.x + t * dx; const py = simP.y + t * dy;
                        // Through ball iÃ§in biraz daha toleranslÄ± (2.0m) - koÅŸan oyuncuya pas
                        if (dist(simE.x, simE.y, px, py) < 2.0 && t > 0.15 && t < 0.85) throughRisk += 100;
                    });

                    // === KRÄ°TÄ°K FIX: THROUGH BALL DA BLOKLANIRSA Ä°PTAL ===
                    const isThroughBlocked = throughRisk > 0;

                    let throughScore = score + 40;
                    if (isThroughBlocked) {
                        throughScore = -9999; // Bu pas seÃ§eneÄŸi iptal!
                    } else {
                        if (p.attributes.vision > 70) throughScore += 20;
                        // POSSESSION STYLE: Killer Pass Bonus!
                        if (tactic.style === 'Possession' && dist(throughTx, throughTy, goalX, PITCH_CENTER_Y) < 32) {
                            throughScore += 30;
                        }
                    }

                    if (throughScore > currentBestScore && !isThroughBlocked) {
                        currentBestScore = throughScore;
                        currentType = 'THROUGH';
                        finalTx = throughTx;
                        finalTy = throughTy;
                    }
                }
            }

            // OPTION 3: AERIAL / CROSS / CHIP PASS
            // === ENHANCED: Kanattan orta her zaman AERIAL olmalÄ± ===
            // VEYA: KÄ±sa mesafe chip pass (lÃ¶b)
            if (forcedAerialCross || (isDeep && isWide) || (groundRisk > 50 && d > 8 && d < 45) || useChipPass) {
                let aerialScore = score - 25; // AERIAL doÄŸal ceza (15 â†’ 25)

                if (forcedAerialCross) aerialScore += 100; // 300 â†’ 100 (hala gÃ¼Ã§lÃ¼ ama dominant deÄŸil)
                else if (isDeep && isWide) aerialScore += 70; // 100 â†’ 70

                // === PAS STÄ°LÄ° ETKÄ°SÄ° (v3 - Ã‡OK Ã–NEMLÄ°) ===
                // Her pas stili AERIAL tercihini farklÄ± ayarlar
                // Short: KÄ±sa pas oynamak istiyor â†’ AERIAL'Ä± cezalandÄ±r!
                // Mixed: NÃ¶tr
                // Direct: Direkt futbol â†’ AERIAL'Ä± biraz sev
                // LongBall: Uzun top â†’ AERIAL'Ä± Ã§ok sev
                // v5: Mesafe zaten uzun AERIAL'Ä± cezalandÄ±rÄ±yor, sadece hafif tip etkisi
                if (tactic.passingStyle === 'Short') aerialScore -= 40; // -80 â†’ -40 (mesafe zaten aÄŸÄ±r ceza)
                else if (tactic.passingStyle === 'Mixed') aerialScore += 5;
                else if (tactic.passingStyle === 'Direct') aerialScore += 20;
                else if (tactic.passingStyle === 'LongBall') aerialScore += 35;

                // === CHIP PASS BONUS (dÃ¼zeltildi) ===
                if (useChipPass) {
                    aerialScore += 60; // 120 â†’ 60 (hala tercih ediliyor ama dominant deÄŸil)
                    if (p.attributes.passing > 70) aerialScore += 15; // 30 â†’ 15
                    if (p.attributes.vision > 75) aerialScore += 10; // 20 â†’ 10
                }

                // === SMART CHIP PASS (AKILLI AÅžIRTMA - v2) ===
                // EÄŸer yer pasÄ± defans tarafÄ±ndan kesiliyorsa (isGroundBlocked),
                // Ve oyuncu yetenekliyse (Vizyon > 75), ÅŸÄ±k bir aÅŸÄ±rtma yap!
                if (d > 8 && d < 25 && isGroundBlocked) {
                    // BloklanmÄ±ÅŸ yer pasÄ± durumunda Chip Pass'i ciddi ÅŸekilde Ã¶dÃ¼llendir
                    if (p.attributes.vision > 75 || p.playStyles?.includes("Maestro")) {
                        aerialScore += 150; // Kesin tercih sebebi yap!
                        // "Maestro" trait'i varsa neredeyse her zaman aÅŸÄ±rtÄ±r
                    } else if (p.attributes.passing > 70) {
                        aerialScore += 80; // Ä°yi pasÃ¶rler de aÅŸÄ±rtabilir
                    } else {
                        aerialScore += 30; // Standart aÅŸÄ±rtma denemesi
                    }
                }

                // === OFSAYT KONTROLÃœ (AERIAL Ä°Ã‡Ä°N EK GÃœVENLÄ°K) ===
                // Global ofsayt kontrolÃ¼ zaten yukarÄ±da yapÄ±lÄ±yor.
                // Bu ek kontrol, havadan paslarda topun dÃ¼ÅŸeceÄŸi yerin de
                // ofsayt Ã§izgisinin gerisinde olmasÄ±nÄ± saÄŸlar (ekstra gÃ¼venlik).
                const targetSimP = this.sim.players[tm.id];
                if (targetSimP) {
                    const isTargetOffside = isHome
                        ? targetSimP.x > offsideLineX + 0.5
                        : targetSimP.x < offsideLineX - 0.5;
                    if (isTargetOffside && forwardProgress > 0) {
                        aerialScore = -9999; // OFSAYT! Bu pas seÃ§eneÄŸini iptal
                    }
                }

                if (aerialScore > currentBestScore) {
                    currentBestScore = aerialScore;
                    currentType = 'AERIAL';
                    finalTx = groundTx;
                    finalTy = groundTy;
                }
            }

            // Not: Eski "FORCED CROSS OVERRIDE" kaldÄ±rÄ±ldÄ±
            // ArtÄ±k forcedAerialCross bonus veriyor ama zorlamÄ±yor

            // --- FINAL ADJUSTMENTS ---
            if (currentBestScore > maxScore) {
                maxScore = currentBestScore;
                bestTarget = tm;
                bestType = currentType;
                bestTx = finalTx;
                bestTy = finalTy;
            }
        });

        if (maxScore < 20) return null;

        // Debug log kaldirildi - gercek pas aninda loglanacak (updateBallCarrierAI'da)

        return {
            player: bestTarget!,
            score: maxScore,
            type: bestType,
            targetX: bestTx,
            targetY: bestTy
        };
    }

    private detectObstacles(p: Player, x: number, y: number): Player[] {
        const obstacles: Player[] = [];
        const searchDist = 6;
        this.allPlayers
            .filter(other => other.lineup === 'STARTING')
            .forEach(other => {
                if (other.id === p.id || other.teamId === p.teamId) return;
                const otherPos = this.sim.players[other.id];
                if (!otherPos) return;
                const d = dist(x, y, otherPos.x, otherPos.y);
                if (d < searchDist) obstacles.push(other);
            });
        return obstacles;
    }

    private findNearestEnemyInCone(p: Player, isHome: boolean): Player | null {
        let nearest: Player | null = null;
        let minD = 10;
        const simP = this.sim.players[p.id];
        const forwardAngle = isHome ? 0 : Math.PI;
        this.allPlayers
            .filter(other => other.lineup === 'STARTING')
            .forEach(other => {
                // === FIX: EXCESSIVE FOULS ===
                // If game is in a set piece mode, STOP pressing!
                // This prevents defenders from rushing the kicker during free kicks
                if (this.sim.mode !== 'PLAYING' && this.sim.mode !== 'KICKOFF') return;

                if (other.teamId === p.teamId) return;
                const otherPos = this.sim.players[other.id];
                if (!otherPos) return;
                const d = dist(simP.x, simP.y, otherPos.x, otherPos.y);
                if (d < minD) {
                    const angleTo = Math.atan2(otherPos.y - simP.y, otherPos.x - simP.x);
                    let diff = Math.abs(forwardAngle - angleTo);
                    if (diff > Math.PI) diff = (2 * Math.PI) - diff;
                    if (diff < Math.PI / 3.5) { minD = d; nearest = other; }
                }
            });
        return nearest;
    }

    // === G MOTORU: AKILLI GERÄ° DÃ–NÃœÅž (SMART RECOVERY) ===
    // Defans oyuncusu Ã§alÄ±m yerse topu kovalamaz, kale Ã¶nÃ¼ne koÅŸarak aÃ§Ä±yÄ± kapatÄ±r.
    private applyDefensiveRecoveryLogic(p: Player, state: PlayerState, isHome: boolean): boolean {
        // Oyuncu oyunda mÄ± kontrolÃ¼
        const simP = this.sim.players[p.id];
        if (!simP) return false;

        const b = this.sim.ball;
        const ballSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);

        // Bu mantÄ±k sadece top hÄ±zlÄ±ysa ve rakip hÃ¼cum ediyorsa devreye girer
        // Ev sahibi iÃ§in rakip saÄŸa saldÄ±rÄ±r (vx > 0.5), Deplasman iÃ§in sola (vx < -0.5)
        const isAttacking = isHome ? (b.vx < -0.5) : (b.vx > 0.5);

        // Top hÄ±zlÄ± ve tehlikeli geliyorsa (Kontra atak vb.)
        if (ballSpeed > 1.2 && isAttacking) {
            // Topun 1.5 saniye sonraki tahmini konumu (Intercept Point)
            const interceptX = b.x + b.vx * 45; // 30 tick = 1 sn
            const interceptY = b.y + b.vy * 45;

            // EÄŸer top benim savunma bÃ¶lgeme geliyorsa (Kendi yarÄ± saham)
            const isDangerous = isHome ? (interceptX < 50) : (interceptX > 55);

            if (isDangerous) {
                // Kilit Nokta: Topa deÄŸil, topun GÄ°DECEÄžÄ° yere koÅŸ (Smart Cut)
                const distToIntercept = dist(simP.x, simP.y, interceptX, interceptY);

                // EÄŸer topun gideceÄŸi yere 40 metreden yakÄ±nsam (yetiÅŸme ÅŸansÄ±m varsa)
                if (distToIntercept < 40) {
                    // Hedef: Top ile Kale arasÄ±na girmek
                    state.targetX = interceptX;
                    state.targetY = interceptY;

                    // SPRINT! Can havliyle koÅŸ
                    this.applySteeringBehavior(p, interceptX, interceptY, MAX_PLAYER_SPEED * 1.05);
                    simP.state = 'SPRINT';

                    // BaÅŸarÄ±lÄ± oldu, bu tur iÃ§in baÅŸka karar verme
                    return true;
                }
            }
        }
        return false;
    }

    private updateOffBallAI(p: Player, isHome: boolean, teamHasBall: boolean, ballInPlay: boolean, offsideLineX: number, goalX: number) {
        if (!this.sim.players[p.id]) return;

        const simP = this.sim.players[p.id];
        const role = this.playerRoles[p.id];
        const tactic = isHome ? this.homeTeam.tactic : this.awayTeam.tactic;
        const ballX = this.sim.ball.x;
        const ballY = this.sim.ball.y;

        // === 1. MUTLAK Ã–NCELÄ°K: TOP BANA GELÄ°YOR (G MOTORU RUHU) ===
        // EÄŸer top bana geliyorsa, her ÅŸeyi bÄ±rak topa sprint at!
        if ((this.sim.ball as any).targetId === p.id && !this.sim.ball.ownerId) {
            this.applySteeringBehavior(p, this.sim.ball.x, this.sim.ball.y, MAX_PLAYER_SPEED);
            simP.state = 'SPRINT';
            simP.facing = Math.atan2(this.sim.ball.y - simP.y, this.sim.ball.x - simP.x);
            return;
        }

        // ============================================================
        // === G MOTORU: DEFANSÄ°F ZEKA Ã‡AÄžRISI (SMART RECOVERY) ===
        // ============================================================
        // EÄŸer defans veya orta saha oyuncusuysam ve takÄ±m kontra yiyorsa, akÄ±llÄ± koÅŸu yap
        if (role === Position.DEF || role === Position.MID) {
            // Fonksiyonu Ã§aÄŸÄ±r, eÄŸer "Evet, koÅŸuyorum" derse (true dÃ¶nerse), iÅŸlemi bitir.
            const recoveryActive = this.applyDefensiveRecoveryLogic(p, this.playerStates[p.id], isHome);
            if (recoveryActive) return;
        }
        // ============================================================
        let speedMod = MAX_PLAYER_SPEED * 0.6;
        let targetX, targetY;
        // baseOffsets artÄ±k direkt motor koordinatlarÄ±nda (105x68)
        const base = this.baseOffsets[p.id];

        // FIX: Substitution Crash - baseOffsets might not be ready
        if (!base) return;

        const baseY = isHome ? base.y : PITCH_WIDTH - base.y;
        const baseX = isHome ? base.x : PITCH_LENGTH - base.x;

        // === PRIORITY 1: OFSAYT RECOVERY (MUTLAK Ã–NCELÄ°K) ===
        // EÄŸer forvet ofsayttaysa, HÄ°Ã‡BÄ°R ÅžEY yapma, sadece Ã§izginin gerisine koÅŸ.
        // Formation drift vs. Ã§alÄ±ÅŸmamalÄ±.
        if (role === Position.FWD) {
            const offsideBuffer = 0.2; // 0.2m Tolerance (Strict!)
            const isOnside = isHome ? (simP.x < offsideLineX - offsideBuffer) : (simP.x > offsideLineX + offsideBuffer);

            if (!isOnside) {
                this.playerStates[p.id].isPressing = false;
                // Hedef: Ã‡izginin 4m gerisi (G Motoru StandardÄ±)
                const recoveryX = isHome ? offsideLineX - 4.0 : offsideLineX + 4.0;
                // Y ekseninde kendi pozisyonunu koru ama hafifÃ§e merkeze kay (Ã§arpÄ±ÅŸma Ã¶nlemek iÃ§in)
                const recoveryY = lerp(simP.y, baseY, 0.2);

                const recoverySpeed = MAX_PLAYER_SPEED * 1.15; // PANIC SPEED (%115)
                simP.state = 'SPRINT';
                simP.facing = Math.atan2(baseY - simP.y, (isHome ? 0 : PITCH_LENGTH) - simP.x); // Arkaya bak

                this.applySteeringBehavior(p, recoveryX, recoveryY, recoverySpeed);
                return; // MUTLAK RETURN - BaÅŸka kod Ã§alÄ±ÅŸamaz!
            }
        }





        // === SÃœRÃœ MENTALÄ°TESÄ° ENGELLEYÄ°CÄ° ===
        // TakÄ±m arkadaÅŸlarÄ± ile minimum mesafe kontrolÃ¼
        const teammates = isHome ? this._cachedHomeStarters : this._cachedAwayStarters;
        const MIN_TEAMMATE_DISTANCE = 8; // Minimum 8 birim uzaklÄ±k

        // YakÄ±ndaki takÄ±m arkadaÅŸlarÄ±nÄ± bul
        let nearbyTeammates: { id: string, x: number, y: number, role: Position }[] = [];
        teammates.forEach(tm => {
            if (tm.id === p.id) return;
            const tmPos = this.sim.players[tm.id];
            if (!tmPos) return;
            const d = dist(simP.x, simP.y, tmPos.x, tmPos.y);
            if (d < MIN_TEAMMATE_DISTANCE * 2) {
                nearbyTeammates.push({
                    id: tm.id,
                    x: tmPos.x,
                    y: tmPos.y,
                    role: this.playerRoles[tm.id]
                });
            }
        });

        // AynÄ± rolde yakÄ±n oyuncu var mÄ±? (Ã¶rn: 2 forvet yan yana)
        const sameRoleNearby = nearbyTeammates.filter(tm => tm.role === role);
        const tooCloseTeammates = nearbyTeammates.filter(tm => dist(simP.x, simP.y, tm.x, tm.y) < MIN_TEAMMATE_DISTANCE);

        // === UNIVERSAL INITIALIZATION (MOVED UP) ===
        // baseOffsets artÄ±k direkt motor koordinatlarÄ±nda (105x68)
        const baseTargetX = isHome ? base.x : (PITCH_LENGTH - base.x);
        const baseTargetY = isHome ? base.y : (PITCH_WIDTH - base.y);
        targetX = baseTargetX;
        targetY = baseTargetY;
        speedMod = MAX_PLAYER_SPEED * 0.65;

        // Custom pozisyon varsa daha sÄ±kÄ± takip et
        const tactic_local = isHome ? this.homeTeam.tactic : this.awayTeam.tactic;
        const hasCustomPos = tactic_local.customPositions && tactic_local.customPositions[p.id];

        let maxDriftX = hasCustomPos ? 12 : 18;
        let maxDriftY = hasCustomPos ? 10 : 15;

        // === FREEROAM: MID drift limitlerini artÄ±r ===
        const instructions_offball = tactic.instructions || [];
        if (instructions_offball.includes('RoamFromPosition') && role === Position.MID) {
            maxDriftX = Math.round(maxDriftX * 1.5);
            maxDriftY = Math.round(maxDriftY * 1.5);
            if (teamHasBall) {
                targetX += isHome ? 12 : -12;
            }
        }

        // === GELÄ°ÅžTÄ°RÄ°LMÄ°Åž WIDTH ETKÄ°SÄ° ===
        let widthOffset = tactic.width === 'Wide' ? 1.4 : tactic.width === 'Narrow' ? 0.65 : 1.0;
        if (role === Position.DEF) widthOffset = 1.0;
        targetY = PITCH_CENTER_Y + (targetY - PITCH_CENTER_Y) * widthOffset;


        if (teamHasBall) {
            // --- OFFENSIVE SHAPE & SUPPORT PLAY (G Motoru Entegrasyonu) ---
            this.playerStates[p.id].isPressing = false;

            // 1. Maintain Formation Structure (Temel Pozisyon)
            let lineH = isHome ? Math.min(60, ballX - 20) : Math.max(40, ballX + 20);
            if (tactic.defensiveLine === 'High') lineH = isHome ? Math.min(80, ballX - 15) : Math.max(20, ballX + 15);
            else if (tactic.defensiveLine === 'Deep') lineH = isHome ? Math.min(45, ballX - 25) : Math.max(55, ballX + 25);

            targetX = isHome ? Math.max(targetX, lineH) : Math.min(targetX, lineH);

            // 2. Support Drift & Attacking Runs (GeliÅŸmiÅŸ KoÅŸular)
            const ballCarrierId = this.sim.ball.ownerId;
            const distToBall = dist(simP.x, simP.y, ballX, ballY);

            // Sadece oyuna dahil olabilecek mesafedekiler (GK hariÃ§)
            if (distToBall < 45 && role !== Position.GK) {

                // === FALSE 9 / SUPPORT STRIKER ===
                // EÄŸer forvetsem ve top bizdeyse ama oyun sÄ±kÄ±ÅŸtÄ±ysa, geriye gelip top isteyeyim
                if (role === Position.FWD && distToBall > 25) {
                    // "False 9" Ã¶zelliÄŸi varsa veya taktik "Possession" ise
                    const isFalse9 = p.playStyles?.includes("False 9") || tactic.style === 'Possession';
                    if (isFalse9 && Math.random() < 0.05) {
                        const angleToBall = Math.atan2(ballY - simP.y, ballX - simP.x);
                        // Topa doÄŸru 10m yaklaÅŸ
                        targetX += Math.cos(angleToBall) * 10;
                        targetY += Math.sin(angleToBall) * 10;
                        speedMod = MAX_PLAYER_SPEED * 0.9;
                        this.emitTeamSignal(p, 'CALL'); // "Bana at!"
                    }
                }

                // === CROSSING SPLIT (KANAT ORTALARINDA Ã‡APRAZ KOÅžU) ===
                // Top kanattaysa ve ben forvetsem, direklere koÅŸu yap
                const isBallWide = ballY < 20 || ballY > 48;
                const isBallDeep = isHome ? ballX > 70 : ballX < 35;

                if (role === Position.FWD && isBallWide && isBallDeep) {
                    // Ã–n Direk / Arka Direk PaylaÅŸÄ±mÄ±
                    // Ã‡ift sayÄ± ID'liler Ã–n DireÄŸe, Tek sayÄ±lar Arka DireÄŸe
                    const isNearPost = (p.lineupIndex || 0) % 2 === 0;

                    // Ã–n Direk: Kale sahasÄ±nÄ±n Ã¶n kÃ¶ÅŸesi
                    // Arka Direk: PenaltÄ± noktasÄ± hizasÄ±nÄ±n arka tarafÄ±
                    const goalX = isHome ? PITCH_LENGTH : 0;
                    const nearPostY = ballY < PITCH_CENTER_Y ? 28 : 40; // Topun olduÄŸu taraftaki direk
                    const farPostY = ballY < PITCH_CENTER_Y ? 40 : 28;  // DiÄŸer direk

                    targetX = isHome ? goalX - 8 : goalX + 8; // Kale aÄŸzÄ±
                    targetY = isNearPost ? nearPostY : farPostY;

                    speedMod = MAX_PLAYER_SPEED; // Tam gaz koÅŸ!
                    simP.state = 'SPRINT';

                    if (Math.random() < 0.1) this.emitTeamSignal(p, 'POINT'); // "Oraya at!"
                }

                // === SHADOW STRIKER (ORTA SAHA SIZMASI) ===
                // Forvetler kanata aÃ§Ä±ldÄ±ysa veya boÅŸluk varsa orta saha iÃ§eri dalar
                if (role === Position.MID && isBallDeep && Math.abs(ballY - PITCH_CENTER_Y) > 15) {
                    // EÄŸer "Gizli Forvet" ise veya ofansif bir rolÃ¼ varsa
                    const isShadowStriker = p.playStyles?.includes("Gizli Forvet") || tactic.mentality === 'Attacking';

                    if (isShadowStriker && Math.random() < 0.03) {
                        // PenaltÄ± noktasÄ±na sÃ¼rpriz koÅŸu
                        targetX = isHome ? PITCH_LENGTH - 12 : 12;
                        targetY = PITCH_CENTER_Y;
                        speedMod = MAX_PLAYER_SPEED * 0.95;
                        simP.state = 'SPRINT';
                    }
                }
            }

            if (simP.state !== 'SPRINT') simP.state = 'RUN';

            // === G MOTORU: YARATICI KAOS (CREATIVE ROAMING) ===
            // YÄ±ldÄ±z oyuncular veya talimat alanlar pozisyonlarÄ±nÄ± terk edebilir
            const isCreative = (p.attributes.vision > 80) || (p.playStyles?.includes("Serbest"));
            const hasRoamInstruction = tactic.instructions && tactic.instructions.includes('RoamFromPosition');

            if (isCreative || hasRoamInstruction) {
                // Drift limitlerini 2 katÄ±na Ã§Ä±kar!
                maxDriftX *= 2.0;
                maxDriftY *= 1.8;

                // BoÅŸluk arama: Topun olduÄŸu yere deÄŸil, boÅŸ alana kay
                if (Math.random() < 0.1) { // Her 10 tickte bir yeni boÅŸluk ara
                    const randomShift = (Math.random() - 0.5) * 15;
                    targetX += randomShift;
                    // Forvetse kanatlara deÄŸil merkeze, Kanatsa iÃ§eri
                    if ((role as any) === Position.FWD) targetY = lerp(targetY, PITCH_CENTER_Y, 0.2);
                }
            }

            // === AÅžIRI KAYMA ENGELÄ° (HÃœCUM) ===
            // Oyuncular base pozisyonlarÄ±ndan Ã§ok uzaklaÅŸmasÄ±n
            const driftX = targetX - baseTargetX;
            const driftY = targetY - baseTargetY;
            if (Math.abs(driftX) > maxDriftX) {
                targetX = baseTargetX + Math.sign(driftX) * maxDriftX;
            }
            if (Math.abs(driftY) > maxDriftY) {
                targetY = baseTargetY + Math.sign(driftY) * maxDriftY;
            }

            // Fullback Overlap Logic - sadece Ã§ok ileri gitmiÅŸse
            if (role === Position.DEF) {
                const isWide = simP.y < 17 || simP.y > PITCH_WIDTH - 17;
                const isBallAdvanced = isHome ? ballX > PITCH_CENTER_X + 5 : ballX < PITCH_CENTER_X - 5;
                if (isWide && isBallAdvanced) {
                    // Overlap run - ama sÄ±nÄ±rlÄ±
                    const overlapDist = Math.min(15, maxDriftX);
                    targetX += (isHome ? overlapDist : -overlapDist);
                    targetY = lerp(targetY, (simP.y < PITCH_CENTER_Y ? 5 : PITCH_WIDTH - 5), 0.25);
                    speedMod = MAX_PLAYER_SPEED * 0.85;
                }
            }

            simP.state = 'RUN';

        } else {
            if (role === Position.FWD) {
                // Defensive Shape - IMPROVED FORWARD DEFENSIVE SUPPORT
                this.playerStates[p.id].isPressing = false;

                // Check if ball is deep in our own half
                const isBallDeepInOwnHalf = isHome ? (ballX < 35) : (ballX > 65);
                const distToBallFromForward = dist(simP.x, simP.y, ballX, ballY);

                if (isBallDeepInOwnHalf) {
                    // Drop back to help! Don't be lazy at the halfway line
                    targetX = isHome ? Math.max(40, ballX + 15) : Math.min(60, ballX - 15);
                    targetY = lerp(simP.y, ballY, 0.3); // Drift towards ball's Y
                    speedMod = MAX_PLAYER_SPEED * 0.75; // Jog back, not idle
                    simP.state = 'RUN';
                } else if (distToBallFromForward < 25 && !ballInPlay) {
                    // Ball is loose and nearby - chase it!
                    targetX = ballX;
                    targetY = ballY;
                    speedMod = MAX_PLAYER_SPEED * 0.9;
                    simP.state = 'RUN';
                } else {
                    // Normal defensive position
                    targetX = isHome ? offsideLineX - 2.0 : offsideLineX + 2.0;
                    targetY = lerp(simP.y, baseTargetY, 0.15);
                    speedMod = MAX_PLAYER_SPEED * 0.7;
                    simP.state = 'RUN';
                }
            } else {
                // --- DEFENSIVE SHAPE (IMPROVED - GOAL-SIDE POSITIONING) ---
                const ballCarrierId = this.sim.ball.ownerId;
                const distToBall = dist(simP.x, simP.y, ballX, ballY);
                const myGoalX = isHome ? 0 : PITCH_LENGTH;

                // === PAS OKUMA & KESÄ°ÅžÄ°M SÄ°STEMÄ° (YENÄ°) ===
                // Top serbest (pas uÃ§uÅŸta) ve hÄ±zlÄ± hareket ediyorsa, araya gir!
                // Goal-side positioning BOZULMAZ: Bu sadece ownerId=null durumunda Ã§alÄ±ÅŸÄ±r
                if (!ballCarrierId) {
                    const ballVx = this.sim.ball.vx || 0;
                    const ballVy = this.sim.ball.vy || 0;
                    const ballSpd = Math.sqrt(ballVx * ballVx + ballVy * ballVy);

                    // Sadece hÄ±zlÄ± hareket eden toplar iÃ§in (pas/ÅŸut), yavaÅŸ toplar zaten pickup ile alÄ±nÄ±r
                    if (ballSpd > 0.8) {
                        // Topun 8-15 tick sonra olacaÄŸÄ± yeri hesapla
                        const interceptTicks = Math.min(15, distToBall / (MAX_PLAYER_SPEED * 0.9));
                        const friction = (this.sim.ball.z > 0.5) ? 0.995 : 0.985;

                        let predBallX = ballX;
                        let predBallY = ballY;
                        let tmpVx = ballVx;
                        let tmpVy = ballVy;
                        for (let t = 0; t < interceptTicks; t++) {
                            predBallX += tmpVx;
                            predBallY += tmpVy;
                            tmpVx *= friction;
                            tmpVy *= friction;
                        }

                        // Topun yolu benim bÃ¶lgemden geÃ§iyor mu?
                        const distToPath = this.distToSegment(simP.x, simP.y, ballX, ballY, predBallX, predBallY);
                        const distToIntercept = dist(simP.x, simP.y, predBallX, predBallY);

                        // Top benim bÃ¶lgemden geÃ§iyor (15m iÃ§inde) VE yetiÅŸebilirim
                        // Ama Ã¶nemli: Kale tarafÄ±na doÄŸru koÅŸ, topun arkasÄ±ndan tren gibi gitme!
                        if (distToPath < 15 && distToIntercept < 20) {
                            // KesiÅŸim noktasÄ±nÄ± hesapla - topun geÃ§eceÄŸi en yakÄ±n nokta
                            // Ama kale ile top arasÄ±ndaki Ã§izgide kal (goal-side korunsun)
                            let interceptX = predBallX;
                            let interceptY = predBallY;

                            // GOAL-SIDE KORUMASI: KesiÅŸim noktasÄ± benim goal-side'Ä±mda mÄ±?
                            const isInterceptGoalSide = isHome
                                ? (interceptX < simP.x + 3) // Sol kaleye yakÄ±nsam, intercept sola doÄŸru olmalÄ±
                                : (interceptX > simP.x - 3); // SaÄŸ kaleye yakÄ±nsam, intercept saÄŸa doÄŸru olmalÄ±

                            if (isInterceptGoalSide) {
                                // Kalenin Ã¶nÃ¼nde kal ama topun yoluna gir
                                targetX = interceptX;
                                targetY = interceptY;
                                speedMod = MAX_PLAYER_SPEED * 0.95;
                                simP.state = 'SPRINT';

                                // Saha sÄ±nÄ±rlarÄ±
                                targetX = clamp(targetX, 1, PITCH_LENGTH - 1);
                                targetY = clamp(targetY, 2, PITCH_WIDTH - 2);

                                this.applySteeringBehavior(p, targetX, targetY, speedMod);
                                return; // Intercept mantÄ±ÄŸÄ± devreye girdi
                            }
                        }
                    }
                }

                // === GENÄ°ÅžLETÄ°LMÄ°Åž TEHLÄ°KE BÃ–LGESÄ° ===
                // Sadece ceza sahasÄ± deÄŸil, orta sahada da aktif ol!
                const distToMyGoal = Math.abs(ballX - myGoalX);
                const isDangerZone = distToMyGoal < 52; // YarÄ± saha (105/2)
                const isCriticalZone = distToMyGoal < 32; // Kritik bÃ¶lge (ceza sahasÄ± yakÄ±nÄ±)

                // 1. Calculate ideal position based on formation
                // === CUSTOM POSITION KORUNMASI (SAVUNMA) ===
                let idealX = isHome ? base.x : (PITCH_LENGTH - base.x);

                // FIX: Orta sahalarÄ±n defans hattÄ±na gÃ¶mÃ¼lmesini engelle (6-7 kiÅŸilik defans oluÅŸmamasÄ± iÃ§in)
                // Midfielders should stay in front of the penalty box (approx 25% of pitch)
                if (role === Position.MID) {
                    const minMidX = PITCH_LENGTH * 0.24; // ~25 metre
                    const maxMidX = PITCH_LENGTH * 0.76; // ~80 metre
                    if (isHome && idealX < minMidX) idealX = minMidX;
                    if (!isHome && idealX > maxMidX) idealX = maxMidX;
                }

                let idealY = isHome ? base.y : (PITCH_WIDTH - base.y);

                // Custom pozisyon varsa Y ekseninde daha sadÄ±k kal
                const hasCustomDefPos = tactic.customPositions && tactic.customPositions[p.id];

                // Apply width setting - COMPLETELY IGNORED for defenders to keep defensive shape compact
                // Defenders stay in formation positions (prevents touchline-hugging)
                let widthOffset = tactic.width === 'Wide' ? 1.25 : tactic.width === 'Narrow' ? 0.75 : 1.0;
                if (role === Position.DEF) {
                    // Defenders: ALWAYS use 1.0 - ignore width setting when defending!
                    // This keeps the 4-back or 5-back line compact and goal-protecting
                    widthOffset = 1.0;
                }
                idealY = PITCH_CENTER_Y + (idealY - PITCH_CENTER_Y) * widthOffset;

                // Shift with ball Y position (cover shadow) - DENGELI kayma
                // Top Ã§ok uzaktaysa kayma, yakÄ±nsa kayabilir
                const distToBallForShadow = dist(simP.x, simP.y, ballX, ballY);
                const ballIsClose = distToBallForShadow < 35;

                // Custom pozisyon varsa daha az kay, top uzaksa hiÃ§ kayma
                let shadowStrength = hasCustomDefPos ? 0.10 : 0.18;
                if (!ballIsClose) shadowStrength *= 0.3; // Uzak toplar iÃ§in minimal kayma

                // Maksimum kayma mesafesi - pozisyonundan 15 metreden fazla uzaklaÅŸma
                const maxShift = 15;
                const proposedY = lerp(idealY, ballY, shadowStrength);
                const shiftAmount = Math.abs(proposedY - (isHome ? base.y : PITCH_WIDTH - base.y));

                // 3. COVERING LOGIC (KADEME ANLAYIÅžI) - YENÄ°!
                // Partnerim baskÄ±daysa, onun boÅŸluÄŸunu kapat
                if (role === Position.DEF) {
                    let coveringShift = 0;
                    const teammates = isHome ? this._cachedHomeStarters : this._cachedAwayStarters;

                    // YakÄ±ndaki diÄŸer defans oyuncularÄ±na bak
                    teammates.forEach(tm => {
                        if (tm.id === p.id) return;
                        if (this.playerRoles[tm.id] !== Position.DEF) return; // Sadece defans partnerleri

                        const tmState = this.playerStates[tm.id];
                        if (!tmState || !this.sim.players[tm.id]) return; // Guard: oyuncu state yoksa atla
                        const tmBase = isHome ? this.baseOffsets[tm.id] : { x: PITCH_LENGTH - this.baseOffsets[tm.id].x, y: PITCH_WIDTH - this.baseOffsets[tm.id].y };

                        // Partner baskÄ±da mÄ± veya pozisyonunu Ã§ok mu kaybetti?
                        // (BaskÄ±daysa veya 15m'den fazla aÃ§Ä±ldÄ±ysa)
                        const isOut = tmState.isPressing || dist(this.sim.players[tm.id].x, this.sim.players[tm.id].y, tmBase.x, tmBase.y) > 15;

                        if (isOut) {
                            // Partner benden hangi yÃ¶nde? (Y ekseni)
                            const yDiff = tmBase.y - idealY; // Pozitifse o aÅŸaÄŸÄ±da, negatifse yukarÄ±da

                            // EÄŸer partner benden uzaktaysa (aramÄ±zda mesafe varsa) ve o pozisyonu terk ettiyse
                            // Ben ona doÄŸru kaymalÄ±yÄ±m.
                            // Ã‡ok yakÄ±nsam (stoper-stoper) daha Ã§ok, uzaksa (bek-stoper) daha az.
                            if (Math.abs(yDiff) < 20) {
                                coveringShift += yDiff * 0.4; // %40 oranÄ±nda kapat
                            }
                        }
                    });

                    // Proposed Y'ye covering ekle
                    idealY += coveringShift;
                } else {
                    idealY = proposedY;
                }

                // 2. Calculate defensive line limit
                let defLineX = isHome ? 26 : 79;
                if (tactic.defensiveLine === 'High') defLineX = isHome ? 37 : 68;
                if (tactic.defensiveLine === 'Deep') defLineX = isHome ? 16 : 89;

                // === YENÄ°: PRESÃ‡I Ã‡IKINCA DEFANS KOMPAKT KALMA ===
                // Bir defans arkadaÅŸÄ± prese Ã§Ä±kÄ±nca, kalan defanslar geri Ã§ekilir
                // Bu, kanattan gelen rakibin defansÄ±n arkasÄ±nda beleÅŸ kalmasÄ±nÄ± engeller
                if (role === Position.DEF && !this.playerStates[p.id].isPressing) {
                    const myTeamDefs = (isHome ? this.homePlayers : this.awayPlayers)
                        .filter(tm => this.playerRoles[tm.id] === Position.DEF && tm.id !== p.id);
                    const anyPartnerPressing = myTeamDefs.some(tm => this.playerStates[tm.id]?.isPressing);

                    if (anyPartnerPressing) {
                        // Partner prese Ã§Ä±kmÄ±ÅŸ â†’ diÄŸerleri 6m geri Ã§ekil!
                        defLineX = isHome ? Math.max(defLineX - 6, 14) : Math.min(defLineX + 6, 91);
                    }
                }

                // 3. CRITICAL: GOAL-SIDE POSITIONING
                // Check if ball is BEHIND my ideal position (line is broken!)
                const isBallBehindMe = isHome ? (ballX < idealX) : (ballX > idealX);

                // === YENÄ°: UZAK DEFANSIN TEHLÄ°KEYE KOÅžMASI ===
                // Gemini'nin tespiti: "Uzaktaki defans tehlikeye koÅŸmuyor, yerine gidiyor"
                // Ã‡Ã¶zÃ¼m: Forvet kaleye doÄŸru koÅŸuyorsa, TÃœM defansÃ§Ä±lar kaleye dÃ¶nmeli
                let isTeamUnderThreat = false;
                let threatDirection: 'left' | 'right' | 'center' | null = null;

                if (ballCarrierId && role === Position.DEF) {
                    const carrier = this.getPlayer(ballCarrierId);
                    const carrierPos = this.sim.players[ballCarrierId];

                    if (carrier && carrierPos && carrier.teamId !== p.teamId) {
                        const carrierVx = carrierPos.vx || 0;
                        const isCarrierRunningToGoal = isHome ? carrierVx < -0.5 : carrierVx > 0.5;
                        const carrierDistToGoal = Math.abs(carrierPos.x - myGoalX);

                        // Forvet kaleye doÄŸru koÅŸuyor VE tehlikeli mesafede
                        if (isCarrierRunningToGoal && carrierDistToGoal < 45) {
                            isTeamUnderThreat = true;

                            // Tehdit hangi yÃ¶nden?
                            if (carrierPos.y < 24) threatDirection = 'left';
                            else if (carrierPos.y > 44) threatDirection = 'right';
                            else threatDirection = 'center';

                            // === UZAK DEFANSIN RECOVERY RUN'I (v2 - DAHA HIZLI KAPANMA) ===
                            // Ben forvetin bulunduÄŸu tarafta deÄŸilsem bile, kaleye dÃ¶n!
                            const myDistToCarrier = dist(simP.x, simP.y, carrierPos.x, carrierPos.y);

                            // BUFF: 20m -> 15m (daha erken tepki)
                            if (myDistToCarrier > 15) {
                                // Ben uzaktayÄ±m - kaleye dÃ¶n, forvetin peÅŸinden koÅŸma
                                // Ama yerime de gitme! Kale ile forvet arasÄ±na gir!

                                // Forvetin gideceÄŸi yeri tahmin et
                                const predictTime = 10;
                                const futureCarrierX = carrierPos.x + carrierVx * predictTime;

                                // Kale ile forvet arasÄ±nda bir noktaya git
                                const coverX = (myGoalX + futureCarrierX) / 2;

                                // Y ekseninde: Forvetin geldiÄŸi tarafa doÄŸru kay
                                let coverY = idealY;
                                if (threatDirection === 'left' && simP.y > 34) {
                                    coverY = lerp(idealY, 24, 0.5); // 0.4 -> 0.5 (daha agresif)
                                } else if (threatDirection === 'right' && simP.y < 34) {
                                    coverY = lerp(idealY, 44, 0.5); // 0.4 -> 0.5
                                } else if (threatDirection === 'center') {
                                    // Merkez tehdit - pozisyonunu koru ama geriye gel
                                    coverY = idealY;
                                }

                                // Hedef: Kaleye yaklaÅŸ ama forvetin pas yolunu kes
                                targetX = isHome ? Math.max(coverX, 8) : Math.min(coverX, PITCH_LENGTH - 8);
                                targetY = coverY;

                                // BUFF: Daha hÄ±zlÄ± koÅŸ! 0.85 -> 0.92
                                speedMod = MAX_PLAYER_SPEED * 0.92;
                                simP.state = 'SPRINT';
                            }
                        }
                    }
                }

                // === KALE Ã–NÃœ ACÄ°L DURUM ===
                // Top kale Ã¶nÃ¼nde (< 12m) ise TÃœM savunmacÄ±lar oraya koÅŸmalÄ±!
                const isGoalBoxEmergency = isHome ? (ballX < 12) : (ballX > PITCH_LENGTH - 12);
                const isInMyPenaltyBox = isHome ? (ballX < 20) : (ballX > PITCH_LENGTH - 20);

                if (isGoalBoxEmergency && role === Position.DEF) {
                    // ACÄ°L DURUM! Kale Ã¶nÃ¼ne koÅŸ!
                    // Topun olduÄŸu yere git, ama kaleyi koru
                    targetX = isHome ? Math.max(2, ballX - 3) : Math.min(PITCH_LENGTH - 2, ballX + 3);
                    targetY = lerp(simP.y, ballY, 0.8); // Topa doÄŸru kay

                    // Kale Ã§izgisini koru - Kale genisliÄŸi: 30.34-37.66, biraz geniÅŸlet
                    targetY = clamp(targetY, 20, 48); // Motor: kale etrafÄ± 20-48m

                    speedMod = MAX_PLAYER_SPEED;
                    simP.state = 'SPRINT';
                    this.playerStates[p.id].isPressing = true;

                    // Topa Ã§ok yakÄ±nsan mÃ¼dahale et!
                    if (distToBall < TACKLE_RANGE_BASE + 3 && ballCarrierId) {
                        const pState2 = this.playerStates[p.id];
                        if (pState2 && pState2.actionLock <= 0) {
                            this.actionTackle(p, this.getPlayer(ballCarrierId)!);
                            pState2.actionLock = 25; // 0.4 saniye cooldown
                        }
                    }

                } else if (isInMyPenaltyBox && (role === Position.DEF || role === Position.MID)) {
                    // Ceza sahasÄ± iÃ§i - daha az agresif ama hala acil
                    const ballDistToGoal = Math.abs(ballX - myGoalX);

                    // Kale ile top arasÄ±na gir
                    targetX = isHome ? Math.max(5, ballX - 5) : Math.min(PITCH_LENGTH - 5, ballX + 5);
                    targetY = lerp(simP.y, ballY, 0.5);
                    targetY = clamp(targetY, 17, 51); // Motor: geniÅŸ savunma hattÄ±

                    speedMod = MAX_PLAYER_SPEED * 0.95;
                    simP.state = 'SPRINT';

                    // MÃ¼dahale mesafesi
                    if (distToBall < TACKLE_RANGE_BASE + 2 && ballCarrierId) {
                        this.actionTackle(p, this.getPlayer(ballCarrierId)!);
                    }

                } else if (isBallBehindMe) {
                    // === AKILLI RECOVERY RUN ===
                    // Topun arkasÄ±ndan koÅŸma! Topun GÄ°DECEÄžÄ° yere koÅŸ!

                    // Top hÄ±zÄ±nÄ± hesapla - nereye gidiyor?
                    const ballVelX = this.sim.ball.vx || 0;
                    const ballVelY = this.sim.ball.vy || 0;
                    const ballSpeed = Math.sqrt(ballVelX * ballVelX + ballVelY * ballVelY);

                    // Topun 10-15 tick sonra olacaÄŸÄ± yer (interception noktasÄ±)
                    const interceptTime = ballSpeed > 0.5 ? 12 : 5;
                    const futureBallX = ballX + ballVelX * interceptTime;
                    const futureBallY = ballY + ballVelY * interceptTime;

                    // Kale ile top arasÄ±na gir, ama topun gideceÄŸi yere
                    targetX = futureBallX + (isHome ? -4 : 4);

                    // Y ekseninde de topun gideceÄŸi yere koÅŸ
                    targetY = lerp(simP.y, futureBallY, 0.7);

                    // EÄŸer top hÄ±zlÄ± hareket ediyorsa, daha agresif kes
                    if (ballSpeed > 1.0) {
                        targetY = futureBallY; // Direkt topun gideceÄŸi yere
                    }

                    // Sprint to recover!
                    speedMod = MAX_PLAYER_SPEED;
                    simP.state = 'SPRINT';
                    this.playerStates[p.id].isPressing = false; // Not pressing, recovering

                } else {
                    // Ball is in front - maintain position but be ready

                    // === G MOTORU: Ä°Ã‡ERÄ° KAPANMA (TUCK IN) ===
                    if (role === Position.DEF) {
                        const isBallCentral = Math.abs(ballY - 34) < 15;
                        const isEnemyAttacking = isHome ? ballX < 40 : ballX > 65;

                        if (isBallCentral && isEnemyAttacking) {
                            // Rakip merkezden geliyorsa, kanat bekleri merkeze yaklaÅŸÄ±r (Kale Ã¶nÃ¼nÃ¼ kapatÄ±r)
                            targetY = lerp(targetY, 34, 0.4);
                            targetX = lerp(targetX, myGoalX, 0.15); // Kaleye doÄŸru hafif geri Ã§ekil
                        }
                    }

                    // === GELÄ°ÅžTÄ°RÄ°LMÄ°Åž COVER SHADOW (PAS YOLU KAPATMA) ===
                    // SavunmacÄ±, top taÅŸÄ±yan ile tehlikeli hÃ¼cumcu arasÄ±ndaki pas yolunu kapatmalÄ±
                    if (ballCarrierId && (role === Position.DEF || role === Position.MID)) {
                        const ballCarrier = this.getPlayer(ballCarrierId);
                        if (ballCarrier && ballCarrier.teamId !== p.teamId) {
                            // Rakip top taÅŸÄ±yorsa, tehlikeli pas yollarÄ±nÄ± kapat
                            const enemyTeam = isHome ? this.awayPlayers : this.homePlayers;
                            const dangerousAttackers = enemyTeam.filter(e => {
                                if (!this.sim.players[e.id]) return false;
                                const ePos = this.sim.players[e.id];
                                // Kaleye yakÄ±n ve pas alabilecek pozisyondaki hÃ¼cumcular
                                const isNearGoal = isHome ? ePos.x < 40 : ePos.x > 60;
                                const isForward = this.playerRoles[e.id] === Position.FWD || this.playerRoles[e.id] === Position.MID;
                                return isNearGoal && isForward && e.id !== ballCarrierId;
                            });

                            // En yakÄ±n tehlikeli hÃ¼cumcunun pas yolunu kapat
                            if (dangerousAttackers.length > 0) {
                                let closestThreat: Player | null = null;
                                let minThreatDist = 999;

                                dangerousAttackers.forEach(threat => {
                                    const threatPos = this.sim.players[threat.id];
                                    const distToThreat = dist(simP.x, simP.y, threatPos.x, threatPos.y);
                                    if (distToThreat < minThreatDist && distToThreat < 20) {
                                        minThreatDist = distToThreat;
                                        closestThreat = threat;
                                    }
                                });

                                if (closestThreat && this.sim.players[closestThreat.id]) {
                                    const threatPos = this.sim.players[closestThreat.id];
                                    // Pas yolunun ortasÄ±na pozisyon al
                                    const coverX = (ballX + threatPos.x) / 2;
                                    const coverY = (ballY + threatPos.y) / 2;

                                    // EÄŸer pas yolu kendi bÃ¶lgemde ve yakÄ±nÄ±mdaysa, oraya git
                                    const isCoverInMyZone = Math.abs(coverX - idealX) < 15 && Math.abs(coverY - idealY) < 20;
                                    if (isCoverInMyZone) {
                                        targetX = lerp(targetX, coverX, 0.4);
                                        targetY = lerp(targetY, coverY, 0.4);

                                        // "Sezgili" yeteneÄŸi: Pas yolu okuma bonusu
                                        if (p.playStyles?.includes("Sezgili") || p.playStyles?.includes("Sezgili+")) {
                                            targetX = lerp(targetX, coverX, 0.2); // Daha agresif kapatma
                                            targetY = lerp(targetY, coverY, 0.2);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // === GLOBAL PRESSING CONTROLLER (Merkezi Pres Sistemi) ===
                    // ArtÄ±k her oyuncu kendi kafasÄ±na gÃ¶re karar vermiyor!
                    // step() baÅŸÄ±nda belirlenen "yetkili" oyuncular listesini kullan

                    const myPresserSet = isHome ? this.homePresserIds : this.awayPresserIds;
                    const hasGlobalAuthority = myPresserSet.has(p.id);

                    // === EMERGENCY INITIATIVE (Acil Durum Ä°nisiyatifi) ===
                    // Senin korkunu gideren mantÄ±k: "Yetkisiz ama dibimde top var!"
                    // Merkezi yetkisi olmasa bile, top Ã§ok yakÄ±n ve tehlikeli bÃ¶lgedeyse mÃ¼dahale et!
                    const EMERGENCY_DISTANCE = 8; // 8 metreden yakÄ±nsa acil durum
                    const isBallInMyFrontYard = distToBall < EMERGENCY_DISTANCE;
                    const isEmergencyZone = isHome ? ballX < 35 : ballX > PITCH_LENGTH - 35; // Kendi yarÄ± saham

                    // === FORVET TAKÄ°BÄ° (Local Initiative) ===
                    // EÄŸer bir forvet bana doÄŸru geliyorsa, ona KAPAN!
                    let closestThreatToMe: Player | null = null;
                    let minThreatToMeDist = 999;
                    let isPenaltyBoxDanger = false;

                    if (role === Position.DEF && ballCarrierId) {
                        const ballCarrier = this.getPlayer(ballCarrierId);
                        if (ballCarrier && ballCarrier.teamId !== p.teamId) {
                            const carrierPos = this.sim.players[ballCarrierId];
                            if (carrierPos) {
                                const distToCarrier = dist(simP.x, simP.y, carrierPos.x, carrierPos.y);
                                const isCarrierInMyZone = Math.abs(carrierPos.y - simP.y) < 20;

                                // CEZA SAHASI KONTROLÃœ
                                isPenaltyBoxDanger = isHome ?
                                    (carrierPos.x < 25 && Math.abs(carrierPos.y - simP.y) < 25) :
                                    (carrierPos.x > PITCH_LENGTH - 25 && Math.abs(carrierPos.y - simP.y) < 25);

                                const carrierVx = carrierPos.vx || 0;
                                const carrierVy = carrierPos.vy || 0;
                                const isRunningToGoal = isHome ? carrierVx < -0.3 : carrierVx > 0.3;

                                if (distToCarrier < 25 && (isCarrierInMyZone || isPenaltyBoxDanger)) {
                                    closestThreatToMe = ballCarrier;
                                    minThreatToMeDist = distToCarrier;

                                    // Forvetin GÄ°DECEÄžÄ° yere git
                                    const interceptTime = Math.max(5, distToCarrier / 2);
                                    const futureCarrierX = carrierPos.x + carrierVx * interceptTime;
                                    const futureCarrierY = carrierPos.y + carrierVy * interceptTime;

                                    targetX = lerp(myGoalX, futureCarrierX, 0.85);
                                    targetY = lerp(simP.y, futureCarrierY, 0.6);

                                    if (distToCarrier < 15 && isRunningToGoal) {
                                        targetX = futureCarrierX + (isHome ? -2 : 2);
                                        targetY = futureCarrierY;
                                        speedMod = MAX_PLAYER_SPEED;
                                        simP.state = 'SPRINT';
                                    } else if (distToCarrier < 20) {
                                        speedMod = MAX_PLAYER_SPEED * 0.9;
                                        simP.state = 'RUN';
                                    }
                                }
                            }
                        }
                    }

                    // === NIHAI PRES KARARI ===
                    // 3 yoldan biriyle pres yapabilirsin:
                    // 1. Merkezi Yetki (Global Authority) - step() baÅŸÄ±nda seÃ§ildin
                    // 2. Acil Durum (Emergency Initiative) - top Ã§ok yakÄ±n + tehlikeli bÃ¶lge
                    // 3. Forvet Takibi (closestThreatToMe) - defansÃ§Ä± iÃ§in forvet kapanmasÄ±
                    let shouldPress = hasGlobalAuthority ||
                        (isBallInMyFrontYard && isEmergencyZone) ||
                        (closestThreatToMe !== null && isPenaltyBoxDanger);

                    if (shouldPress) {
                        this.playerStates[p.id].isPressing = true;

                        // === TARGET OFFSETTING (GEMÄ°NÄ°'NÄ°N Ã–NERÄ°SÄ°) ===
                        // Ä°ki presÃ§inin aynÄ± noktaya koÅŸup Ã§arpÄ±ÅŸmasÄ±nÄ± engelle!
                        // Hangi sÄ±rada pres yapÄ±yorum?
                        const myTeam = isHome ? this.homeTeam : this.awayTeam;
                        const isHomeTeam = isHome;
                        const myDefenders = isHomeTeam
                            ? this.homePlayers.filter(dp => this.playerRoles[dp.id] === Position.DEF)
                            : this.awayPlayers.filter(dp => this.playerRoles[dp.id] === Position.DEF);

                        let myRank = 0;
                        if (hasGlobalAuthority) {
                            const myPresserSet = isHome ? this.homePresserIds : this.awayPresserIds;
                            const presserArray = Array.from(myPresserSet);
                            myRank = presserArray.indexOf(p.id) + 1; // 1-indexed
                        }

                        // Forvet takibi varsa ona git, yoksa topa git
                        if (!closestThreatToMe) {
                            let interceptX = ballX + this.sim.ball.vx * 3;
                            let interceptY = ballY + this.sim.ball.vy * 3;

                            // === AKILLI HEDEF AYRIMI (OFFSET) ===
                            // 1. PresÃ§i: Direkt topa basar (Aggressive Press)
                            // 2. PresÃ§i: Top ile kale arasÄ±na girer (Supporting Layer/Jockey)
                            if (myRank === 2) {
                                const goalX = isHome ? 0 : PITCH_LENGTH;
                                // Hedefi top ile kale arasÄ±na kaydÄ±r (lerp)
                                // - X'i %25 kaleye doÄŸru Ã§ek
                                // - Y'yi %15 merkeze doÄŸru Ã§ek
                                interceptX = lerp(interceptX, goalX, 0.25);
                                interceptY = lerp(interceptY, PITCH_CENTER_Y, 0.15);
                            }

                            targetX = interceptX;
                            targetY = interceptY;
                        }
                        speedMod = MAX_PLAYER_SPEED;
                        simP.state = 'SPRINT';

                        // Tackle mesafesi
                        let tackleDist = TACKLE_RANGE_BASE;
                        if (isPenaltyBoxDanger) {
                            tackleDist = 7.5; // Ceza sahasÄ±nda daha geniÅŸ aralÄ±k
                        }

                        if (distToBall < tackleDist && ballCarrierId) {
                            // === TACKLE COOLDOWN CHECK ===
                            // AynÄ± oyuncu sÃ¼rekli tackle yapamasÄ±n!
                            const pState = this.playerStates[p.id];
                            if (pState && pState.actionLock <= 0) {
                                this.actionTackle(p, this.getPlayer(ballCarrierId)!);
                                pState.actionLock = 25; // 0.4 saniye cooldown (60â†’25)
                            }
                        }
                    } else {
                        // === YETKÄ°SÄ°Z OYUNCU - RECOVERY RUN & CROWDING FIX ===
                        // Merkezi sistemden yetki almadÄ±n ve acil durum da yok
                        // Top Ã§ok yakÄ±nsa (< 12m): HEMEN SAVUNMA HATTINA GERÄ° KOÅž!
                        // Uzaksa: Bir sorun yok, ideal pozisyon koru
                        this.playerStates[p.id].isPressing = false;

                        if (distToBall < 12) {
                            // === RECOVERY RUN: Topa Ã§ok yakÄ±nÄ±z ama yetkili deÄŸiliz ===
                            // Kaledeki ideal pozisyona doÄŸru geri koÅŸ
                            const myGoalX = isHome ? 0 : PITCH_LENGTH;

                            // Åžu anki X'i ideal X ile interpolate et (0.5 = %50)
                            // Sonra kaleye doÄŸru %20 daha Ã§ek
                            let recoveryX = lerp(simP.x, idealX, 0.5);
                            recoveryX = isHome
                                ? Math.max(recoveryX, 0)
                                : Math.min(recoveryX, PITCH_LENGTH);
                            recoveryX = lerp(recoveryX, myGoalX, 0.2);

                            targetX = recoveryX;
                            targetY = idealY;

                            speedMod = MAX_PLAYER_SPEED * 0.85; // HÄ±zlÄ± ama sprint deÄŸil
                            simP.state = 'RUN';

                            // Topu izle (jockey position)
                            simP.facing = Math.atan2(ballY - simP.y, ballX - simP.x);
                        } else {
                            // Uzakta isen, sadece defans hattÄ±nÄ± koru
                            // Jockey position - face the ball when within 15m
                            if (distToBall < 15) {
                                simP.facing = Math.atan2(ballY - simP.y, ballX - simP.x);
                            }

                            // Stay on defensive line - pas yollarÄ±nÄ± kapat
                            targetX = isHome ? Math.max(idealX, defLineX) : Math.min(idealX, defLineX);
                            targetY = idealY;
                            speedMod = MAX_PLAYER_SPEED * 0.65;
                            simP.state = 'RUN';
                        }
                    }
                }

                // === GK RETREAT LOGIC (Engine 4) ===
                if (role === Position.GK) {
                    const startLine = isHome ? 0 : PITCH_LENGTH;
                    const distToLine = Math.abs(ballX - startLine);
                    const isDanger = distToLine < 35; // 35m danger zone

                    if (isDanger) {
                        // RETREAT! Kaleye geri dÃ¶n
                        targetX = isHome ? 2.0 : PITCH_LENGTH - 2.0;
                        targetY = PITCH_CENTER_Y;
                        speedMod = MAX_PLAYER_SPEED * 0.85;
                    } else {
                        // SWEEPER KEEPER
                        // Top bizdeyse veya tehlike yoksa, defans arkasÄ±na aÃ§Ä±l
                        const sweepDist = teamHasBall ? 20 : 12;
                        targetX = isHome ? sweepDist : PITCH_LENGTH - sweepDist;
                        // Topun olduÄŸu kanada hafif kay
                        targetY = 34 + (ballY - 34) * 0.15;
                    }
                }

                // === INSTRUCTION: ROAM FROM POSITION (GÃœÃ‡LENDÄ°RÄ°LMÄ°Åž) ===
                // Serbest DolaÅŸ: Orta sahalar gizli forvet gibi Ã§alÄ±ÅŸÄ±r
                if (tactic.instructions && tactic.instructions.includes('RoamFromPosition')) {
                    // 1. Random Movement (Marktan kurtulma)
                    if (simP.state !== 'SPRINT' && !this.playerStates[p.id].isPressing) {
                        const roamX = (Math.random() - 0.5) * 8.0; // +/- 4.0m random (6â†’8)
                        const roamY = (Math.random() - 0.5) * 8.0;
                        targetX += roamX;
                        targetY += roamY;
                    }

                    // 2. GÄ°ZLÄ° FORVET SÄ°STEMÄ° (Shadow Striker / Box-to-Box)
                    // Orta sahalar son 1/3'e girdiÄŸinde forvetin yanÄ±na koÅŸar
                    if (teamHasBall && role === Position.MID && this.sim.ball.ownerId !== p.id) {
                        const isAttackingThird = isHome ? ballX > 60 : ballX < 45;

                        if (isAttackingThird) {
                            const posAttr = p.attributes.positioning || 50;
                            const staminaOk = (this.playerStates[p.id]?.currentStamina || 100) > 40;
                            // %4-6 olasÄ±lÄ±k (eski: %1-1.5) â€” Ã§ok daha sÄ±k koÅŸu!
                            const runProb = staminaOk ? 0.04 + ((posAttr / 5000)) : 0.005;

                            if (simP.state !== 'SPRINT' && Math.random() < runProb) {
                                // Forvetin yanÄ±na ama offsideline'Ä±n gerisinde
                                const onsideX = isHome ? offsideLineX - 3 : offsideLineX + 3;
                                const boxTargetX = isHome
                                    ? Math.min(PITCH_LENGTH - 14, onsideX)
                                    : Math.max(14, onsideX);

                                // Top hangi kanattaysa karÅŸÄ± tarafta boÅŸluk ara
                                let boxTargetY: number;
                                if (ballY < PITCH_CENTER_Y) {
                                    boxTargetY = PITCH_CENTER_Y + 8 + Math.random() * 6; // KarÅŸÄ± taraf
                                } else {
                                    boxTargetY = PITCH_CENTER_Y - 8 - Math.random() * 6;
                                }
                                boxTargetY = clamp(boxTargetY, 20, 48);

                                targetX = boxTargetX;
                                targetY = boxTargetY;

                                speedMod = MAX_PLAYER_SPEED * 0.95;
                                simP.state = 'SPRINT';

                                if (Math.random() < 0.3) this.emitTeamSignal(p, 'POINT');
                            }
                        }
                    }
                }

                targetY = clamp(targetY, 2, PITCH_WIDTH - 2);
                targetX = clamp(targetX, 0, PITCH_LENGTH);

            }
        }
        // === G MOTORU: AKILLI SÄ°NYAL SÄ°STEMÄ° (SMART SIGNALING) ===
        // Sadece rastgele deÄŸil, gerÃ§ekten boÅŸta olan istesin!
        const openness = this.calculateShotOpening(simP.x, simP.y, isHome ? PITCH_LENGTH : 0, isHome);
        const amIOpen = openness > 0.6; // Ã–nÃ¼m aÃ§Ä±ksa (bunu 0.5'ten 0.6'ya Ã§ektim)
        const myGoalX = isHome ? 0 : PITCH_LENGTH;
        const distToMyGoal = Math.abs(simP.x - myGoalX); // Kendi kaleme uzaklÄ±k -> Rakip kaleye yakÄ±nlÄ±k
        const distToEnemyGoal = PITCH_LENGTH - distToMyGoal;
        const isInGoodPosition = distToEnemyGoal < 30 || (distToEnemyGoal < 45 && role === Position.FWD);

        // POINT: KoÅŸu yoluna iste (Sprint atÄ±yorsam ve Ã¶nÃ¼m boÅŸsa)
        if (simP.state === 'SPRINT' && amIOpen && Math.random() < 0.08) {
            this.emitTeamSignal(p, 'POINT');
        }

        // CALL: AyaÄŸÄ±ma iste (Duruyorsam, tehlikeli bÃ¶lgedeysem ve boÅŸsam)
        else if (simP.state !== 'SPRINT' && isInGoodPosition && amIOpen && Math.random() < 0.05) {
            this.emitTeamSignal(p, 'CALL');
        }

        // HOLD: TakÄ±m arkadaÅŸÄ±m zorda ise "Sakin ol" de
        else if (teamHasBall && this.sim.ball.ownerId) {
            // Top taÅŸÄ±yan baskÄ±daysa
            const carrier = this.sim.players[this.sim.ball.ownerId];
            if (carrier) {
                // Basit bir mesafe kontrolÃ¼ (baskÄ± hesabÄ± karmaÅŸÄ±k, random yeterli)
                if (Math.random() < 0.02 && (role === Position.MID || role === Position.DEF)) {
                    this.emitTeamSignal(p, 'HOLD');
                }
            }
        }


        this.applySteeringBehavior(p, targetX, targetY, speedMod);
    }

    private isPartnerPressing(p: Player): boolean {
        const myTeamPlayers = p.teamId === this.homeTeam.id ? this.homePlayers : this.awayPlayers;
        return myTeamPlayers.some(tm =>
            tm.id !== p.id &&
            this.playerRoles[tm.id] === Position.DEF &&
            this.playerStates[tm.id]?.isPressing
        );
    }

    private isClosestTeammateToBall(p: Player): boolean {
        const myTeamPlayers = p.teamId === this.homeTeam.id ? this.homePlayers : this.awayPlayers;
        if (!this.sim.players[p.id]) return false;

        const myDist = dist(this.sim.players[p.id].x, this.sim.players[p.id].y, this.sim.ball.x, this.sim.ball.y);
        const myGoalX = p.teamId === this.homeTeam.id ? 0 : PITCH_LENGTH;
        const distToGoal = Math.abs(this.sim.ball.x - myGoalX);

        let closerCount = 0;

        for (const tm of myTeamPlayers) {
            if (tm.id === p.id) continue;
            if (tm.lineup !== 'STARTING') continue;
            if (!this.sim.players[tm.id]) continue;

            const tmX = this.sim.players[tm.id].x;
            const tmY = this.sim.players[tm.id].y;
            const ballX = this.sim.ball.x;
            const ballY = this.sim.ball.y;

            // GeÃ§ilmiÅŸ oyuncu kontrolÃ¼ - topun arkasÄ±ndaki oyuncuyu sayma
            const isTmBeaten = p.teamId === this.homeTeam.id ? (tmX > ballX + 2) : (tmX < ballX - 2);
            if (isTmBeaten) continue;

            let tmEffectiveDist = dist(tmX, tmY, ballX, ballY);

            // Zaten baskÄ± yapan oyuncu varsa, ona Ã¶ncelik ver
            if (this.playerStates[tm.id]?.isPressing) {
                tmEffectiveDist *= 0.7;
            }

            if (tmEffectiveDist < myDist) {
                closerCount++;
            }
        }

        // En yakÄ±n veya en yakÄ±n 2 kiÅŸiden biriysen true
        if (closerCount === 0) return true;

        // Tehlikeli bÃ¶lgedeyse 2 kiÅŸi baskÄ± yapabilir
        if (distToGoal < 35 && closerCount < 2) return true;

        return false;
    }

    private applySteeringBehavior(p: Player, tx: number, ty: number, maxSpeed: number) {
        const simP = this.sim.players[p.id];
        if (!simP) return; // Player was removed (red card)
        const state = this.playerStates[p.id];

        const dx = tx - simP.x;
        const dy = ty - simP.y;
        const distToTarget = Math.sqrt(dx * dx + dy * dy);

        let desiredVx = 0, desiredVy = 0;
        if (distToTarget > 0.5) {
            const speed = (distToTarget < 5) ? maxSpeed * (distToTarget / 5) : maxSpeed;
            desiredVx = (dx / distToTarget) * speed;
            desiredVy = (dy / distToTarget) * speed;
        }

        // === SEPARATION FORCE GÃœÃ‡LENDIRMESI (GEMÄ°NÄ° Ã–NERÄ°SÄ°) ===
        // AyrÄ±ÅŸma yarÄ±Ã§apÄ±: 2.0 -> 3.5 (Daha geniÅŸ kiÅŸisel alan)
        // Push strength: 0.5 -> 2.5 (5 kat gÃ¼Ã§lÃ¼ itme)
        const separateRadius = 3.5;
        let sepVx = 0, sepVy = 0;
        this.allPlayers.forEach(other => {
            if (other.id !== p.id && this.sim.players[other.id]) {
                const otherPos = this.sim.players[other.id];
                const d = dist(simP.x, simP.y, otherPos.x, otherPos.y);
                if (d < separateRadius && d > 0) {
                    const pushStr = (separateRadius - d) / d;
                    // 0.5 -> 2.5 (5 katÄ±na Ã§Ä±ktÄ±!)
                    sepVx += (simP.x - otherPos.x) * pushStr * 2.5;
                    sepVy += (simP.y - otherPos.y) * pushStr * 2.5;
                }
            }
        });

        const finalVx = desiredVx + sepVx;
        const finalVy = desiredVy + sepVy;

        const agility = (p.attributes.dribbling + (p.attributes.speed * 0.5)) / 150;
        const inertia = PLAYER_ACCELERATION * agility;

        simP.vx = lerp(simP.vx, finalVx, inertia);
        simP.vy = lerp(simP.vy, finalVy, inertia);

        const currentSpeed = Math.sqrt(simP.vx * simP.vx + simP.vy * simP.vy);

        // === MERKEZÄ° YORGUNLUK ETKÄ°SÄ° - HIZ ===
        const physicalMod = getFatigueModifier(state.currentStamina, 'physical');
        let staminaFactor = physicalMod;

        // 25% altÄ±nda sprint atamaz - sadece jog yapabilir
        if (state.currentStamina < 25) {
            staminaFactor = Math.min(staminaFactor, 0.55); // Max %55 hÄ±z
        }
        // 10% altÄ±nda yÃ¼rÃ¼mek bile zor
        if (state.currentStamina < 10) {
            staminaFactor = Math.min(staminaFactor, 0.40); // Max %40 hÄ±z
        }

        let speedPenalty = 1.0;
        if (p.id === this.sim.ball.ownerId) {
            const driSkill = p.attributes.dribbling || 50;
            // NERF v2: Top sÃ¼rerken daha yavaÅŸ ol (savunmacÄ±lar yetiÅŸsin)
            // Eski: 0.80 + dri/100 * 0.15 = 0.80-0.95 arasÄ±
            // Yeni: 0.72 + dri/100 * 0.13 = 0.72-0.85 arasÄ±
            speedPenalty = 0.72 + (driSkill / 100) * 0.13;
        }

        // MEANINGFUL SPEED FORMULA - Stats should matter!
        // Formula: 0.75 + speed/250
        let speedBonus = 0.75 + (p.attributes.speed / 250);

        // === YETENEK ETKÄ°LERÄ°: HIZ ===
        // "Seri" yeteneÄŸi: Sprint hÄ±zÄ± %8 bonus
        if (p.playStyles?.includes("Seri") || p.playStyles?.includes("Seri+")) {
            speedBonus *= 1.08;
        }
        // "Ã‡abuk AdÄ±m" yeteneÄŸi: Ä°vmelenme bonusu (inertia'da uygulanÄ±r, burada kÃ¼Ã§Ã¼k hÄ±z bonusu)
        if (p.playStyles?.includes("Ã‡abuk AdÄ±m") || p.playStyles?.includes("Ã‡abuk AdÄ±m+")) {
            speedBonus *= 1.04;
        }

        // Cap at 1.20x to prevent light-speed bug (raised from 1.15 for abilities)
        speedBonus = Math.min(speedBonus, 1.20);
        const physicalLimit = Math.min(maxSpeed, MAX_PLAYER_SPEED) * speedBonus * staminaFactor * speedPenalty;

        if (currentSpeed > 0.8) {
            const movementAngle = Math.atan2(simP.vy, simP.vx);
            const angleDiff = Math.abs(movementAngle - simP.facing);
            if (angleDiff > 1.5) {
                simP.vx *= 0.8;
                simP.vy *= 0.8;
            }
        }

        if (currentSpeed > physicalLimit) {
            simP.vx = (simP.vx / currentSpeed) * physicalLimit;
            simP.vy = (simP.vy / currentSpeed) * physicalLimit;
        }

        // STRICT HARD CAP - No player can EVER exceed MAX_PLAYER_SPEED
        // This is the absolute final safety check
        const ABSOLUTE_MAX = MAX_PLAYER_SPEED;
        const newSpeed = Math.sqrt(simP.vx * simP.vx + simP.vy * simP.vy);
        if (newSpeed > ABSOLUTE_MAX) {
            simP.vx = (simP.vx / newSpeed) * ABSOLUTE_MAX;
            simP.vy = (simP.vy / newSpeed) * ABSOLUTE_MAX;
        }

        simP.x = clamp(simP.x + simP.vx, 0, PITCH_LENGTH);
        simP.y = clamp(simP.y + simP.vy, 0, PITCH_WIDTH);

        // --- FACING LOGIC ---
        // If moving fast, face movement direction.
        // If slow/idle, FACE THE BALL to look at play.
        let targetAngle = simP.facing;

        if (currentSpeed > 0.3) {
            targetAngle = Math.atan2(simP.vy, simP.vx);
        } else {
            // Look at ball
            targetAngle = Math.atan2(this.sim.ball.y - simP.y, this.sim.ball.x - simP.x);
        }

        let angleDiff = targetAngle - simP.facing;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        simP.facing += angleDiff * PLAYER_TURN_SPEED;

        // --- MESAFE BAZLI YORGUNLUK SÄ°STEMÄ° ---
        // GerÃ§ek futbol verilerine gÃ¶re:
        // - Bir futbolcu 8-12 tam saha sprinti sonrasÄ± ciddi yorulur
        // - Jog ile 20-30 tam saha sonrasÄ± yorulur
        // - Saha = 105 metre (PITCH_LENGTH)

        const isSprinting = currentSpeed > MAX_PLAYER_SPEED * 0.75;
        const isRunning = currentSpeed > MAX_PLAYER_SPEED * 0.3;
        const isWalking = currentSpeed > MAX_PLAYER_SPEED * 0.1;

        // Her tick'te kat edilen mesafeyi hesapla ve kaydet
        // ARTIRILDI: Mesafe Ã§arpanlarÄ± yÃ¼kseltildi (daha hÄ±zlÄ± yorulma)
        const distanceThisTick = currentSpeed; // birim/tick

        if (isSprinting) {
            // Sprint mesafesi 1.3x Ã§arpanla kaydedilir (daha yorucu)
            state.sprintDistance = (state.sprintDistance || 0) + (distanceThisTick * 1.3);
        } else if (isRunning) {
            // KoÅŸu mesafesi 1.15x Ã§arpanla kaydedilir
            state.runDistance = (state.runDistance || 0) + (distanceThisTick * 1.15);
        }
        // YÃ¼rÃ¼yÃ¼ÅŸ ve durma mesafe olarak sayÄ±lmaz (yorgunluk yaratmaz)

        // === YORGUNLUK PUANI HESABI ===
        // FormÃ¼l: (sprint mesafesi Ã— 2.5) + (koÅŸu mesafesi Ã— 0.7)
        // ARTIRILDI: Ã‡arpanlar yÃ¼kseltildi
        const FIELD_LENGTH = PITCH_LENGTH; // metre = 1 tam saha
        const sprintFields = (state.sprintDistance || 0) / FIELD_LENGTH;
        const runFields = (state.runDistance || 0) / FIELD_LENGTH;

        // Yorgunluk puanÄ± (tam saha cinsinden) - ARTIRILMIÅž Ã‡ARPANLAR
        const fatigueScore = (sprintFields * 2.5) + (runFields * 0.7);

        // === STAMINA ATTRIBUTE ETKÄ°SÄ° ===
        // YÃ¼ksek dayanÄ±klÄ±lÄ±k = yorgunluk eÅŸiÄŸi yÃ¼kselir
        // BUFF: EÅŸikler artÄ±rÄ±ldÄ± (daha geÃ§ yorulma)
        // 50 stamina = 12 puan eÅŸik, 80 stamina = 15 puan eÅŸik, 99 stamina = 17 puan eÅŸik
        const staminaAttr = p.attributes?.stamina || 60;
        let fatigueThreshold = 7 + (staminaAttr / 10); // 7-17 arasÄ± eÅŸik (buff)

        // === YETENEK ETKÄ°SÄ°: AMANSIZ ===
        if (p.playStyles?.includes("AmansÄ±z") || p.playStyles?.includes("AmansÄ±z+")) {
            fatigueThreshold *= 1.35; // %35 daha fazla dayanÄ±r
        }

        // === STAMINA HESABI ===
        // fatigueScore 0 â†’ %100 stamina
        // fatigueScore = threshold â†’ %50 stamina (ciddi yorgunluk)
        // fatigueScore = threshold * 2 â†’ %0 stamina (bitkin)
        const fatigueRatio = fatigueScore / fatigueThreshold;
        let newStamina = 100 - (fatigueRatio * 50);

        // Durma/yÃ¼rÃ¼yÃ¼ÅŸ ile HAFIF dinlenme (ama mesafe sÄ±fÄ±rlanmaz!)
        if (!isSprinting && !isRunning) {
            // Dinlenirken Ã§ok yavaÅŸ toparlanma - AZALTILDI
            const recoveryRate = 0.005 + (staminaAttr / 12000); // 0.005-0.013 arasÄ±
            newStamina = Math.min(100, newStamina + recoveryRate);

            // AyrÄ±ca sprint/run distance Ã§ok yavaÅŸ azalÄ±r (laktik asit atÄ±lmasÄ±)
            if (state.sprintDistance > 0) {
                state.sprintDistance = Math.max(0, state.sprintDistance - 0.015);
            }
            if (state.runDistance > 0) {
                state.runDistance = Math.max(0, state.runDistance - 0.025);
            }
        }

        state.currentStamina = Math.max(0, Math.min(100, newStamina));

        // SYNC TO PUBLIC STATE for UI
        simP.stamina = state.currentStamina;
    }

    private resolveCollisions() {
        // === PERFORMANCE: Skip collision detection every other tick ===
        // Collision resolution is O(nÂ²) but doesn't need to run every tick
        // Players don't move fast enough for 1-tick gaps to matter
        if (this.tickCount % 2 !== 0) return;

        const players = this._cachedStarters.length > 0 ? this._cachedStarters : this.allPlayers;
        for (let i = 0; i < players.length; i++) {
            for (let j = i + 1; j < players.length; j++) {
                const p1 = this.sim.players[players[i].id];
                const p2 = this.sim.players[players[j].id];
                if (!p1 || !p2) continue;
                const dx = p1.x - p2.x; const dy = p1.y - p2.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                const minD = 1.0;

                if (d < minD && d > 0.01) {
                    const overlap = minD - d;
                    const nx = dx / d; const ny = dy / d;
                    p1.x += nx * overlap * 0.5; p1.y += ny * overlap * 0.5;
                    p2.x -= nx * overlap * 0.5; p2.y -= ny * overlap * 0.5;

                    const p1HasBall = (players[i].id === this.sim.ball.ownerId);
                    const p2HasBall = (players[j].id === this.sim.ball.ownerId);

                    if (p1HasBall) {
                        // === DRIBBLING SKILL GAP (p1) ===
                        const p1State = this.playerStates[players[i].id];
                        const p2State = this.playerStates[players[j].id];
                        const p1Dri = players[i].attributes.dribbling * (p1State?.currentStamina > 30 ? 1 : 0.8);
                        const p2Tac = players[j].attributes.tackling * (p2State?.currentStamina > 30 ? 1 : 0.8);
                        const diff = p1Dri - p2Tac;

                        if ((p1Dri > 80 && diff > 10) || players[i].playStyles?.includes("Top CambazÄ±")) {
                            p1.vx *= 0.75; p1.vy *= 0.75; // Less slowdown
                            if (p1State) p1State.actionLock = 4; // Faster recovery
                            if (p2State) p2State.actionLock = 12; // Defender stunned
                        } else {
                            p1.vx *= 0.5; p1.vy *= 0.5;
                            if (p1State) p1State.actionLock = 8;
                            this.lastTouchTeamId = players[j].teamId;
                        }
                    } else {
                        p1.vx *= 0.9; p1.vy *= 0.9;
                    }

                    // === VISUALS: COLLISION CUE ===
                    // Add "struggle" effect
                    (p1 as any).isCollided = true;
                    (p2 as any).isCollided = true;

                    if (p2HasBall) {
                        // === DRIBBLING SKILL GAP (p2) ===
                        const p2State = this.playerStates[players[j].id];
                        const p1State = this.playerStates[players[i].id];
                        const p2Dri = players[j].attributes.dribbling * (p2State?.currentStamina > 30 ? 1 : 0.8);
                        const p1Tac = players[i].attributes.tackling * (p1State?.currentStamina > 30 ? 1 : 0.8);
                        const diff = p2Dri - p1Tac;

                        if ((p2Dri > 80 && diff > 10) || players[j].playStyles?.includes("Top CambazÄ±")) {
                            p2.vx *= 0.75; p2.vy *= 0.75;
                            if (p2State) p2State.actionLock = 4;
                            if (p1State) p1State.actionLock = 12;
                        } else {
                            p2.vx *= 0.5; p2.vy *= 0.5;
                            if (p2State) p2State.actionLock = 8;
                            this.lastTouchTeamId = players[i].teamId;
                        }
                    } else {
                        p2.vx *= 0.9; p2.vy *= 0.9;
                    }
                }
            }
        }
    }

    private checkGameEvents(): MatchEvent | null {
        const b = this.sim.ball;
        const outLeft = b.x < 0;
        const outRight = b.x > PITCH_LENGTH;
        const outTop = b.y < 0;
        const outBottom = b.y > PITCH_WIDTH;

        // === THROW-IN: Ball out on sides ===
        if (outTop || outBottom) {
            // Determine which team gets throw-in (opposite of last touch)
            const lastTouchWasHome = this.lastTouchTeamId === this.homeTeam.id;
            const throwingTeamIsHome = !lastTouchWasHome;

            // Throw-in position - MUST be inside field to prevent infinite loop!
            const throwX = clamp(b.x, 5, PITCH_LENGTH - 5); // Keep within reasonable X range
            const throwY = outTop ? 2 : PITCH_WIDTH - 2; // Place ball INSIDE the field, not on edge!

            // Find closest non-GK player to throw position from throwing team
            const throwingTeamPlayers = (throwingTeamIsHome ? this.homePlayers : this.awayPlayers)
                .filter(p => p.lineup === 'STARTING' && this.playerRoles[p.id] !== Position.GK);

            const thrower = throwingTeamPlayers.sort((a, b) => {
                const distA = this.sim.players[a.id] ? dist(throwX, throwY, this.sim.players[a.id].x, this.sim.players[a.id].y) : 999;
                const distB = this.sim.players[b.id] ? dist(throwX, throwY, this.sim.players[b.id].x, this.sim.players[b.id].y) : 999;
                return distA - distB;
            })[0];

            if (thrower && this.sim.players[thrower.id]) {
                // Only move the thrower - DON'T reset everyone's positions!
                this.sim.players[thrower.id].x = throwX;
                this.sim.players[thrower.id].y = throwY;
                this.sim.players[thrower.id].vx = 0;
                this.sim.players[thrower.id].vy = 0;
                this.sim.ball.ownerId = thrower.id;
                this.sim.ball.x = throwX;
                this.sim.ball.y = throwY;
                this.sim.ball.vx = 0;
                this.sim.ball.vy = 0;
                this.sim.ball.vz = 0;
                if (this.playerStates[thrower.id]) {
                    this.playerStates[thrower.id].actionLock = 3;
                }
            }

            const throwingTeam = throwingTeamIsHome ? this.homeTeam : this.awayTeam;
            return {
                minute: this.internalMinute,
                type: MatchEventType.THROW_IN,
                description: `TaÃ§: ${throwingTeam.name}`,
                teamId: throwingTeam.id
            };
        }

        // === GOAL or OUT on goal line ===
        if (outLeft || outRight) {
            if (b.y > GOAL_Y_TOP && b.y < GOAL_Y_BOTTOM && b.z < 2.44) {
                // GOAL!
                if (outLeft) {
                    const scorerId = this.lastShooterId;
                    const scorer = scorerId ? this.getPlayer(scorerId) : null;
                    this.lastShooterId = null;
                    this.resetPositions('KICKOFF', this.homeTeam.id);
                    // Queue KICKOFF event after GOAL
                    this.pendingEvents.push({
                        minute: this.internalMinute,
                        type: MatchEventType.KICKOFF,
                        description: 'Santra',
                        teamId: this.homeTeam.id
                    });
                    this.match.awayScore++; // Update internal score state
                    return { minute: this.internalMinute, type: MatchEventType.GOAL, description: `GOL! ${scorer ? scorer.lastName : this.awayTeam.name}`, teamId: this.awayTeam.id, playerId: scorerId || undefined };
                }
                if (outRight) {
                    const scorerId = this.lastShooterId;
                    const scorer = scorerId ? this.getPlayer(scorerId) : null;
                    this.lastShooterId = null;
                    this.resetPositions('KICKOFF', this.awayTeam.id);
                    // Queue KICKOFF event after GOAL
                    this.pendingEvents.push({
                        minute: this.internalMinute,
                        type: MatchEventType.KICKOFF,
                        description: 'Santra',
                        teamId: this.awayTeam.id
                    });
                    this.match.homeScore++; // Update internal score state
                    return { minute: this.internalMinute, type: MatchEventType.GOAL, description: `GOL! ${scorer ? scorer.lastName : this.homeTeam.name}`, teamId: this.homeTeam.id, playerId: scorerId || undefined };
                }
            }
            else {
                // Corner or Goal Kick
                const isHomeGoalSide = outLeft;
                const lastTouchWasHome = this.lastTouchTeamId === this.homeTeam.id;


                if (isHomeGoalSide) {
                    // Ball out on HOME (left) goal side
                    if (lastTouchWasHome && this.lastTouchTeamId) {
                        // Last touch by HOME team = CORNER for AWAY team
                        const isTop = b.y < PITCH_CENTER_Y;
                        this.resetPositions(isTop ? 'CORNER_AWAY_TOP' : 'CORNER_AWAY_BOTTOM');
                        return { minute: this.internalMinute, type: MatchEventType.CORNER, description: `Korner: ${this.awayTeam.name}`, teamId: this.awayTeam.id };
                    } else {
                        // Last touch by AWAY team OR unknown = GOAL KICK for HOME team
                        const gk = this.homePlayers.find(p => this.playerRoles[p.id] === Position.GK && p.lineup === 'STARTING');
                        if (gk && this.sim.players[gk.id]) {
                            this.sim.players[gk.id].x = 5;
                            this.sim.players[gk.id].y = PITCH_CENTER_Y;
                            this.sim.ball.ownerId = gk.id;
                            this.sim.ball.x = 5;
                            this.sim.ball.y = PITCH_CENTER_Y;
                            this.sim.ball.vx = 0;
                            this.sim.ball.vy = 0;
                            this.sim.ball.vz = 0;
                            this.sim.ball.z = 0;
                            if (this.playerStates[gk.id]) {
                                this.playerStates[gk.id].actionLock = 5;
                            }
                        }
                    }
                } else {
                    // Ball out on AWAY (right) goal side
                    if (!lastTouchWasHome && this.lastTouchTeamId) {
                        // Last touch by AWAY team = CORNER for HOME team
                        const isTop = b.y < PITCH_CENTER_Y;
                        this.resetPositions(isTop ? 'CORNER_HOME_TOP' : 'CORNER_HOME_BOTTOM');
                        return { minute: this.internalMinute, type: MatchEventType.CORNER, description: `Korner: ${this.homeTeam.name}`, teamId: this.homeTeam.id };
                    } else {
                        // Last touch by HOME team OR unknown = GOAL KICK for AWAY team
                        const gk = this.awayPlayers.find(p => this.playerRoles[p.id] === Position.GK && p.lineup === 'STARTING');
                        if (gk && this.sim.players[gk.id]) {
                            this.sim.players[gk.id].x = PITCH_LENGTH - 5;
                            this.sim.players[gk.id].y = PITCH_CENTER_Y;
                            this.sim.ball.ownerId = gk.id;
                            this.sim.ball.x = PITCH_LENGTH - 5;
                            this.sim.ball.y = PITCH_CENTER_Y;
                            this.sim.ball.vx = 0;
                            this.sim.ball.vy = 0;
                            this.sim.ball.vz = 0;
                            this.sim.ball.z = 0;
                            if (this.playerStates[gk.id]) {
                                this.playerStates[gk.id].actionLock = 5;
                            }
                        }
                    }
                }
                return null;
            }
        }
        return null;
    }

    private getActionText(teamId: string | null): string {
        if (!teamId) return "Sahipsiz Top";
        const teamName = teamId === this.homeTeam.id ? this.homeTeam.name : this.awayTeam.name;
        if (this.sim.ball.x > 37 && this.sim.ball.x < 68) return `${teamName} Oyun Kuruyor`;
        if (this.sim.ball.x < 32) return (teamId === this.homeTeam.id) ? `${teamName} Savunmadan Ã‡Ä±kÄ±yor` : `${teamName} BaskÄ±da`;
        if (this.sim.ball.x > 73) return (teamId === this.homeTeam.id) ? `${teamName} Gol ArÄ±yor` : `${teamName} Savunmada`;
        return `${teamName} Topla Oynuyor`;
    }

    private actionPass(carrier: Player, target: Player, type: 'GROUND' | 'THROUGH' | 'AERIAL', targetOverrideX?: number, targetOverrideY?: number) {
        const cPos = this.sim.players[carrier.id];
        const tPos = this.sim.players[target.id];
        const state = this.playerStates[carrier.id];

        // === OFSAYT KONTROLÃœ ===
        // Pas hedefi ofsayt pozisyondaysa pasÄ± iptal et!
        // GK paslarÄ± ve geri paslar ofsayt olmaz
        const isHome = carrier.teamId === this.homeTeam.id;
        const offsideLineX = isHome ? this._awayDefLine : this._homeDefLine;
        if (offsideLineX !== undefined && target.position !== Position.GK) {
            const targetIsAhead = isHome
                ? tPos.x > offsideLineX + 1.0  // 1m tolerans
                : tPos.x < offsideLineX - 1.0;
            const carrierIsAhead = isHome
                ? cPos.x > offsideLineX
                : cPos.x < offsideLineX;
            // Ofsayt: hedef defans hattÄ±nÄ±n Ã¶tesinde VE pasÃ¶r hattÄ±n gerisinde (ileri pas)
            const isForwardPass = isHome ? tPos.x > cPos.x : tPos.x < cPos.x;
            if (targetIsAhead && !carrierIsAhead && isForwardPass) {
                // OFSAYT! PasÄ± iptal et, serbest vuruÅŸ ver
                this.sim.ball.ownerId = null;
                this.sim.ball.vx = 0;
                this.sim.ball.vy = 0;
                this.sim.ball.vz = 0;
                // Topu ofsayt noktasÄ±na koy
                this.sim.ball.x = tPos.x;
                this.sim.ball.y = tPos.y;
                this.traceLog.push(`ðŸš© OFSAYT! ${target.lastName} ofsayt pozisyonda â€” serbest vuruÅŸ!`);
                // Event oluÅŸtur
                this.pendingEvents.push({
                    minute: this.internalMinute,
                    type: MatchEventType.OFFSIDE,
                    description: `ðŸš© ${target.lastName} ofsayt! Serbest vuruÅŸ.`,
                    teamId: carrier.teamId,
                    playerId: target.id
                });
                // Rakip takÄ±ma serbest vuruÅŸ ver
                const enemyTeamPlayers = isHome ? this.awayPlayers : this.homePlayers;
                const nearestEnemy = enemyTeamPlayers
                    .filter(ep => ep.lineup === 'STARTING' && this.playerRoles[ep.id] === Position.DEF)
                    .sort((a, b) => dist(this.sim.players[a.id].x, this.sim.players[a.id].y, tPos.x, tPos.y) - dist(this.sim.players[b.id].x, this.sim.players[b.id].y, tPos.x, tPos.y))[0];
                if (nearestEnemy) {
                    this.sim.ball.ownerId = nearestEnemy.id;
                }
                this.playerStates[carrier.id].actionLock = 15;
                return; // PasÄ± iptal et
            }
        }

        // === YORGUNLUK DAHÄ°L GERÃ‡EK STATLAR ===
        const isGK = carrier.position === Position.GK;
        const fatigueMods = getAllFatigueModifiers(state.currentStamina, isGK);

        const pasStat = carrier.attributes.passing * fatigueMods.passing;
        const vision = carrier.attributes.vision * fatigueMods.vision;
        const composure = carrier.attributes.composure * fatigueMods.composure;
        const decisions = carrier.attributes.decisions * fatigueMods.decisions;

        let tx = targetOverrideX !== undefined ? targetOverrideX : tPos.x;
        let ty = targetOverrideY !== undefined ? targetOverrideY : tPos.y;

        // === YENÄ°: AKILLI PAS HEDEFLEMESÄ° (v2) ===
        // Topun varÄ±ÅŸ sÃ¼resini hesapla ve alÄ±cÄ±nÄ±n o sÃ¼rede nerede olacaÄŸÄ±nÄ± Ã¶ngÃ¶r
        if (targetOverrideX === undefined) {
            // Mesafeye gÃ¶re pas hÄ±zÄ±nÄ± tahmin et
            const initialDist = dist(cPos.x, cPos.y, tPos.x, tPos.y);

            // Tahmini pas hÄ±zÄ± (mesafeye baÄŸlÄ±)
            // AERIAL: Fizik bazlÄ± hesap â€” lob yÃ¼ksekliÄŸi ve air drag'a gÃ¶re
            // GROUND: 0.75x MAX_BALL_SPEED (~90 km/h)
            let estimatedPassSpeed: number;
            if (type === 'AERIAL') {
                // Fizik bazlÄ±: lobHeight â†’ airTime â†’ gereken yatay hÄ±z
                let estLobH = initialDist < 12 ? Math.min(1.5, 0.4 + initialDist * 0.07)
                    : initialDist < 30 ? Math.min(2.2, 0.7 + initialDist * 0.035)
                        : Math.min(3.0, 0.9 + initialDist * 0.03);
                const estAirTime = 2 * estLobH / GRAVITY;
                const estDragSum = (1 - Math.pow(BALL_AIR_DRAG, estAirTime)) / (1 - BALL_AIR_DRAG);
                estimatedPassSpeed = estDragSum > 0.1 ? initialDist / estDragSum : 1.0;
            } else {
                estimatedPassSpeed = Math.min(MAX_BALL_SPEED * 0.75, 1.5 + (initialDist * 0.04));
            }

            // Topun varÄ±ÅŸ sÃ¼resi (tick cinsinden)
            const travelTime = estimatedPassSpeed > 0.1 ? initialDist / estimatedPassSpeed : 5;

            // AlÄ±cÄ±nÄ±n hÄ±zÄ±
            const receiverSpeed = Math.sqrt((tPos.vx || 0) ** 2 + (tPos.vy || 0) ** 2);

            if (type === 'THROUGH') {
                // THROUGH BALL: AlÄ±cÄ±nÄ±n koÅŸacaÄŸÄ± yere hedefle
                // Vision etkisi: YÃ¼ksek vision = daha iyi Ã¶ngÃ¶rÃ¼
                const visionFactor = Math.min(1.5, vision / 60);

                // AlÄ±cÄ±nÄ±n gelecek pozisyonu = ÅŸimdiki pozisyon + hÄ±z Ã— sÃ¼re
                const leadFactor = travelTime * visionFactor;
                tx = tPos.x + (tPos.vx || 0) * leadFactor;
                ty = tPos.y + (tPos.vy || 0) * leadFactor;
            } else {
                // GROUND/NORMAL PAS: Hafif lead, ama Ã§ok deÄŸil
                // AlÄ±cÄ± hareket ediyorsa biraz Ã¶nÃ¼ne at
                if (receiverSpeed > 0.3) {
                    const leadFactor = Math.min(travelTime * 0.6, 8); // Max 8 tick lead
                    tx = tPos.x + (tPos.vx || 0) * leadFactor;
                    ty = tPos.y + (tPos.vy || 0) * leadFactor;
                } else {
                    // AlÄ±cÄ± duruyor - direkt ona at
                    tx = tPos.x;
                    ty = tPos.y;
                }
            }
        }

        // === PAS HATA PAYI (ERROR MARGIN) - YENÄ°! ===
        const teamTactic = isHome ? this.homeTeam.tactic : this.awayTeam.tactic;

        // 1. Baz Hata (Yetenek ve Yorgunluk Etkili)
        // Pas 100 -> 0.2m sapma, Pas 50 -> 1.5m sapma
        let targetErrorBase = Math.max(0.2, (100 - pasStat) / 33.3);

        // 2. Stil Ã‡arpanÄ± (Risk FaktÃ¶rÃ¼)
        let styleMod = 1.0;
        if (teamTactic.passingStyle === 'Short') styleMod = 0.5;      // Ã‡ok isabetli
        else if (teamTactic.passingStyle === 'Mixed') styleMod = 1.0; // Normal
        else if (teamTactic.passingStyle === 'Direct') styleMod = 1.4;// Biraz riskli
        else if (teamTactic.passingStyle === 'LongBall') styleMod = 2.0; // Ã‡ok riskli

        // 3. Mesafe Ã‡arpanÄ± (UzaklaÅŸtÄ±kÃ§a sapma artar)
        // KÄ±sa paslarda hata az, uzun paslarda logaritmik artar
        const passDistCalc = dist(cPos.x, cPos.y, tx, ty);
        const distMod = Math.max(1.0, passDistCalc / 25.0);

        // 4. Nihai Hata
        const targetErrorTotal = targetErrorBase * styleMod * distMod;

        // Hedefe rastgele sapma ekle (Gaussian benzeri)
        const errorX = (Math.random() - 0.5 + Math.random() - 0.5) * targetErrorTotal;
        const errorY = (Math.random() - 0.5 + Math.random() - 0.5) * targetErrorTotal;

        // Hata uygulanmÄ±ÅŸ hedef (Saha sÄ±nÄ±rlarÄ± iÃ§inde kalmalÄ±)
        tx = clamp(tx + errorX, 1, PITCH_LENGTH - 1);
        ty = clamp(ty + errorY, 1, PITCH_WIDTH - 1);

        const dx = tx - cPos.x; const dy = ty - cPos.y;
        const angle = Math.atan2(dy, dx);
        const distToT = Math.sqrt(dx * dx + dy * dy);

        // === PAS HATASI (BALANCED v3) ===
        // ESKÄ° v2: 0.04 base + 0.008 multiplier = Ã§ok fazla hata, paslar kesiliyordu
        // YENÄ° v3: 0.02 base + 0.006 multiplier = daha dengeli
        // pas 80 iÃ§in: 0.02 + (20 * 0.006) = 0.14 radyan (~8 derece)
        const baseError = 0.02; // AzaltÄ±ldÄ±: 0.04 â†’ 0.02
        let errorMargin = baseError + ((100 - pasStat) * 0.006); // AzaltÄ±ldÄ±: 0.008 â†’ 0.006

        // Composure: BaskÄ± altÄ±nda pas kalitesi
        errorMargin *= (1 + (1 - composure / 100) * 0.3); // 0.4â†’0.3 (eski deÄŸer)

        // Decisions: KÃ¶tÃ¼ karar = yanlÄ±ÅŸ yere pas
        errorMargin *= (1 + (1 - decisions / 100) * 0.2); // 0.3â†’0.2 (eski deÄŸer)

        // MESAFE BAZLI HATA: Uzun paslar daha hatalÄ±
        if (distToT > 30) errorMargin *= 1.15; // 25â†’30, 1.2â†’1.15
        if (distToT > 40) errorMargin *= 1.10; // 35â†’40, 1.15â†’1.10

        // === YETENEK ETKÄ°SÄ°: KESKÄ°N PAS ===
        // "Keskin Pas" yeteneÄŸi: Through ball isabeti %25 artar
        if (type === 'THROUGH' && (carrier.playStyles?.includes("Keskin Pas") || carrier.playStyles?.includes("Keskin Pas+"))) {
            errorMargin *= 0.75;
        }

        // === YETENEK ETKÄ°SÄ°: UZUN TOPLA PAS ===
        // "Uzun Topla Pas" yeteneÄŸi: Havadan pas isabeti %30 artar
        if (type === 'AERIAL' && (carrier.playStyles?.includes("Uzun Topla Pas") || carrier.playStyles?.includes("Uzun Topla Pas+"))) {
            errorMargin *= 0.70;
        }

        const finalAngle = angle + (Math.random() * errorMargin - errorMargin / 2);

        // FIXED AERIAL PASS POWER - Was overshooting targets!
        // Strength etkisi: Yorgun oyuncu uzun pas atamaz
        let power: number;
        const strengthMod = fatigueMods.strength;
        if (type === 'AERIAL') {
            // === FÄ°ZÄ°K BAZLI AERIAL PAS (v3 - DOÄžRU HESAP) ===
            // Sorun: Eski formÃ¼l air drag ve gravity'yi hesaba katmÄ±yordu
            // Top 50m'ye atÄ±lmak istenirken 71m gidiyordu (%40 overshoot!)
            // Ã‡Ã¶zÃ¼m: Topun havada kalma sÃ¼resini hesapla, sonra gereken yatay hÄ±zÄ± bul

            // 1. LOB YÃœKSEKLÄ°ÄžÄ° (vz) â€” mesafeye gÃ¶re ark yÃ¼ksekliÄŸi
            let lobHeight: number;
            if (distToT < 12) {
                // Chip pass: AlÃ§ak, zarif ark
                lobHeight = Math.min(1.5, 0.4 + (distToT * 0.07)) * strengthMod;
            } else if (distToT < 30) {
                // Normal orta: Orta yÃ¼kseklik
                lobHeight = Math.min(2.2, 0.7 + (distToT * 0.035)) * strengthMod;
            } else {
                // Uzun top: YÃ¼ksek ark
                lobHeight = Math.min(3.0, 0.9 + (distToT * 0.03)) * strengthMod;
            }

            // 2. HAVADA KALMA SÃœRESÄ° â€” yerÃ§ekimi ile hesap (tick cinsinden)
            // vz her tick GRAVITY (0.20) kadar azalÄ±r
            // Zirve sÃ¼resi = lobHeight / GRAVITY
            // Toplam uÃ§uÅŸ = 2 * zirve (yukarÄ± + aÅŸaÄŸÄ±)
            const airTime = 2 * lobHeight / GRAVITY;

            // 3. GEREKEN YATAY HIZ â€” air drag dahil
            // Her tick: vx *= BALL_AIR_DRAG (0.98)
            // Toplam mesafe = vx0 * (1 - drag^airTime) / (1 - drag)
            // => vx0 = distToT * (1 - drag) / (1 - drag^airTime)
            const drag = BALL_AIR_DRAG;
            const dragSum = (1 - Math.pow(drag, airTime)) / (1 - drag);

            // GÃ¼venlik: dragSum 0 olmasÄ±n
            if (dragSum > 0.1) {
                // FIXED: Power calculation now accounts for drag applied BEFORE movement (v3.1)
                // Physics engine: vx *= drag; x += vx;
                // So first tick moves (power * drag), not power.
                power = (distToT / dragSum / drag) * strengthMod;
            } else {
                power = distToT * 0.05 * strengthMod; // Fallback
            }

            // Clamp: Ã‡ok yÃ¼ksek gÃ¼Ã§ olmasÄ±n
            power = Math.min(MAX_BALL_SPEED * 0.65, power);
            // Minimum: Ã‡ok dÃ¼ÅŸÃ¼k gÃ¼Ã§ de olmasÄ±n
            power = Math.max(0.5, power);

            // === LOB'U UYGULA ===
            this.sim.ball.vz = lobHeight;
            this.sim.ball.curve = 0;

            // Trace log
            if (distToT < 12) {
                this.traceLog.push(`${carrier.lastName} zarif bir aÅŸÄ±rtma pas attÄ±!`);
            } else if (distToT < 30) {
                this.traceLog.push(`${carrier.lastName} havadan pas attÄ±!`);
            } else {
                this.traceLog.push(`${carrier.lastName} uzun bir havadan pas gÃ¶nderdi!`);
            }
        } else {
            power = Math.min(MAX_BALL_SPEED * 0.75, 1.5 + (distToT * 0.04)) * strengthMod;
        }

        this.sim.ball.ownerId = null;
        // === RECEIVER AWARENESS ===
        // Topa hedef atÄ±yoruz ki alÄ±cÄ± topun kendisine geldiÄŸini anlasÄ±n
        (this.sim.ball as any).targetId = target.id;
        this.sim.ball.x = cPos.x + Math.cos(finalAngle) * 1.5;
        this.sim.ball.y = cPos.y + Math.sin(finalAngle) * 1.5;
        this.sim.ball.vx = Math.cos(finalAngle) * power;
        this.sim.ball.vy = Math.sin(finalAngle) * power;

        if (type !== 'AERIAL') {
            // Ground/Through pass: z ekseni yok
            this.sim.ball.vz = 0;
            this.sim.ball.curve = 0;
        }
        // AERIAL tipi iÃ§in vz ve curve yukarÄ±da zaten set edildi

        this.playerStates[carrier.id].possessionCooldown = 12;
        // SPEED GLITCH FIX: Passer Lockout
        // Prevent passer from immediately chasing their own ball
        this.playerStates[carrier.id].actionLock = 8;

        this.sim.players[carrier.id].state = 'KICK';

        this.lastTouchTeamId = carrier.teamId;

        // === G MOTORU: VER-KAÃ‡ (PASS & MOVE) ===
        // PasÄ± atan oyuncu (GK hariÃ§) pasÄ± attÄ±ktan sonra durmasÄ±n, ileri koÅŸsun!
        const isAttackingRole = this.playerRoles[carrier.id] !== Position.DEF && this.playerRoles[carrier.id] !== Position.GK;
        const tacticName = carrier.teamId === this.homeTeam.id ? this.homeTeam.tactic.style : this.awayTeam.tactic.style;
        const isDefensiveTactic = tacticName === 'Defensive' || tacticName === 'ParkTheBus';

        // EÄŸer defansif oynamÄ±yorsak ve oyuncu hÃ¼cumcuysa, pasÄ± at ve koÅŸ!
        if (isAttackingRole && !isDefensiveTactic) {
            // HÄ±zlÄ± bir depar (Ver-KaÃ§)
            this.playerStates[carrier.id].supportRunUntil = this.tickCount + 120; // 2 saniye boyunca ileri koÅŸ

            // Ver-KaÃ§ yaparken elini kaldÄ±rÄ±p "Ã¶nÃ¼me at" desin (POINT)
            if (Math.random() < 0.4) {
                this.emitTeamSignal(carrier, 'POINT', target.id);
            }
        }

        const typeText = type === 'THROUGH' ? "Ara pasÄ±" : (type === 'AERIAL' ? "Havadan pas" : "Pas");
        this.traceLog.push(`${carrier.lastName} ${typeText} denedi.`);
    }

    private actionShoot(p: Player, isHome: boolean) {
        const pos = this.sim.players[p.id];
        const goalX = isHome ? PITCH_LENGTH : 0;
        const goalY = PITCH_CENTER_Y;
        const state = this.playerStates[p.id];

        // === YORGUNLUK DAHÄ°L GERÃ‡EK STATLAR ===
        const isGK = p.position === Position.GK;
        const fatigueMods = getAllFatigueModifiers(state.currentStamina, isGK);

        const fin = p.attributes.finishing * fatigueMods.finishing;
        const pwr = p.attributes.strength * fatigueMods.strength;
        const composure = p.attributes.composure * fatigueMods.composure;
        // Decisions impact spread
        const decisions = p.attributes.decisions * fatigueMods.decisions;

        // === DEBUG LOG ===
        // console.log(`ðŸŽ¯ ÅžUT: ${p.lastName} | Fin: ${fin.toFixed(1)}`);

        const distToGoal = dist(pos.x, pos.y, goalX, PITCH_CENTER_Y);

        // === xG HESABI (BUFF v2: Bitiricilerin Etkisi Artirildi) ===
        const baseXG = Math.max(0.02, (0.60 - (distToGoal / 65)));  // 70 -> 65: Biraz daha comert xG
        // finishingMod: Yuksek finishing'in etkisi artirildi
        // Eski: 0.5 + (fin/100)*0.7 -> fin80=1.06, fin90=1.13
        // Yeni: 0.4 + (fin/100)*0.85 -> fin80=1.08, fin90=1.165
        const finishingMod = 0.4 + (fin / 100) * 0.85;
        const xGValue = baseXG * finishingMod;

        // Stat Update
        if (isHome) {
            this.match.stats.homeShots++;
            this.match.stats.homeXG += xGValue;
        } else {
            this.match.stats.awayShots++;
            this.match.stats.awayXG += xGValue;
        }

        const enemyPlayers = isHome ? this.awayPlayers : this.homePlayers;
        const gk = enemyPlayers.find(ep => this.playerRoles[ep.id] === Position.GK);
        let targetY = goalY;

        // Composure etkisi: Target selection modification
        const confidence = ((fin - 50) / 50) * (composure / 100);
        const cornerBias = Math.max(0.45, confidence);

        // Corner bias will be modified by 1v1 logic below (after accuracyPenalty is declared)
        let finalCornerBias = cornerBias;

        if (gk && this.sim.players[gk.id]) {
            // targetY will be recalculated after 1v1 check below
            const gkY = this.sim.players[gk.id].y;
            if (gkY > PITCH_CENTER_Y) targetY = lerp(PITCH_CENTER_Y, GOAL_Y_TOP + 1, cornerBias);
            else targetY = lerp(PITCH_CENTER_Y, GOAL_Y_BOTTOM - 1, cornerBias);
        } else {
            targetY = PITCH_CENTER_Y;
        }

        let dy = targetY - pos.y;
        const dx = goalX - pos.x;
        let angle = Math.atan2(dy, dx);

        let accuracyPenalty = 0;
        const currentSpeed = Math.sqrt(this.sim.players[p.id].vx ** 2 + this.sim.players[p.id].vy ** 2);

        if (currentSpeed > MAX_PLAYER_SPEED * 0.5) accuracyPenalty += 0.15;
        if (currentSpeed > MAX_PLAYER_SPEED * 0.9) accuracyPenalty += 0.25;

        // === 1v1 FORVET KÃ–ÅžE BONUSU ===
        // Forvet 1v1'de kalecinin ters kÃ¶ÅŸesine plase atma yeteneÄŸi
        const is1v1Situation = distToGoal < 18 && this.calculateShotOpening(pos.x, pos.y, goalX, isHome) > 0.4;
        const isForwardShooter = this.playerRoles[p.id] === Position.FWD;

        if (is1v1Situation && isForwardShooter) {
            // Forvetler 1v1'de daha iyi kÃ¶ÅŸeye yerleÅŸtirir
            finalCornerBias = Math.min(0.95, cornerBias + 0.15 + (composure / 300));
            accuracyPenalty -= 0.08; // Daha isabetli
        } else if (is1v1Situation) {
            finalCornerBias = Math.min(0.9, cornerBias + 0.08);
        }

        // Recalculate targetY with final corner bias (1v1 bonus dahil)
        if (gk && this.sim.players[gk.id]) {
            const gkY = this.sim.players[gk.id].y;
            if (gkY > PITCH_CENTER_Y) targetY = lerp(PITCH_CENTER_Y, GOAL_Y_TOP + 1, finalCornerBias);
            else targetY = lerp(PITCH_CENTER_Y, GOAL_Y_BOTTOM - 1, finalCornerBias);
            // Recalculate angle with updated targetY
            dy = targetY - pos.y;
            angle = Math.atan2(dy, dx);
        }

        // === SPECIAL SHOT TYPES ===
        let shotType = 'NORMAL';
        let traceText = `${p.lastName} ÅŸut Ã§ekti!`;
        const ballZ = this.sim.ball.z || 0;

        // 0. FREE KICK DETECTION (Serbest VuruÅŸ)
        // Duran top ve baskÄ± yoksa serbest vuruÅŸ olabilir
        const isStationary = Math.abs(this.sim.players[p.id].vx) < 0.1 && Math.abs(this.sim.players[p.id].vy) < 0.1;
        const nearbyEnemies = enemyPlayers.filter(e => {
            const ePos = this.sim.players[e.id];
            return ePos && dist(ePos.x, ePos.y, pos.x, pos.y) < 8;
        });
        const isFreeKickShot = isStationary && nearbyEnemies.length === 0 && distToGoal > 18 && distToGoal < 35;

        if (isFreeKickShot) { // isFreeKickSituation removed
            shotType = 'FREE_KICK';
            const hasCurve = p.playStyles?.includes("Plase Åžut") || p.playStyles?.includes("Plase Åžut+");
            const hasDeadBall = p.playStyles?.includes("Ã–lÃ¼ Top UzmanÄ±") || p.playStyles?.includes("Ã–lÃ¼ Top UzmanÄ±+");

            if (hasDeadBall || hasCurve) {
                traceText = `ðŸŽ¯ ${p.lastName} frikik ÅŸutu! (KÄ±vrÄ±mlÄ±)`;
                accuracyPenalty -= 0.1; // Uzman bonus
            } else {
                traceText = `âš½ ${p.lastName} frikik ÅŸutu!`;
            }
        }
        // 1. VOLLEY / BICYCLE KICK
        else if (ballZ > 0.6) {
            if (ballZ > 1.4 && (p.playStyles?.includes("Akrobatik") || p.playStyles?.includes("Akrobatik+"))) {
                shotType = 'BICYCLE';
                traceText = `ðŸš² ${p.lastName} RÃ–VEÅžATA DENEDÄ°!`;
                accuracyPenalty += 0.3; // Hard
            } else {
                shotType = 'VOLLEY';
                traceText = `ðŸš€ ${p.lastName} geliÅŸine vurdu!`;
                accuracyPenalty += 0.15;
            }

            // === VISUALS: ACROBATIC SHOT ===
            // Pass to frontend for emoji animation
            if (this.sim.players[p.id]) {
                (this.sim.players[p.id] as any).shotType = shotType;
                if (this.playerStates[p.id]) {
                    (this.playerStates[p.id] as any).shotTypeExpiry = this.tickCount + 45; // ~0.75s display
                }
            }
        }

        // 2. CHIP SHOT (AÅŸÄ±rtma) - Kaleci Ã¶ndeyse
        // FRIKIK HARÄ°Ã‡ - Frikiklerde aÅŸÄ±rtma olmaz
        const isFreeKick = this.sim.mode === 'FREE_KICK_HOME' || this.sim.mode === 'FREE_KICK_AWAY';
        if (!isFreeKick && distToGoal < 25 && distToGoal > 5) {
            // Kaleci kaleden aÃ§Ä±lmÄ±ÅŸ mÄ±?
            const gkId = isHome ? this.awayPlayers.find(p => p.position === Position.GK)?.id : this.homePlayers.find(p => p.position === Position.GK)?.id;
            if (gkId && this.sim.players[gkId]) {
                const gkPos = this.sim.players[gkId];
                const gkDistFromLine = Math.abs(gkPos.x - goalX); // 0 veya 105'ten uzaklÄ±k

                // Kaleci 4 metreden fazla aÃ§Ä±lmÄ±ÅŸsa aÅŸÄ±rtma dene
                if (gkDistFromLine > 4.0) {
                    const flairBonus = (p.attributes.vision || 50) > 70 ? 20 : 0;
                    // Yetenekli oyuncular daha sÄ±k dener
                    if (Math.random() * 100 < (5 + flairBonus)) {
                        shotType = 'CHIP';
                        traceText = `âœ¨ ${p.lastName} kalecinin Ã¼stÃ¼nden aÅŸÄ±rtÄ±yor!`;
                    }
                }
            }
        }

        // === ACCURACY & SPREAD (BUFF v2: Ä°yi Bitiriciler Daha Ä°sabetli) ===
        let baseSpread: number;
        if (fin >= 95) baseSpread = 0.03 + (100 - fin) * 0.003;       // 0.04â†’0.03: Elit bitiriciler
        else if (fin >= 85) baseSpread = 0.06 + (95 - fin) * 0.003;   // 0.08â†’0.06: Ã‡ok iyi bitiriciler
        else if (fin >= 70) baseSpread = 0.12 + (85 - fin) * 0.005;   // 0.14â†’0.12: Ä°yi bitiriciler
        else if (fin >= 50) baseSpread = 0.23 + (70 - fin) * 0.008;
        else baseSpread = 0.38 + (50 - fin) * 0.012;

        let spread = baseSpread + accuracyPenalty;

        // Pressure Effect
        let pressureMod = 1.0;
        const defendingPlayers = isHome ? this.awayPlayers : this.homePlayers;
        const nearbyDefenders = defendingPlayers.filter(e => {
            const ePos = this.sim.players[e.id];
            return ePos && dist(ePos.x, ePos.y, pos.x, pos.y) < 4.0;
        });

        if (nearbyDefenders.length > 0) {
            const pressureResist = (p.personality?.pressureHandling || 0.5);
            const impact = 1.0 - (pressureResist * 0.6);
            pressureMod += (nearbyDefenders.length * 0.30 * impact);
        }
        spread *= pressureMod;

        // Distance Penalty
        if (distToGoal > 25) {
            const extraDist = distToGoal - 25;
            spread *= (1.0 + (extraDist * 0.035));
        }

        // Fatigue Decision Impact
        spread *= (1 + (1 - fatigueMods.decisions) * 0.4);

        // Shot Speed
        let shotSpeed = 2.8 + (pwr / 70);
        shotSpeed *= fatigueMods.speed;

        // === Ã–LÃœMCÃœL BÃ–LGE BONUSU (Death Zone: Kale Ã–nÃ¼nde 15m) ===
        if (distToGoal < 15) {
            shotSpeed *= 1.20;
            spread *= 0.70;
        }

        // Playstyle Effects on Shot
        if (p.playStyles?.includes("Plase Åžut")) {
            spread *= 0.75;
            shotSpeed *= 0.90;
        }
        if (p.playStyles?.includes("Kuvvetli Åžut")) {
            shotSpeed *= 1.25;
            spread *= 1.15;
        }
        if (shotType === 'BICYCLE') {
            shotSpeed *= 1.1;
            spread *= 1.5;
        }
        // === PENALTI Ã–ZEL FÄ°ZÄ°K ===
        const isPenaltyShot = this.sim.mode === 'PENALTY_HOME' || this.sim.mode === 'PENALTY_AWAY';
        if (isPenaltyShot) {
            spread *= 0.40;    // %60 daha isabetli (11m, duran top)
            accuracyPenalty = 0; // HÄ±z penaltÄ±sÄ± yok (duran top)
            shotSpeed = 4.0 + (pwr / 100) * 1.5; // Sabit gÃ¼Ã§lÃ¼ ÅŸut (4.0-5.5)
            // KÃ¶ÅŸeye plase: GK'nÄ±n ters tarafÄ±na
            if (gk && this.sim.players[gk.id]) {
                const gkY = this.sim.players[gk.id].y;
                // Kalecinin durduÄŸu tarafa gÃ¶re ters kÃ¶ÅŸeyi hedefle
                if (gkY > PITCH_CENTER_Y) {
                    targetY = GOAL_Y_TOP + 1.5; // Alt kÃ¶ÅŸe
                } else {
                    targetY = GOAL_Y_BOTTOM - 1.5; // Ãœst kÃ¶ÅŸe
                }
                dy = targetY - pos.y;
                angle = Math.atan2(dy, dx);
            }
        }
        if (shotType === 'CHIP') {
            shotSpeed *= 0.55; // Slower for better arc
            spread *= 0.8;
        }
        // === SERBEST VURUÅž Ã–ZEL FÄ°ZÄ°K (GÃœNCELLENDÄ°) ===
        if (shotType === 'FREE_KICK') {
            const hasCurve = p.playStyles?.includes("Plase Åžut") || p.playStyles?.includes("Plase Åžut+");
            const hasDeadBall = p.playStyles?.includes("Ã–lÃ¼ Top UzmanÄ±") || p.playStyles?.includes("Ã–lÃ¼ Top UzmanÄ±+");

            if (hasDeadBall) spread *= 0.60; // More accurate
            else if (hasCurve) spread *= 0.70;
            else spread *= 0.85;

            shotSpeed *= 0.90; // Controlled speed
        }

        const shotAngle = angle + (Math.random() * spread - spread / 2);

        // Target Check
        const finalYAtGoal = pos.y + (goalX - pos.x) * Math.tan(shotAngle);
        const isOnTarget = finalYAtGoal > GOAL_Y_TOP && finalYAtGoal < GOAL_Y_BOTTOM;
        if (isOnTarget) {
            if (isHome) this.match.stats.homeOnTarget++;
            else this.match.stats.awayOnTarget++;
        }

        // === BARAJ VE BLOKLAMA MANTIÄžI ===
        // Serbest vuruÅŸlarda topun barajÄ± aÅŸmasÄ± artÄ±k daha olasÄ±
        const enemies = (isHome ? this.awayPlayers : this.homePlayers).filter(e => e.lineup === 'STARTING');

        if (shotType === 'FREE_KICK') {
            const WALL_DISTANCE = 9;
            let wallBlocked = false;

            for (const e of enemies) {
                const ePos = this.sim.players[e.id];
                if (!ePos || this.playerRoles[e.id] === Position.GK) continue;

                const d = dist(pos.x, pos.y, ePos.x, ePos.y);

                if (d >= 7 && d <= 13) {
                    const angleToE = Math.atan2(ePos.y - pos.y, ePos.x - pos.x);
                    const angleDiff = Math.abs(angleToE - shotAngle);

                    if (angleDiff < 0.25) {
                        const timeToWall = d / shotSpeed;
                        // TUNE: Daha yÃ¼ksek kavis, barajÄ± geÃ§me ÅŸansÄ± artÄ±rÄ±ldÄ±
                        const ballHeightAtWall = (this.sim.ball.vz || 2.0) * timeToWall - 0.5 * GRAVITY * timeToWall * timeToWall;

                        const wallJumpHeight = 1.8 + ((e.attributes.strength || 50) / 100) * 0.5;

                        if (ballHeightAtWall < wallJumpHeight) {
                            // BLOK!
                            const blockRoll = Math.random();
                            const blockChance = 0.5; // Slightly reduced from 0.6

                            if (blockRoll < blockChance) {
                                this.traceLog.push(`ðŸ§± ${e.lastName} barajda engelledi!`);
                                this.sim.ball.ownerId = null;
                                this.sim.ball.vx = (Math.random() - 0.5) * 1.5;
                                this.sim.ball.vy = (Math.random() - 0.5) * 1.5;
                                this.sim.ball.vz = 0.5;
                                this.playerStates[p.id].possessionCooldown = 20;
                                this.lastTouchTeamId = e.teamId;
                                wallBlocked = true;
                                break;
                            }
                        }
                        else {
                            this.traceLog.push(`Top barajÄ±n Ã¼stÃ¼nden ÅŸÄ±k bir kavisle geÃ§ti!`);
                        }
                    }
                }
            }
            if (wallBlocked) return;
        }
        else {
            // Standard block logic
            for (const e of enemies) {
                const ePos = this.sim.players[e.id];
                if (!ePos || this.playerRoles[e.id] === Position.GK) continue;

                const d = dist(pos.x, pos.y, ePos.x, ePos.y);
                if (d < 3) {
                    const angleToE = Math.atan2(ePos.y - pos.y, ePos.x - pos.x);
                    if (Math.abs(angleToE - shotAngle) < 0.4) {
                        let blockChance = 0.4;
                        if (e.playStyles?.includes("Engel")) blockChance += 0.3;

                        if (Math.random() < blockChance) {
                            this.traceLog.push(`${e.lastName} ÅŸutu blokladÄ±!`);
                            this.sim.ball.ownerId = null;
                            this.sim.ball.vx = (Math.random() - 0.5) * 2;
                            this.sim.ball.vy = (Math.random() - 0.5) * 2;
                            this.playerStates[p.id].possessionCooldown = 20;
                            this.lastTouchTeamId = e.teamId;
                            return;
                        }
                    }
                }
            }
        }

        // EXECUTE SHOT
        this.sim.ball.ownerId = null;
        this.sim.ball.vx = Math.cos(shotAngle) * shotSpeed;
        this.sim.ball.vy = Math.sin(shotAngle) * shotSpeed;

        // Z-Axis Physics (AERIAL TUNING)
        let baseVz = 0.5 + (Math.random() * 0.5); // VarsayÄ±lan: Yerden/hafif seken

        // FRIKIK Ä°Ã‡Ä°N VZ ARTIRIMI
        const isFreeKickShotMode = this.sim.mode === 'FREE_KICK_HOME' || this.sim.mode === 'FREE_KICK_AWAY';
        if (isFreeKickShotMode) {
            // BarajÄ± (2.0m boy) geÃ§mek iÃ§in en az 2.5-3.0 vz lazÄ±m
            // Mesafeye gÃ¶re ayarla: Uzaksa daha dik, yakÄ±nsa daha kontrollÃ¼
            if (distToGoal < 22) {
                baseVz = 2.8 + (Math.random() * 0.5); // YakÄ±n frikik: 2.8 - 3.3
            } else {
                baseVz = 3.2 + (Math.random() * 0.8); // Uzak frikik: 3.2 - 4.0
            }
            // Frikiklerde power biraz dÃ¼ÅŸÃ¼rÃ¼lÃ¼r (kontrol iÃ§in)
            shotSpeed *= 0.95;
        }

        if (shotType === 'CHIP') {
            this.sim.ball.vz = 3.5 + (Math.random() * 1.5); // Daha yÃ¼ksek (3.5-5.0)
            shotSpeed *= 0.65; // Daha yumuÅŸak vuruÅŸ
            spread *= 0.9; // Biraz daha zor
        } else if (shotType === 'FREE_KICK') {
            this.sim.ball.vz = baseVz;
        } else if (distToGoal > 25) {
            this.sim.ball.vz = 0.5 + Math.random();
        } else {
            this.sim.ball.vz = 0.2 + (Math.random() * 0.7);
        }

        // Curve
        if (shotType === 'FREE_KICK') {
            const hasCurve = p.playStyles?.includes("Plase Åžut") || p.playStyles?.includes("Plase Åžut+");
            const yDiff = pos.y - 50;
            if (hasCurve) {
                this.sim.ball.curve = yDiff > 0 ? -1.4 : 1.4; // Increased curve 1.2 -> 1.4
            } else {
                this.sim.ball.curve = yDiff > 0 ? -0.7 : 0.7; // 0.6 -> 0.7
            }
        } else if (p.playStyles.includes("Plase Åžut") || Math.random() > 0.75) {
            const yDiff = pos.y - 50;
            this.sim.ball.curve = yDiff > 0 ? -0.8 : 0.8;
        } else { this.sim.ball.curve = 0; }

        this.playerStates[p.id].possessionCooldown = 15;
        this.sim.players[p.id].state = 'KICK';
        this.lastTouchTeamId = p.teamId;
        this.lastShooterId = p.id;
        this.traceLog.push(traceText);
    }


    private handleRedCardTactics(teamId: string, lostPosition: Position) {
        // Only for AI (user manages their own red cards)
        if (teamId === this.userTeamId) return;

        const isHome = teamId === this.homeTeam.id;
        const subsMade = isHome ? this.homeSubsMade : this.awaySubsMade;

        // If no subs left, we can't do much
        if (subsMade >= this.MAX_SUBS) return;

        // If we lost a DEFENDER or GOALKEEPER, we MUST fill that gap to prevent easy goals
        if (lostPosition === Position.DEF || lostPosition === Position.GK) {
            const bench = (isHome ? this.homePlayers : this.awayPlayers)
                .filter(p => p.lineup === 'BENCH' && !this.substitutedOutPlayerIds.has(p.id));

            // Find a replacement on bench (same position preferred)
            const replacement = bench.find(p => {
                const role = normalizePos(p);
                return role === lostPosition; // Find a new DEF/GK
            });

            if (replacement) {
                // We need to sacrifice someone.
                // Sacrifice the worst performing FWD or MID
                const starters = (isHome ? this.homePlayers : this.awayPlayers)
                    .filter(p => p.lineup === 'STARTING' && this.sim.players[p.id]); // Must be on pitch

                // Prioritize sacrificing FWD, then MID
                let sacrifice: Player | undefined = starters
                    .filter(p => this.playerRoles[p.id] === Position.FWD)
                    .sort((a, b) => (this.playerStates[a.id]?.currentStamina || 0) - (this.playerStates[b.id]?.currentStamina || 0))[0];

                if (!sacrifice) {
                    sacrifice = starters
                        .filter(p => this.playerRoles[p.id] === Position.MID)
                        .sort((a, b) => (this.playerStates[a.id]?.currentStamina || 0) - (this.playerStates[b.id]?.currentStamina || 0))[0];
                }

                if (sacrifice) {
                    // Correct signature: playerIn (Object), playerOutId (String), isAI (Boolean)
                    this.substitutePlayer(replacement, sacrifice.id, true);
                    this.traceLog.push(`AI TAKTÄ°K: KÄ±rmÄ±zÄ± kart sonrasÄ± ${sacrifice.lastName} Ã§Ä±ktÄ±, ${replacement.lastName} girdi.`);
                }
            }
        }
    }

    private actionTackle(defender: Player, attacker: Player) {
        if (!attacker) return;

        const defState = this.playerStates[defender.id];
        const attState = this.playerStates[attacker.id];
        // CRASH FIX: Guard clause for missing state
        if (!defState || !attState) return;

        const tactic = defender.teamId === this.homeTeam.id ? this.homeTeam.tactic : this.awayTeam.tactic;

        const defIsGK = defender.position === Position.GK;
        const defFatigueMods = getAllFatigueModifiers(defState.currentStamina, defIsGK);

        // BUFF: General Defense Quality +10% (was +5%)
        let effectiveDef = (applyStatFloor(defender.attributes.tackling, 45) * defFatigueMods.tackling) * 1.10;
        const defStrength = applyStatFloor(defender.attributes.strength, 40) * defFatigueMods.strength;
        // Aggression is raw, others are floor-scaled
        const defAggression = defender.attributes.aggression * defFatigueMods.aggression;
        const defDecisions = applyStatFloor(defender.attributes.decisions, 40) * defFatigueMods.decisions;
        const defPositioning = applyStatFloor(defender.attributes.positioning, 45) * defFatigueMods.positioning;

        // Composite Defense Score
        effectiveDef = (effectiveDef * 0.7) + (defStrength * 0.2) + (defPositioning * 0.1);

        // Fatigue Impact (Tweaked: 0.6 -> 0.75)
        if (defState.currentStamina < 50) effectiveDef *= 0.75;

        // Savunma Yetenekleri
        if (defender.playStyles?.includes("Top Kesici") || defender.playStyles?.includes("Top Kesici+")) effectiveDef *= 1.30;
        if (defender.playStyles?.includes("Kayarak MÃ¼dahale") || defender.playStyles?.includes("Kayarak MÃ¼dahale+")) effectiveDef *= 1.25;
        if (defender.playStyles?.includes("GÃ¼Ã§lÃ¼") || defender.playStyles?.includes("GÃ¼Ã§lÃ¼+")) effectiveDef *= 1.15;
        if (defender.playStyles?.includes("Engel") || defender.playStyles?.includes("Engel+")) effectiveDef *= 1.10;

        // HÃ¼cumcu StatlarÄ±
        const attIsGK = attacker.position === Position.GK;
        const attFatigueMods = getAllFatigueModifiers(attState.currentStamina, attIsGK);

        // BUFF: General Dribbling Quality +5%
        let effectiveDri = (attacker.attributes.dribbling * attFatigueMods.dribbling) * 1.05;
        const attStrength = attacker.attributes.strength * attFatigueMods.strength;
        const attComposure = attacker.attributes.composure * attFatigueMods.composure;
        const attSpeed = attacker.attributes.speed * attFatigueMods.speed;

        effectiveDri = (effectiveDri * 0.6) + (attComposure * 0.2) + (attStrength * 0.1) + (attSpeed * 0.1);

        // HÃ¼cum Yetenekleri
        if (attacker.playStyles?.includes("Ezber Bozan") || attacker.playStyles?.includes("Ezber Bozan+")) effectiveDri *= 1.25;
        if (attacker.playStyles?.includes("Teknik") || attacker.playStyles?.includes("Teknik+")) effectiveDri *= 1.10;
        if (attacker.playStyles?.includes("BaskÄ±ya DayanÄ±klÄ±") || attacker.playStyles?.includes("BaskÄ±ya DayanÄ±klÄ±+")) effectiveDri *= 1.12;

        // === YILDIZ OYUNCU BONUSU (DRIBBLING) ===
        // OVR 85+ hÃ¼cumcular kilidi aÃ§sÄ±n!
        const attackerOVR = attacker.overall || 70;
        if (attackerOVR >= 85) {
            effectiveDri *= 1.15; // %15 dribling bonusu
        } else if (attackerOVR >= 80) {
            effectiveDri *= 1.08; // %8 dribling bonusu
        }

        let riskFactor = 1.0;
        if (tactic.aggression === 'Aggressive') {
            effectiveDef *= 1.25;
            riskFactor = 2.2;
        } else if (tactic.aggression === 'Reckless') { // YENÄ°: KASAP MODU
            effectiveDef *= 1.45; // %45 DEFANS BONUSU (Neredeyse geÃ§ilmez)
            riskFactor = 3.5;     // %250 daha fazla faul riski
        } else if (tactic.aggression === 'Safe') {
            effectiveDef *= 0.85;
            riskFactor = 0.6;
        }

        // TACTICAL BUFF: "Park The Bus" Defense is unbreakable
        if (tactic.style === 'ParkTheBus') effectiveDef *= 1.3;
        // TACTICAL BUFF: "High Press" Defense is messy but aggressive
        if (tactic.style === 'HighPress') effectiveDef *= 1.1;

        const decisionPenalty = Math.max(0.7, defDecisions / 100);
        // === TACKLE BALANCE v8: NEUTRAL BIAS (RESTORED) ===
        // Engine 4 Standard: 0.45 / 0.45
        // Removed global 0.98 nerf
        const rollD = effectiveDef * (Math.random() + 0.45) * decisionPenalty;
        const rollA = effectiveDri * (Math.random() + 0.45);

        if (rollD > rollA) {
            // BaÅŸarÄ±lÄ± MÃ¼dahale
            if (Math.random() < 0.4) {
                // Top boÅŸta kalÄ±r
                this.sim.ball.ownerId = null;
                this.sim.ball.vx = (Math.random() - 0.5) * 2;
                this.sim.ball.vy = (Math.random() - 0.5) * 2;

                // Safe access via local vars wouldn't work for write, must use array
                this.playerStates[attacker.id].possessionCooldown = 20;
                this.playerStates[defender.id].possessionCooldown = 10;

                this.traceLog.push(`${defender.lastName} mÃ¼dahale etti, top boÅŸta!`);
                this.lastTouchTeamId = defender.teamId;
                // Topu kazanÄ±r
                this.sim.ball.ownerId = defender.id;
                this.playerStates[attacker.id].possessionCooldown = 30;
                this.playerStates[attacker.id].actionLock = 25;
                this.sim.players[defender.id].state = 'TACKLE';
                this.traceLog.push(`${defender.lastName} topu kaptÄ±!`);
                this.lastTouchTeamId = defender.teamId;
            }
        } else {
            // MÃ¼dahale BaÅŸarÄ±sÄ±z - Ã‡alÄ±m Yedi veya FAUL!

            // === FOUL DETECTION (BALANCED v4 - AZ FAUL) ===
            // GerÃ§ek futbolda maÃ§ baÅŸÄ±na ortalama 10-12 faul olur (toplam iki takÄ±m)
            // TakÄ±m baÅŸÄ±na 5-6 faul normal
            // BALANCED: Safe: %5, Normal: %10, Aggressive: %22, Reckless: %35
            let foulChance = riskFactor * 0.10; // 0.16 â†’ 0.10

            // === PANIC FOUL (LAST MAN) - AZALTILDI ===
            let isPanicFoul = false;

            const isDefenderHome = defender.teamId === this.homeTeam.id;
            const attackerSim = this.sim.players[attacker.id];
            if (defender.position === Position.DEF && attackerSim) {
                const distToGoal = isDefenderHome ? attackerSim.x : (PITCH_LENGTH - attackerSim.x);
                if (distToGoal < 25 && Math.random() < 0.05 && tactic.aggression !== 'Safe') { // 30â†’25m, 0.10â†’0.05
                    foulChance += 0.20; // 0.40 â†’ 0.20
                    isPanicFoul = true;
                }
            }

            const isFoul = Math.random() < foulChance;

            if (isFoul) {
                // FAUL! Serbest vuruÅŸ verilir
                const defPos = this.sim.players[defender.id];
                const attPos = this.sim.players[attacker.id];

                // Store foul position for free kick
                this.foulPosition = { x: attPos?.x ?? 50, y: attPos?.y ?? 50 };

                // Panic Foul = Almost certanly a card
                if (isPanicFoul) {
                    this.traceLog.push(`ðŸŸ¥ ${defender.lastName} son adam olarak indirdi! (Profesyonel Faul)`);
                }


                // Determine which team gets the free kick (or penalty)
                const attackingTeamIsHome = attacker.teamId === this.homeTeam.id;
                const defenderTeamIsHome = defender.teamId === this.homeTeam.id;

                // === PENALTY CHECK ===
                // Check if foul is in the penalty area of the DEFENDING team
                // Penalty Box Y range (centered): 34 Â± 20.16 = 13.84 to 54.16
                const isInsideBoxY = this.foulPosition.y > (34 - 20.16) && this.foulPosition.y < (34 + 20.16);
                let isPenalty = false;

                if (isInsideBoxY) {
                    if (defenderTeamIsHome) {
                        // Home defends Left (0-16.5)
                        if (this.foulPosition.x < 16.5) isPenalty = true;
                    } else {
                        // Away defends Right (88.5-105)
                        if (this.foulPosition.x > (105 - 16.5)) isPenalty = true;
                    }
                }

                // Card chance: based on aggression and how bad the foul is
                const cardRoll = Math.random();
                // BALANCED CARD RATES v4 (AZALTILDI):
                // GerÃ§ek futbol: MaÃ§ baÅŸÄ±na 3-4 sarÄ±, 0.1 kÄ±rmÄ±zÄ±
                // Safe: Yellow 6%, Red 0.3%
                // Normal: Yellow 12%, Red 0.5%
                // Aggressive: Yellow 18%, Red 1.5%
                // Reckless: Yellow 35%, Red 8%

                let yellowChance = 0.12; // 0.15 â†’ 0.12
                let redChance = 0.005;   // 0.01 â†’ 0.005

                // Penalty iÃ§indeki faul (DOGSO - azaltÄ±ldÄ±)
                if (isPenalty) {
                    yellowChance += 0.15; // 0.20 â†’ 0.15
                    redChance += 0.05;    // 0.10 â†’ 0.05
                }

                if (tactic.aggression === 'Aggressive') {
                    yellowChance = 0.18; // 0.25 â†’ 0.18
                    redChance = 0.015;   // 0.03 â†’ 0.015
                } else if (tactic.aggression === 'Reckless') {
                    yellowChance = 0.35; // 0.50 â†’ 0.35
                    redChance = 0.08;    // 0.15 â†’ 0.08
                } else if (tactic.aggression === 'Safe') {
                    yellowChance = 0.06; // 0.08 â†’ 0.06
                    redChance = 0.003;   // 0.005 â†’ 0.003
                }

                let cardEvent: MatchEvent | null = null;

                // BUGFIX: Define player names early so they're accessible in all branches
                const defenderName = defender.lastName || defender.firstName || `#${defender.id.slice(0, 5)}`;

                // Check for Second Yellow Card
                const hasYellow = this.match.events.some(e => e.type === MatchEventType.CARD_YELLOW && e.playerId === defender.id) ||
                    this.pendingEvents.some(e => e.type === MatchEventType.CARD_YELLOW && e.playerId === defender.id);

                if (cardRoll < redChance || (cardRoll < yellowChance && hasYellow)) {
                    // RED CARD! (Direct or Second Yellow)
                    const isSecondYellow = cardRoll >= redChance;

                    cardEvent = {
                        minute: this.internalMinute,
                        type: MatchEventType.CARD_RED,
                        description: isSecondYellow ? `KÄ±rmÄ±zÄ± Kart! (Ã‡ift SarÄ±) ${defenderName}` : `KÄ±rmÄ±zÄ± Kart! ${defenderName}`,
                        teamId: defender.teamId,
                        playerId: defender.id
                    };

                    // UI INDICATOR FIX: Mark as suspended immediately
                    // Set to 2 because processWeeklyUpdate decrements BEFORE next match
                    // 2 â†’ 1 (after current week) â†’ still banned for next match â†’ 0 (after that)
                    defender.matchSuspension = 2;

                    // Remove player from pitch completely
                    defender.lineup = 'RESERVE';

                    // CRITICAL FIX: Also remove from simulation to prevent ghost player!
                    delete this.sim.players[defender.id];
                    delete this.playerStates[defender.id];

                    this.traceLog.push(isSecondYellow ? `ðŸŸ¥ ${defenderName} Ã‡Ä°FT SARIDAN KIRMIZI!` : `ðŸŸ¥ ${defenderName} KIRMIZI KART!`);

                    // AI TACTICAL RESPONSE: Sacrifice Attacker for Defender if needed
                    this.handleRedCardTactics(defender.teamId, normalizePos(defender));

                } else if (cardRoll < yellowChance) {
                    // YELLOW CARD
                    // Reuse defenderName from earlier (already defined above)
                    cardEvent = {
                        minute: this.internalMinute,
                        type: MatchEventType.CARD_YELLOW,
                        description: `SarÄ± Kart: ${defenderName}`,
                        teamId: defender.teamId,
                        playerId: defender.id
                    };
                    this.traceLog.push(`ðŸŸ¨ ${defenderName} SARI KART!`);
                }

                // Queue events
                // BUGFIX: Use fallback for attacker name too
                const attackerName = attacker.lastName || attacker.firstName || `#${attacker.id.slice(0, 5)}`;
                const foulEvent: MatchEvent = {
                    minute: this.internalMinute,
                    type: MatchEventType.FOUL,
                    description: `Faul: ${defenderName} â†’ ${attackerName}`,
                    teamId: defender.teamId,
                    playerId: defender.id
                };
                this.pendingEvents.push(foulEvent);

                if (cardEvent) {
                    this.pendingEvents.push(cardEvent);
                }

                const attackingTeam = attackingTeamIsHome ? this.homeTeam : this.awayTeam;

                // === PENALTY OR FREE KICK SETUP ===
                if (isPenalty) {
                    // PENALTY KICK
                    this.pendingEvents.push({
                        minute: this.internalMinute,
                        type: MatchEventType.PENALTY,
                        description: `PENALTI: ${attackingTeam.name}`,
                        teamId: attackingTeam.id
                    });
                    this.traceLog.push(`â€¼ï¸ PENALTI! ${defenderName}, ${attackerName}'i ceza sahasÄ±nda dÃ¼ÅŸÃ¼rdÃ¼!`);

                    const penaltyX = attackingTeamIsHome ? (105 - 11) : 11;
                    const penaltyY = 34;
                    this.placeBallForSetPiece(attackingTeam, penaltyX, penaltyY, false, attackingTeamIsHome ? 'PENALTY_HOME' : 'PENALTY_AWAY');

                } else {
                    // FREE KICK
                    const fkX = this.foulPosition?.x ?? 50;
                    const fkY = this.foulPosition?.y ?? 50;

                    this.placeBallForSetPiece(attackingTeam, fkX, fkY, true, attackingTeamIsHome ? 'FREE_KICK_HOME' : 'FREE_KICK_AWAY');

                    this.pendingEvents.push({
                        minute: this.internalMinute,
                        type: MatchEventType.FREE_KICK,
                        description: `Serbest VuruÅŸ: ${attackingTeam.name}`,
                        teamId: attackingTeam.id
                    });

                    this.traceLog.push(`âš ï¸ FAUL! ${defender.lastName} - Serbest vuruÅŸ ${attackingTeam.name}`);
                }
            } else {
                // Normal Ã§alÄ±m - faul yok
                const recoveryTime = 25 * riskFactor * (2 - defFatigueMods.speed);
                this.playerStates[defender.id].actionLock = recoveryTime;

                // HÄ±z kaybÄ±
                this.sim.players[defender.id].vx *= (0.2 / riskFactor);
                this.sim.players[defender.id].vy *= (0.2 / riskFactor);

                this.traceLog.push(`${attacker.lastName} rakibini geÃ§ti!`);
            }
        }
    }

    // New Helper for Set Pieces
    private placeBallForSetPiece(attackingTeam: Team, x: number, y: number, buildWall: boolean, mode: SetPieceMode) {
        // Set match mode
        this.sim.mode = mode;

        // Find best taker
        const attackingTeamPlayers = (attackingTeam.id === this.homeTeam.id ? this.homePlayers : this.awayPlayers)
            .filter(p => p.lineup === 'STARTING' && this.playerRoles[p.id] !== Position.GK);

        const taker = attackingTeamPlayers.sort((a, b) =>
            (b.attributes.passing + b.attributes.vision) - (a.attributes.passing + a.attributes.vision)
        )[0];

        if (taker && this.sim.players[taker.id]) {
            // Move taker to position
            this.sim.players[taker.id].x = x;
            this.sim.players[taker.id].y = y;
            this.sim.players[taker.id].vx = 0;
            this.sim.players[taker.id].vy = 0;
            this.sim.ball.ownerId = taker.id;
            this.sim.ball.x = x;
            this.sim.ball.y = y;
            this.sim.ball.vx = 0;
            this.sim.ball.vy = 0;
            this.sim.ball.vz = 0;
            if (this.playerStates[taker.id]) {
                this.playerStates[taker.id].actionLock = 30; // 5â†’30: PenaltÄ± kullanana kadar rakip Ã§alamaz!
            }
        }

        // === PENALTY: Clear all players from penalty area ===
        if (!buildWall && (mode === 'PENALTY_HOME' || mode === 'PENALTY_AWAY')) {
            const isPenaltyHome = mode === 'PENALTY_HOME';
            // Penalty is at goal side: Home attacks right (goalX=105), Away attacks left (goalX=0)
            const penaltyGoalX = isPenaltyHome ? PITCH_LENGTH : 0;

            // Position defending GK on the goal line
            const defendingPlayers = isPenaltyHome ? this.awayPlayers : this.homePlayers;
            const gk = defendingPlayers.find(p => this.playerRoles[p.id] === Position.GK && p.lineup === 'STARTING');
            if (gk && this.sim.players[gk.id]) {
                this.sim.players[gk.id].x = isPenaltyHome ? (PITCH_LENGTH - 1) : 1;
                this.sim.players[gk.id].y = PITCH_CENTER_Y;
                this.sim.players[gk.id].vx = 0;
                this.sim.players[gk.id].vy = 0;
                if (this.playerStates[gk.id]) {
                    this.playerStates[gk.id].actionLock = 10;
                }
            }

            // Penalty box dimensions:
            // X: 0 to 16.5 (left) or 88.5 to 105 (right)
            // Y: ~13.84 to ~54.16 (34 Â± 20.16)
            const boxMinY = PITCH_CENTER_Y - 22;
            const boxMaxY = PITCH_CENTER_Y + 22;
            const boxXLimit = 16.5;

            // Push ALL players (both teams) outside the penalty area except taker and GK
            // === PENALTY D ARC: Oyuncular penaltÄ± noktasÄ±ndan 9.15m uzakta olmalÄ± ===
            const penaltySpotX = isPenaltyHome ? (PITCH_LENGTH - PENALTY_SPOT) : PENALTY_SPOT;
            const allPlayers = [...this.homePlayers, ...this.awayPlayers]
                .filter(p => p.lineup === 'STARTING' && this.sim.players[p.id]);

            let pushIndex = 0; // OyuncularÄ± dÃ¼zenli daÄŸÄ±tmak iÃ§in
            for (const p of allPlayers) {
                // Skip the taker
                if (taker && p.id === taker.id) continue;
                // Skip defending GK
                if (gk && p.id === gk.id) continue;

                const simP = this.sim.players[p.id];
                if (!simP) continue;

                // PenaltÄ± noktasÄ±na mesafe - D arc kontrolÃ¼ (9.15m)
                const distToPenaltySpot = Math.sqrt(
                    (simP.x - penaltySpotX) ** 2 + (simP.y - PITCH_CENTER_Y) ** 2
                );

                let isInsideBox = false;
                if (isPenaltyHome) {
                    isInsideBox = simP.x > (PITCH_LENGTH - boxXLimit) && simP.y > boxMinY && simP.y < boxMaxY;
                } else {
                    isInsideBox = simP.x < boxXLimit && simP.y > boxMinY && simP.y < boxMaxY;
                }

                // PenaltÄ± noktasÄ±na 9.15m'den yakÄ±n olan veya ceza sahasÄ±nda olan herkesi it
                if (isInsideBox || distToPenaltySpot < 9.15) {
                    // OyuncularÄ± ceza sahasÄ±nÄ±n DIÅžINA, D Ã§izgisinin arkasÄ±na yerleÅŸtir
                    if (isPenaltyHome) {
                        simP.x = PITCH_LENGTH - boxXLimit - 5; // 5m dÄ±ÅŸarÄ± (3mâ†’5m)
                    } else {
                        simP.x = boxXLimit + 5;
                    }
                    // OyuncularÄ± yarÄ±m daire (D) boyunca dÃ¼zenli daÄŸÄ±t
                    const spreadAngle = -0.8 + (pushIndex / Math.max(1, allPlayers.length - 2)) * 1.6;
                    simP.y = PITCH_CENTER_Y + Math.sin(spreadAngle) * 18;
                    simP.y = clamp(simP.y, boxMinY, boxMaxY);
                    simP.vx = 0;
                    simP.vy = 0;
                    pushIndex++;
                    if (this.playerStates[p.id]) {
                        this.playerStates[p.id].actionLock = 120; // 2 saniye tut (15â†’120)
                    }
                }
            }
        }

        if (buildWall) {
            // === WALL FORMATION ===
            // Position 3-4 defenders in a wall between ball and goal
            const enemyTeam = (attackingTeam.id === this.homeTeam.id ? this.awayPlayers : this.homePlayers)
                .filter(p => p.lineup === 'STARTING' && this.playerRoles[p.id] !== Position.GK);

            // Determine which goal the free kick is aimed at
            const targetGoalX = attackingTeam.id === this.homeTeam.id ? 100 : 0; // Attacking towards this goal
            const wallDistance = 10; // 9.15m scaled

            // === GK POSITIONING ===
            // Ensure GK is on the line
            const enemyPlayersArr = (attackingTeam.id === this.homeTeam.id ? this.awayPlayers : this.homePlayers);
            const gk = enemyPlayersArr.find(p => this.playerRoles[p.id] === Position.GK);
            if (gk && this.sim.players[gk.id]) {
                this.sim.players[gk.id].x = targetGoalX > 50 ? 100 : 5; // On the line (slightly off 0/105)
                this.sim.players[gk.id].y = 34; // Center
                this.sim.players[gk.id].vx = 0;
                this.sim.players[gk.id].vy = 0;
            }

            // Calculate wall position (between ball and goal)
            const angleToGoal = Math.atan2(34 - y, targetGoalX - x); // Target center Y=34
            const wallCenterX = x + Math.cos(angleToGoal) * wallDistance;
            const wallCenterY = y + Math.sin(angleToGoal) * wallDistance;

            // Select 3-4 closest defenders for wall
            const wallSize = x > 20 && x < 80 ? 4 : 3; // Bigger wall for dangerous positions
            const wallPlayers = enemyTeam
                .filter(p => this.sim.players[p.id] && (!gk || p.id !== gk.id)) // Exclude GK from wall
                .sort((a, b) => {
                    const distA = dist(x, y, this.sim.players[a.id].x, this.sim.players[a.id].y);
                    const distB = dist(x, y, this.sim.players[b.id].x, this.sim.players[b.id].y);
                    return distA - distB;
                })
                .slice(0, wallSize);

            // Position wall players
            const perpAngle = angleToGoal + Math.PI / 2;
            const wallSpacing = 2.5;

            wallPlayers.forEach((wp, idx) => {
                const simWp = this.sim.players[wp.id];
                if (simWp) {
                    const offset = (idx - (wallPlayers.length - 1) / 2) * wallSpacing;
                    simWp.x = wallCenterX + Math.cos(perpAngle) * offset;
                    simWp.y = wallCenterY + Math.sin(perpAngle) * offset;
                    simWp.vx = 0;
                    simWp.vy = 0;
                    simWp.facing = Math.atan2(y - simWp.y, x - simWp.x);
                    if (this.playerStates[wp.id]) {
                        this.playerStates[wp.id].actionLock = 8;
                    }
                }
            });

            // Push other nearby opponents back
            const wallPlayerIds = new Set(wallPlayers.map(p => p.id));
            enemyTeam.forEach(ep => {
                if (wallPlayerIds.has(ep.id)) return;
                const simEp = this.sim.players[ep.id];
                if (simEp && dist(x, y, simEp.x, simEp.y) < 12) {
                    const dx = simEp.x - x;
                    const dy = simEp.y - y;
                    const d = Math.max(0.1, Math.sqrt(dx * dx + dy * dy));
                    simEp.x = x + (dx / d) * 14;
                    simEp.y = y + (dy / d) * 14;
                    simEp.vx = 0;
                    simEp.vy = 0;
                }
            });
        }
    }

    // === CANLI MAÃ‡ LOG SÄ°STEMÄ° ===
    // MaÃ§Ä± saniye saniye izlemek iÃ§in detaylÄ± yorumcu stili log
    private logDebugSnapshot(): void {
        const ballX = this.sim.ball.x;
        const ballY = this.sim.ball.y;
        const ballOwner = this.sim.ball.ownerId ? this.getPlayer(this.sim.ball.ownerId) : null;
        const owningTeamId = ballOwner?.teamId || null;

        // TÃ¼m oyuncular
        const allStarters = [...this.homePlayers, ...this.awayPlayers].filter(p => p.lineup === 'STARTING');
        const homePlayers = allStarters.filter(p => p.teamId === this.homeTeam.id);
        const awayPlayers = allStarters.filter(p => p.teamId === this.awayTeam.id);

        // BÃ¶lge analizi
        const getZone = (x: number): string => {
            if (x < 25) return 'DEF';
            if (x < 40) return 'DEF-MID';
            if (x < 65) return 'MID';
            if (x < 80) return 'ATK-MID';
            return 'ATK';
        };

        const getYZone = (y: number): string => {
            if (y < 20) return 'SOL';
            if (y < 48) return 'ORTA';
            return 'SAÄž';
        };

        // === DEVELOPMENT MODE DISABLED ===
        // DetaylÄ± debug loglarÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±. Daha sonra ihtiyaÃ§ olursa:
        // - Defans analizi
        // - Pressing koordinasyonu
        // - Formation tracking
        // iÃ§in bu fonksiyon aÃ§Ä±labilir.

        // Åžimdilik boÅŸ kalmÄ±yor, ileride development mode flag'i eklenebilir
        if (false) { // SET TO TRUE FOR DEBUG
            // DEBUG LOGS HERE
        }
    }
    // === G MOTORU: GÃ–RÃœÅž AÃ‡ISI HESAPLAMA ===
    // Bir oyuncunun belirli bir hedefe (genelde kale veya koÅŸu yolu) ne kadar rahat ulaÅŸabileceÄŸini hesaplar.
    // 0.0 = Tamamen kapalÄ± (Ã¶nÃ¼nde adam var)
    // 1.0 = Tamamen aÃ§Ä±k (dÃ¼mdÃ¼z boÅŸluk)



}

